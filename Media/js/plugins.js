/*-------------------------------  main.js  ------------------------------------*/
    $(document).ready(function() {

    /*! http://mths.be/placeholder v2.0.8 by @mathias */
        (function (window, document, $) {

            // Opera Mini v7 doesn’t support placeholder although its DOM seems to indicate so
            var isOperaMini = Object.prototype.toString.call(window.operamini) == '[object OperaMini]';
            var isInputSupported = 'placeholder' in document.createElement('input') && !isOperaMini;
            var isTextareaSupported = 'placeholder' in document.createElement('textarea') && !isOperaMini;
            var prototype = $.fn;
            var valHooks = $.valHooks;
            var propHooks = $.propHooks;
            var hooks;
            var placeholder;

            if (isInputSupported && isTextareaSupported) {

                placeholder = prototype.placeholder = function() {
                    return this;
                };

                placeholder.input = placeholder.textarea = true;

            } else {

                placeholder = prototype.placeholder = function() {
                    var $this = this;
                    $this
                        .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
                        .not('.placeholder')
                        .bind({
                            'focus.placeholder': clearPlaceholder,
                            'blur.placeholder': setPlaceholder
                        })
                        .data('placeholder-enabled', true)
                        .trigger('blur.placeholder');
                    return $this;
                };

                placeholder.input = isInputSupported;
                placeholder.textarea = isTextareaSupported;

                hooks = {
                    'get': function(element) {
                        var $element = $(element);

                        var $passwordInput = $element.data('placeholder-password');
                        if ($passwordInput) {
                            return $passwordInput[0].value;
                        }

                        return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
                    },
                    'set': function(element, value) {
                        var $element = $(element);

                        var $passwordInput = $element.data('placeholder-password');
                        if ($passwordInput) {
                            return $passwordInput[0].value = value;
                        }

                        if (!$element.data('placeholder-enabled')) {
                            return element.value = value;
                        }
                        if (value == '') {
                            element.value = value;
                            // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                            if (element != safeActiveElement()) {
                                // We can't use `triggerHandler` here because of dummy text/password inputs :(
                                setPlaceholder.call(element);
                            }
                        } else if ($element.hasClass('placeholder')) {
                            clearPlaceholder.call(element, true, value) || (element.value = value);
                        } else {
                            element.value = value;
                        }
                        // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                        return $element;
                    }
                };

                if (!isInputSupported) {
                    valHooks.input = hooks;
                    propHooks.value = hooks;
                }
                if (!isTextareaSupported) {
                    valHooks.textarea = hooks;
                    propHooks.value = hooks;
                }

                $(function() {
                    // Look for forms
                    $(document).delegate('form', 'submit.placeholder', function() {
                        // Clear the placeholder values so they don't get submitted
                        var $inputs = $('.placeholder', this).each(clearPlaceholder);
                        setTimeout(function() {
                            $inputs.each(setPlaceholder);
                        }, 10);
                    });
                });

                // Clear placeholder values upon page reload
                $(window).bind('beforeunload.placeholder', function() {
                    $('.placeholder').each(function() {
                        this.value = '';
                    });
                });

            }

            function args(elem) {
                // Return an object of element attributes
                var newAttrs = {};
                var rinlinejQuery = /^jQuery\d+$/;
                $.each(elem.attributes, function(i, attr) {
                    if (attr.specified && !rinlinejQuery.test(attr.name)) {
                        newAttrs[attr.name] = attr.value;
                    }
                });
                return newAttrs;
            }

            function clearPlaceholder(event, value) {
                var input = this;
                var $input = $(input);
                if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
                    if ($input.data('placeholder-password')) {
                        $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
                        // If `clearPlaceholder` was called from `$.valHooks.input.set`
                        if (event === true) {
                            return $input[0].value = value;
                        }
                        $input.focus();
                    } else {
                        input.value = '';
                        $input.removeClass('placeholder');
                        input == safeActiveElement() && input.select();
                    }
                }
            }

            function setPlaceholder() {
                var $replacement;
                var input = this;
                var $input = $(input);
                var id = this.id;
                if (input.value == '') {
                    if (input.type == 'password') {
                        if (!$input.data('placeholder-textinput')) {
                            try {
                                $replacement = $input.clone().attr({ 'type': 'text' });
                            } catch(e) {
                                $replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
                            }
                            $replacement
                                .removeAttr('name')
                                .data({
                                    'placeholder-password': $input,
                                    'placeholder-id': id
                                })
                                .bind('focus.placeholder', clearPlaceholder);
                            $input
                                .data({
                                    'placeholder-textinput': $replacement,
                                    'placeholder-id': id
                                })
                                .before($replacement);
                        }
                        $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
                        // Note: `$input[0] != input` now!
                    }
                    $input.addClass('placeholder');
                    $input[0].value = $input.attr('placeholder');
                } else {
                    $input.removeClass('placeholder');
                }
            }

            function safeActiveElement() {
                // Avoid IE9 `document.activeElement` of death
                // https://github.com/mathiasbynens/jquery-placeholder/pull/99
                try {
                    return document.activeElement;
                } catch (exception) {}
            }

        }(this, document, jQuery));



        if (Modernizr.ie9) {
            $('input, textarea').placeholder();
        }
        
        /*-----------------------*/
        $(window).load(function() {

            jQuery.fn.liQuotes = function(options) {
                var o = jQuery.extend({}, options);
                return this.each(function() {
                    htmlreplace($(this));

                    function htmlreplace(element) {
                        if (!element) element = document.body;
                        var nodes = $(element).contents().each(function() {
                            if (this.nodeType == Node.TEXT_NODE) {
                                $(this).wrap('<span class="node_t"/>');
                            } else {
                                htmlreplace(this);
                            }
                        });
                    }
                    $('.node_t').each(function() {
                        var el = $(this),
                            str = el.html(),
                            raquo_one = /'\s/g,
                            laquo_one = /\s'/g,
                            raquo_two = /"\s/g,
                            laquo_two = /\s"/g,
                            raquo_brack_one = /'\)/g,
                            laquo_brack_one = /\('/g,
                            raquo_brack_two = /"\)/g,
                            laquo_brack_two = /\("/g,
                            raquo_tag_one = /'$/g,
                            laquo_tag_one = /^'/g,
                            raquo_tag_two = /"$/g,
                            laquo_tag_two = /^"/g,
                            raquo_one_coma = /'\,/g,
                            raquo_one_dot = /'\./g,
                            raquo_two_coma = /"\,/g,
                            raquo_two_dot = /"\./g,
                            raquo_one_colon = /'\:/g,
                            raquo_two_colon = /"\:/g,
                            quest_one_colon = /'\?/g,
                            quest_two_colon = /"\?/g,
                            exclam_one_colon = /'\!/g,
                            exclam_two_colon = /"\!/g,
                            semic_one_colon = /'\;/g,
                            semic_two_colon = /"\;/g;
                        var result = str.replace(laquo_one, " &laquo;").replace(raquo_one, "&raquo; ").replace(laquo_two, " &laquo;").replace(raquo_two, "&raquo; ").replace(raquo_one_coma, "&raquo;,").replace(raquo_one_dot, "&raquo;.").replace(raquo_two_coma, "&raquo;,").replace(raquo_two_dot, "&raquo;.").replace(raquo_one_colon, "&raquo;:").replace(raquo_two_colon, "&raquo;:").replace(quest_one_colon, "&raquo;?").replace(quest_two_colon, "&raquo;?").replace(exclam_one_colon, "&raquo;!").replace(exclam_two_colon, "&raquo;!").replace(laquo_brack_one, "(&laquo;").replace(raquo_brack_one, "&raquo;)").replace(laquo_brack_two, "(&laquo;").replace(raquo_brack_two, "&raquo;)").replace(laquo_tag_one, "&laquo;").replace(raquo_tag_one, "&raquo;").replace(laquo_tag_two, "&laquo;").replace(raquo_tag_two, "&raquo;").replace(semic_one_colon, "&raquo;;").replace(semic_two_colon, "&raquo;;");
                        el.html(result);
                    });
                    $('.node_t').each(function() {
                        var html = $(this).html();
                        $(this).after(html).remove();
                    });
                });
            };
            $('.q').liQuotes();
        });
    });
/*-------------------------------  liValidForm.js  ------------------------------------*/ 
    $.extend($.fn, {
    validateDelegate: function(delegate, type, handler) {
        return this.bind(type, function(event) {
            var target = $(event.target);
            if (target.is(delegate)) {
                return handler.apply(target, arguments);
            }
        });
    }
});
$.extend($.fn, {
    validate: function(options) {
        if (!this.length) {
            if (options && options.debug && window.console) {
                console.warn("Nothing selected, can't validate, returning nothing.");
            }
            return;
        }
        var validator = $.data(this[0], "validator");
        if (validator) {
            return validator;
        }
        this.attr("novalidate", "novalidate");
        validator = new $.validator(options, this[0]);
        $.data(this[0], "validator", validator);
        if (validator.settings.onsubmit) {
            this.validateDelegate(":submit", "click", function(event) {
                if (validator.settings.submitHandler) {
                    validator.submitButton = event.target;
                }
                if ($(event.target).hasClass("cancel")) {
                    validator.cancelSubmit = true;
                }
                if ($(event.target).attr("formnovalidate") !== undefined) {
                    validator.cancelSubmit = true;
                }
            });
            this.submit(function(event) {
                if (validator.settings.debug) {
                    event.preventDefault();
                }

                function handle() {
                    var hidden, result;
                    if (validator.settings.submitHandler) {
                        if (validator.submitButton) {
                            hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm);
                        }
                        result = validator.settings.submitHandler.call(validator, validator.currentForm, event);
                        if (validator.submitButton) {
                            hidden.remove();
                        }
                        if (result !== undefined) {
                            return result;
                        }
                        return false;
                    }
                    return true;
                }
                if (validator.cancelSubmit) {
                    validator.cancelSubmit = false;
                    return handle();
                }
                if (validator.form()) {
                    if (validator.pendingRequest) {
                        validator.formSubmitted = true;
                        return false;
                    }
                    return handle();
                } else {
                    validator.focusInvalid();
                    return false;
                }
            });
        }
        return validator;
    },
    valid: function() {
        var valid, validator, errorList;
        if ($(this[0]).is("form")) {
            valid = this.validate().form();
        } else if ($(this[0]).is("div")) {
            valid = this.validate().form();
        } else {
            errorList = [];
            valid = true;
            validator = $(this[0].form).validate();
            this.each(function() {
                valid = validator.element(this) && valid;
                errorList = errorList.concat(validator.errorList);
            });
            validator.errorList = errorList;
        }
        return valid;
    },
    removeAttrs: function(attributes) {
        var result = {},
            $element = this;
        $.each(attributes.split(/\s/), function(index, value) {
            result[value] = $element.attr(value);
            $element.removeAttr(value);
        });
        return result;
    },
    rules: function(command, argument) {
        var element = this[0],
            settings, staticRules, existingRules, data, param, filtered;
        if (command) {
            settings = $.data(element.form, "validator").settings;
            staticRules = settings.rules;
            existingRules = $.validator.staticRules(element);
            switch (command) {
                case "add":
                    $.extend(existingRules, $.validator.normalizeRule(argument));
                    delete existingRules.messages;
                    staticRules[element.name] = existingRules;
                    if (argument.messages) {
                        settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
                    }
                    break;
                case "remove":
                    if (!argument) {
                        delete staticRules[element.name];
                        return existingRules;
                    }
                    filtered = {};
                    $.each(argument.split(/\s/), function(index, method) {
                        filtered[method] = existingRules[method];
                        delete existingRules[method];
                        if (method === "required") {
                            $(element).removeAttr("aria-required");
                        }
                    });
                    return filtered;
            }
        }
        data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element);
        if (data.required) {
            param = data.required;
            delete data.required;
            data = $.extend({
                required: param
            }, data);
            $(element).attr("aria-required", "true");
        }
        if (data.remote) {
            param = data.remote;
            delete data.remote;
            data = $.extend(data, {
                remote: param
            });
        }
        return data;
    }
});
$.extend($.expr[":"], {
    blank: function(a) {
        return !$.trim("" + $(a).val());
    },
    filled: function(a) {
        return !!$.trim("" + $(a).val());
    },
    unchecked: function(a) {
        return !$(a).prop("checked");
    }
});
$.validator = function(options, form) {
    this.settings = $.extend(true, {}, $.validator.defaults, options);
    this.currentForm = form;
    this.init();
};
$.validator.format = function(source, params) {
    if (arguments.length === 1) {
        return function() {
            var args = $.makeArray(arguments);
            args.unshift(source);
            return $.validator.format.apply(this, args);
        };
    }
    if (arguments.length > 2 && params.constructor !== Array) {
        params = $.makeArray(arguments).slice(1);
    }
    if (params.constructor !== Array) {
        params = [params];
    }
    $.each(params, function(i, n) {
        source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function() {
            return n;
        });
    });
    return source;
};
$.extend($.validator, {
    defaults: {
        messages: {},
        groups: {},
        rules: {},
        errorClass: "error",
        validClass: "valid",
        errorElement: "label",
        focusCleanup: false,
        focusInvalid: true,
        errorContainer: $([]),
        errorLabelContainer: $([]),
        onsubmit: true,
        ignore: ":hidden",
        ignoreTitle: false,
        onfocusin: function(element) {
            this.lastActive = element;
            if (this.settings.focusCleanup) {
                if (this.settings.unhighlight) {
                    this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
                }
                this.hideThese(this.errorsFor(element));
            }
        },
        onfocusout: function(element) {
            if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
                this.element(element);
            }
        },
        onkeyup: function(element, event) {
            if (event.which === 9 && this.elementValue(element) === "") {

            } else if (element.name in this.submitted || element === this.lastElement) {
                this.element(element);
            }
        },
        onclick: function(element) {
            if (element.name in this.submitted) {
                this.element(element);
            } else if (element.parentNode.name in this.submitted) {
                this.element(element.parentNode);
            }
        },
        highlight: function(element, errorClass, validClass) {
            if (element.type === "radio") {
                this.findByName(element.name).addClass(errorClass).removeClass(validClass);
            } else {
                $(element).addClass(errorClass).removeClass(validClass);
            }
        },
        unhighlight: function(element, errorClass, validClass) {
            if (element.type === "radio") {
                this.findByName(element.name).removeClass(errorClass).addClass(validClass);
            } else {
                $(element).removeClass(errorClass).addClass(validClass);
            }
        }
    },
    setDefaults: function(settings) {
        $.extend($.validator.defaults, settings);
    },
    messages: {
        required: "This field is required.",
        remote: "Please fix this field.",
        email: "Please enter a valid email address.",
        url: "Please enter a valid URL.",
        date: "Please enter a valid date.",
        dateISO: "Please enter a valid date ( ISO ).",
        number: "Please enter a valid number.",
        digits: "Please enter only digits.",
        creditcard: "Please enter a valid credit card number.",
        equalTo: "Please enter the same value again.",
        maxlength: $.validator.format("Please enter no more than {0} characters."),
        minlength: $.validator.format("Please enter at least {0} characters."),
        rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
        range: $.validator.format("Please enter a value between {0} and {1}."),
        max: $.validator.format("Please enter a value less than or equal to {0}."),
        min: $.validator.format("Please enter a value greater than or equal to {0}.")
    },
    autoCreateRanges: false,
    prototype: {
        init: function() {
            this.labelContainer = $(this.settings.errorLabelContainer);
            this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
            this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
            this.submitted = {};
            this.valueCache = {};
            this.pendingRequest = 0;
            this.pending = {};
            this.invalid = {};
            this.reset();
            var groups = (this.groups = {}),
                rules;
            $.each(this.settings.groups, function(key, value) {
                if (typeof value === "string") {
                    value = value.split(/\s/);
                }
                $.each(value, function(index, name) {
                    groups[name] = key;
                });
            });
            rules = this.settings.rules;
            $.each(rules, function(key, value) {
                rules[key] = $.validator.normalizeRule(value);
            });

            function delegate(event) {
                var validator, form, eventType;
                form = this[0].form;
                if (!form) {
                    form = $(this).closest("div[data-form='true']").get(0);
                }
                validator = $.data(form, "validator"), eventType = "on" + event.type.replace(/^validate/, ""), this.settings = validator.settings;
                if (this.settings[eventType] && !this.is(this.settings.ignore)) {
                    this.settings[eventType].call(validator, this[0], event);
                }
            }
            $(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, " + "[type='number'], [type='search'] ,[type='tel'], [type='url'], " + "[type='email'], [type='datetime'], [type='date'], [type='month'], " + "[type='week'], [type='time'], [type='datetime-local'], " + "[type='range'], [type='color'], [type='radio'], [type='checkbox']", "focusin focusout keyup", delegate).validateDelegate("select, option, [type='radio'], [type='checkbox']", "click", delegate);
            if (this.settings.invalidHandler) {
                $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
            }
            $(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true");
        },
        form: function() {
            this.checkForm();
            $.extend(this.submitted, this.errorMap);
            this.invalid = $.extend({}, this.errorMap);
            if (!this.valid()) {
                $(this.currentForm).triggerHandler("invalid-form", [this]);
            }
            this.showErrors();
            return this.valid();
        },
        checkForm: function() {
            this.prepareForm();
            for (var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++) {
                this.check(elements[i]);
            }
            return this.valid();
        },
        element: function(element) {
            var cleanElement = this.clean(element),
                checkElement = this.validationTargetFor(cleanElement),
                result = true;
            this.lastElement = checkElement;
            if (checkElement === undefined) {
                delete this.invalid[cleanElement.name];
            } else {
                this.prepareElement(checkElement);
                this.currentElements = $(checkElement);
                result = this.check(checkElement) !== false;
                if (result) {
                    delete this.invalid[checkElement.name];
                } else {
                    this.invalid[checkElement.name] = true;
                }
            }
            $(element).attr("aria-invalid", !result);
            if (!this.numberOfInvalids()) {
                this.toHide = this.toHide.add(this.containers);
            }
            this.showErrors();
            return result;
        },
        showErrors: function(errors) {
            if (errors) {
                $.extend(this.errorMap, errors);
                this.errorList = [];
                for (var name in errors) {
                    this.errorList.push({
                        message: errors[name],
                        element: this.findByName(name)[0]
                    });
                }
                this.successList = $.grep(this.successList, function(element) {
                    return !(element.name in errors);
                });
            }
            if (this.settings.showErrors) {
                this.settings.showErrors.call(this, this.errorMap, this.errorList);
            } else {
                this.defaultShowErrors();
            }
        },
        resetForm: function() {
            if ($.fn.resetForm) {
                $(this.currentForm).resetForm();
            }
            this.submitted = {};
            this.lastElement = null;
            this.prepareForm();
            this.hideErrors();
            var i, elements = this.elements().removeData("previousValue").removeAttr("aria-invalid");
            if (this.settings.unhighlight) {
                for (i = 0; elements[i]; i++) {
                    this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, "");
                }
            } else {
                elements.removeClass(this.settings.errorClass);
            }
        },
        numberOfInvalids: function() {
            return this.objectLength(this.invalid);
        },
        objectLength: function(obj) {
            var count = 0,
                i;
            for (i in obj) {
                count++;
            }
            return count;
        },
        hideErrors: function() {
            this.hideThese(this.toHide);
        },
        hideThese: function(errors) {
            errors.not(this.containers).text("");
            this.addWrapper(errors).hide();
        },
        valid: function() {
            return this.size() === 0;
        },
        size: function() {
            return this.errorList.length;
        },
        focusInvalid: function() {
            if (this.settings.focusInvalid) {
                try {
                    $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin");
                } catch (e) {}
            }
        },
        findLastActive: function() {
            var lastActive = this.lastActive;
            return lastActive && $.grep(this.errorList, function(n) {
                return n.element.name === lastActive.name;
            }).length === 1 && lastActive;
        },
        elements: function() {
            var validator = this,
                rulesCache = {};
            return $(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function() {
                if (!this.name && validator.settings.debug && window.console) {
                    console.error("%o has no name assigned", this);
                }
                if (this.name in rulesCache || !validator.objectLength($(this).rules())) {
                    return false;
                }
                rulesCache[this.name] = true;
                return true;
            });
        },
        clean: function(selector) {
            return $(selector)[0];
        },
        errors: function() {
            var errorClass = this.settings.errorClass.split(" ").join(".");
            return $(this.settings.errorElement + "." + errorClass, this.errorContext);
        },
        reset: function() {
            this.successList = [];
            this.errorList = [];
            this.errorMap = {};
            this.toShow = $([]);
            this.toHide = $([]);
            this.currentElements = $([]);
        },
        prepareForm: function() {
            this.reset();
            this.toHide = this.errors().add(this.containers);
        },
        prepareElement: function(element) {
            this.reset();
            this.toHide = this.errorsFor(element);
        },
        elementValue: function(element) {
            var val, $element = $(element),
                type = element.type;
            if (type === "radio" || type === "checkbox") {
                return $("input[name='" + element.name + "']:checked").val();
            } else if (type === "number" && typeof element.validity !== "undefined") {
                return element.validity.badInput ? false : $element.val();
            }
            val = $element.val();
            if (typeof val === "string") {
                return val.replace(/\r/g, "");
            }
            return val;
        },
        check: function(element) {
            element = this.validationTargetFor(this.clean(element));
            var rules = $(element).rules(),
                rulesCount = $.map(rules, function(n, i) {
                    return i;
                }).length,
                dependencyMismatch = false,
                val = this.elementValue(element),
                result, method, rule;
            for (method in rules) {
                rule = {
                    method: method,
                    parameters: rules[method]
                };
                try {
                    result = $.validator.methods[method].call(this, val, element, rule.parameters);
                    if (result === "dependency-mismatch" && rulesCount === 1) {
                        dependencyMismatch = true;
                        continue;
                    }
                    dependencyMismatch = false;
                    if (result === "pending") {
                        this.toHide = this.toHide.not(this.errorsFor(element));
                        return;
                    }
                    if (!result) {
                        this.formatAndAdd(element, rule);
                        return false;
                    }
                } catch (e) {
                    if (this.settings.debug && window.console) {
                        console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e);
                    }
                    throw e;
                }
            }
            if (dependencyMismatch) {
                return;
            }
            if (this.objectLength(rules)) {
                this.successList.push(element);
            }
            return true;
        },
        customDataMessage: function(element, method) {
            return $(element).data("msg" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()) || $(element).data("msg");
        },
        customMessage: function(name, method) {
            var m = this.settings.messages[name];
            return m && (m.constructor === String ? m : m[method]);
        },
        findDefined: function() {
            for (var i = 0; i < arguments.length; i++) {
                if (arguments[i] !== undefined) {
                    return arguments[i];
                }
            }
            return undefined;
        },
        defaultMessage: function(element, method) {
            return this.findDefined(this.customMessage(element.name, method), this.customDataMessage(element, method), !this.settings.ignoreTitle && element.title || undefined, $.validator.messages[method], "<strong>Warning: No message defined for " + element.name + "</strong>");
        },
        formatAndAdd: function(element, rule) {
            var message = this.defaultMessage(element, rule.method),
                theregex = /\$?\{(\d+)\}/g;
            if (typeof message === "function") {
                message = message.call(this, rule.parameters, element);
            } else if (theregex.test(message)) {
                message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
            }
            this.errorList.push({
                message: message,
                element: element,
                method: rule.method
            });
            this.errorMap[element.name] = message;
            this.submitted[element.name] = message;
        },
        addWrapper: function(toToggle) {
            if (this.settings.wrapper) {
                toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
            }
            return toToggle;
        },
        defaultShowErrors: function() {
            var i, elements, error;
            for (i = 0; this.errorList[i]; i++) {
                error = this.errorList[i];
                if (this.settings.highlight) {
                    this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                }
                this.showLabel(error.element, error.message);
            }
            if (this.errorList.length) {
                this.toShow = this.toShow.add(this.containers);
            }
            if (this.settings.success) {
                for (i = 0; this.successList[i]; i++) {
                    this.showLabel(this.successList[i]);
                }
            }
            if (this.settings.unhighlight) {
                for (i = 0, elements = this.validElements(); elements[i]; i++) {
                    this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                }
            }
            this.toHide = this.toHide.not(this.toShow);
            this.hideErrors();
            this.addWrapper(this.toShow).show();
        },
        validElements: function() {
            return this.currentElements.not(this.invalidElements());
        },
        invalidElements: function() {
            return $(this.errorList).map(function() {
                return this.element;
            });
        },
        showLabel: function(element, message) {
            var place, group, errorID, error = this.errorsFor(element),
                elementID = this.idOrName(element),
                describedBy = $(element).attr("aria-describedby");
            if (error.length) {
                error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);
                error.html(message);
            } else {
                error = $("<" + this.settings.errorElement + ">").attr("id", elementID + "-error").addClass(this.settings.errorClass).html(message || "");
                place = error;
                if (this.settings.wrapper) {
                    place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                }
                if (this.labelContainer.length) {
                    this.labelContainer.append(place);
                } else if (this.settings.errorPlacement) {
                    this.settings.errorPlacement(place, $(element));
                } else {
                    place.insertAfter(element);
                } if (error.is("label")) {
                    error.attr("for", elementID);
                } else if (error.parents("label[for='" + elementID + "']").length === 0) {
                    errorID = error.attr("id").replace(/(:|\.|\[|\]|\$)/g, "\\$1");
                    if (!describedBy) {
                        describedBy = errorID;
                    } else if (!describedBy.match(new RegExp("\\b" + errorID + "\\b"))) {
                        describedBy += " " + errorID;
                    }
                    $(element).attr("aria-describedby", describedBy);
                    group = this.groups[element.name];
                    if (group) {
                        $.each(this.groups, function(name, testgroup) {
                            if (testgroup === group) {
                                $("[name='" + name + "']", this.currentForm).attr("aria-describedby", error.attr("id"));
                            }
                        });
                    }
                }
            } if (!message && this.settings.success) {
                error.text("");
                if (typeof this.settings.success === "string") {
                    error.addClass(this.settings.success);
                } else {
                    this.settings.success(error, element);
                }
            }
            this.toShow = this.toShow.add(error);
        },
        errorsFor: function(element) {
            var name = this.idOrName(element),
                describer = $(element).attr("aria-describedby"),
                selector = "label[for='" + name + "'], label[for='" + name + "'] *";
            if (describer) {
                selector = selector + ", #" + describer.replace(/\s+/g, ", #");
            }
            return this.errors().filter(selector);
        },
        idOrName: function(element) {
            return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
        },
        validationTargetFor: function(element) {
            if (this.checkable(element)) {
                element = this.findByName(element.name);
            }
            return $(element).not(this.settings.ignore)[0];
        },
        checkable: function(element) {
            return (/radio|checkbox/i).test(element.type);
        },
        findByName: function(name) {
            return $(this.currentForm).find("[name='" + name + "']");
        },
        getLength: function(value, element) {
            switch (element.nodeName.toLowerCase()) {
                case "select":
                    return $("option:selected", element).length;
                case "input":
                    if (this.checkable(element)) {
                        return this.findByName(element.name).filter(":checked").length;
                    }
            }
            return value.length;
        },
        depend: function(param, element) {
            return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
        },
        dependTypes: {
            "boolean": function(param) {
                return param;
            },
            "string": function(param, element) {
                return !!$(param, element.form).length;
            },
            "function": function(param, element) {
                return param(element);
            }
        },
        optional: function(element) {
            var val = this.elementValue(element);
            return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
        },
        startRequest: function(element) {
            if (!this.pending[element.name]) {
                this.pendingRequest++;
                this.pending[element.name] = true;
            }
        },
        stopRequest: function(element, valid) {
            this.pendingRequest--;
            if (this.pendingRequest < 0) {
                this.pendingRequest = 0;
            }
            delete this.pending[element.name];
            if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
                $(this.currentForm).submit();
                this.formSubmitted = false;
            } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
                $(this.currentForm).triggerHandler("invalid-form", [this]);
                this.formSubmitted = false;
            }
        },
        previousValue: function(element) {
            return $.data(element, "previousValue") || $.data(element, "previousValue", {
                old: null,
                valid: true,
                message: this.defaultMessage(element, "remote")
            });
        }
    },
    classRuleSettings: {
        required: {
            required: true
        },
        email: {
            email: true
        },
        url: {
            url: true
        },
        date: {
            date: true
        },
        dateISO: {
            dateISO: true
        },
        number: {
            number: true
        },
        digits: {
            digits: true
        },
        creditcard: {
            creditcard: true
        }
    },
    addClassRules: function(className, rules) {
        if (className.constructor === String) {
            this.classRuleSettings[className] = rules;
        } else {
            $.extend(this.classRuleSettings, className);
        }
    },
    classRules: function(element) {
        var rules = {},
            classes = $(element).attr("class");
        if (classes) {
            $.each(classes.split(" "), function() {
                if (this in $.validator.classRuleSettings) {
                    $.extend(rules, $.validator.classRuleSettings[this]);
                }
            });
        }
        return rules;
    },
    attributeRules: function(element) {
        var rules = {},
            $element = $(element),
            type = element.getAttribute("type"),
            method, value;
        for (method in $.validator.methods) {
            if (method === "required") {
                value = element.getAttribute(method);
                if (value === "") {
                    value = true;
                }
                value = !!value;
            } else {
                value = $element.attr(method);
            } if (/min|max/.test(method) && (type === null || /number|range|text/.test(type))) {
                value = Number(value);
            }
            if (value || value === 0) {
                rules[method] = value;
            } else if (type === method && type !== "range") {
                rules[method] = true;
            }
        }
        if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
            delete rules.maxlength;
        }
        return rules;
    },
    dataRules: function(element) {
        var method, value, rules = {},
            $element = $(element);
        for (method in $.validator.methods) {
            value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());
            if (value !== undefined) {
                rules[method] = value;
            }
        }
        return rules;
    },
    staticRules: function(element) {
        if (element.form) {
            validator = $.data(element.form, "validator");
        } else {
            validator = $.data($(element).closest("div[data-form='true']").get(0), "validator");
        }
        var rules = {},
            validator = validator;
        if (validator.settings.rules) {
            rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
        }
        return rules;
    },
    normalizeRules: function(rules, element) {
        $.each(rules, function(prop, val) {
            if (val === false) {
                delete rules[prop];
                return;
            }
            if (val.param || val.depends) {
                var keepRule = true;
                switch (typeof val.depends) {
                    case "string":
                        keepRule = !!$(val.depends, element.form).length;
                        break;
                    case "function":
                        keepRule = val.depends.call(element, element);
                        break;
                }
                if (keepRule) {
                    rules[prop] = val.param !== undefined ? val.param : true;
                } else {
                    delete rules[prop];
                }
            }
        });
        $.each(rules, function(rule, parameter) {
            rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
        });
        $.each(["minlength", "maxlength"], function() {
            if (rules[this]) {
                rules[this] = Number(rules[this]);
            }
        });
        $.each(["rangelength", "range"], function() {
            var parts;
            if (rules[this]) {
                if ($.isArray(rules[this])) {
                    rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
                } else if (typeof rules[this] === "string") {
                    parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/);
                    rules[this] = [Number(parts[0]), Number(parts[1])];
                }
            }
        });
        if ($.validator.autoCreateRanges) {
            if (rules.min != null && rules.max != null) {
                rules.range = [rules.min, rules.max];
                delete rules.min;
                delete rules.max;
            }
            if (rules.minlength != null && rules.maxlength != null) {
                rules.rangelength = [rules.minlength, rules.maxlength];
                delete rules.minlength;
                delete rules.maxlength;
            }
        }
        return rules;
    },
    normalizeRule: function(data) {
        if (typeof data === "string") {
            var transformed = {};
            $.each(data.split(/\s/), function() {
                transformed[this] = true;
            });
            data = transformed;
        }
        return data;
    },
    addMethod: function(name, method, message) {
        $.validator.methods[name] = method;
        $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
        if (method.length < 3) {
            $.validator.addClassRules(name, $.validator.normalizeRule(name));
        }
    },
    methods: {
        required: function(value, element, param) {
            if (!this.depend(param, element)) {
                return "dependency-mismatch";
            }
            if (element.nodeName.toLowerCase() === "select") {
                var val = $(element).val();
                return val && val.length > 0;
            }
            if (this.checkable(element)) {
                return this.getLength(value, element) > 0;
            }
            return $.trim(value).length > 0;
        },
        phone: function(value, element, param) {
            return this.optional(element) || /^([+]?[0-9]{1,2})?([0-9]{3})([\d]{7})$/.test(value);
        },
        phoneUA: function(value, element, param) {
            return this.optional(element) || /^([+]38)?([0-9]{3})([\d]{7})$/.test(value);
        },
        validTrue: function(value, element, param) {
            if ($(element).data('valid') === true) {
                return true;
            } else {
                return false;
            }
        },
        filesize: function(value, element, param) {
            return this.optional(element) || (element.files[0].size <= param);
        },
        word: function(value, element) {
            return this.optional(element) || /^[a-zA-Zа-яА-ЯіІїЇєЄґҐ ]*$/.test(value);
        },
        login: function(value, element) {
            return this.optional(element) || /^[a-zA-Zа-яА-ЯіІїЇєЄґҐ][0-9a-zA-Zа-яА-ЯіІїЇєЄґҐ\-\._| ]+$/.test(value);
        },
        email: function(value, element) {
            return this.optional(element) || /^([a-zA-Z0-9_\.\-]{2,})+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/.test(value);
        },
        url: function(value, element) {
            return this.optional(element) || /^((https?|s?ftp):\/\/)?(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
        },
        date: function(value, element) {
            return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
        },
        dateISO: function(value, element) {
            return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
        },
        number: function(value, element) {
            return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
        },
        digits: function(value, element) {
            return this.optional(element) || /^\d+$/.test(value);
        },
        creditcard: function(value, element) {
            if (this.optional(element)) {
                return "dependency-mismatch";
            }
            if (/[^0-9 \-]+/.test(value)) {
                return false;
            }
            var nCheck = 0,
                nDigit = 0,
                bEven = false,
                n, cDigit;
            value = value.replace(/\D/g, "");
            if (value.length < 13 || value.length > 19) {
                return false;
            }
            for (n = value.length - 1; n >= 0; n--) {
                cDigit = value.charAt(n);
                nDigit = parseInt(cDigit, 10);
                if (bEven) {
                    if ((nDigit *= 2) > 9) {
                        nDigit -= 9;
                    }
                }
                nCheck += nDigit;
                bEven = !bEven;
            }
            return (nCheck % 10) === 0;
        },
        minlength: function(value, element, param) {
            var length = $.isArray(value) ? value.length : this.getLength(value, element);
            return this.optional(element) || length >= param;
        },
        maxlength: function(value, element, param) {
            var length = $.isArray(value) ? value.length : this.getLength(value, element);
            return this.optional(element) || length <= param;
        },
        rangelength: function(value, element, param) {
            var length = $.isArray(value) ? value.length : this.getLength(value, element);
            return this.optional(element) || (length >= param[0] && length <= param[1]);
        },
        min: function(value, element, param) {
            return this.optional(element) || value >= param;
        },
        max: function(value, element, param) {
            return this.optional(element) || value <= param;
        },
        range: function(value, element, param) {
            return this.optional(element) || (value >= param[0] && value <= param[1]);
        },
        equalTo: function(value, element, param) {
            var target = $(param);
            if (this.settings.onfocusout) {
                target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
                    $(element).valid();
                });
            }
            return value === target.val();
        },
        remote: function(value, element, param) {
            if (this.optional(element)) {
                return "dependency-mismatch";
            }
            var previous = this.previousValue(element),
                validator, data;
            if (!this.settings.messages[element.name]) {
                this.settings.messages[element.name] = {};
            }
            previous.originalMessage = this.settings.messages[element.name].remote;
            this.settings.messages[element.name].remote = previous.message;
            param = typeof param === "string" && {
                url: param
            } || param;
            if (previous.old === value) {
                return previous.valid;
            }
            previous.old = value;
            validator = this;
            this.startRequest(element);
            data = {};
            data[element.name] = value;
            $.ajax($.extend(true, {
                url: param,
                mode: "abort",
                port: "validate" + element.name,
                dataType: "json",
                data: data,
                context: validator.currentForm,
                success: function(response) {
                    var valid = response === true || response === "true",
                        errors, message, submitted;
                    validator.settings.messages[element.name].remote = previous.originalMessage;
                    if (valid) {
                        submitted = validator.formSubmitted;
                        validator.prepareElement(element);
                        validator.formSubmitted = submitted;
                        validator.successList.push(element);
                        delete validator.invalid[element.name];
                        validator.showErrors();
                    } else {
                        errors = {};
                        message = response || validator.defaultMessage(element, "remote");
                        errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
                        validator.invalid[element.name] = true;
                        validator.showErrors(errors);
                    }
                    previous.valid = valid;
                    validator.stopRequest(element, valid);
                }
            }, param));
            return "pending";
        }
    }
});
if ($('html').attr('lang').split('-').shift() === 'ru') {
    $.extend($.validator.messages, {
        required: "Это поле необходимо заполнить.",
        word: "Вводите только буквы",
        remote: "Пожалуйста, введите правильное значение.",
        email: "Пожалуйста, введите корректный адрес электронной почты.",
        url: "Пожалуйста, введите корректный URL.",
        date: "Пожалуйста, введите корректную дату.",
        dateISO: "Пожалуйста, введите корректную дату в формате ISO.",
        number: "Пожалуйста, введите число.",
        digits: "Пожалуйста, вводите только цифры.",
        creditcard: "Пожалуйста, введите правильный номер кредитной карты.",
        equalTo: "Пожалуйста, введите такое же значение ещё раз.",
        extension: "Пожалуйста, выберите файл с правильным расширением.",
        maxlength: $.validator.format("Пожалуйста, введите не больше {0} символов."),
        minlength: $.validator.format("Пожалуйста, введите не меньше {0} символов."),
        rangelength: $.validator.format("Пожалуйста, введите значение длиной от {0} до {1} символов."),
        range: $.validator.format("Пожалуйста, введите число от {0} до {1}."),
        max: $.validator.format("Пожалуйста, введите число, меньшее или равное {0}."),
        min: $.validator.format("Пожалуйста, введите число, большее или равное {0}.")
    });
}
$.format = function deprecated() {
    throw "$.format has been deprecated. Please use $.validator.format instead.";
};

/*-------------------------------  liActualSize.js  ------------------------------------*/
    (function($) {
        $.fn.actual = function() {
            if (arguments.length && typeof arguments[0] == 'string') {
                var dim = arguments[0];
                if (this.is(':visible')) return this[dim]();
                var clone = $(this).clone().css({
                    position: 'absolute',
                    top: '-9999px',
                    visibility: 'hidden'
                }).appendTo('body');
                var s = clone[dim]();
                clone.remove();

                return s;
            }
            return undefined;
        };
    }(jQuery));
/*-------------------------------  validate  ------------------------------------*/
    $.extend($.fn, {
        validateDelegate: function( delegate, type, handler ) {
            return this.bind(type, function( event ) {
                var target = $(event.target);
                if ( target.is(delegate) ) {
                    return handler.apply(target, arguments);
                }
            });
        }
    });
   $.extend($.fn, {
    // http://jqueryvalidation.org/validate/
    validate: function( options ) {

        // if nothing is selected, return nothing; can't chain anyway
        if ( !this.length ) {
            if ( options && options.debug && window.console ) {
                console.warn( "Nothing selected, can't validate, returning nothing." );
            }
            return;
        }

        // check if a validator for this form was already created
        var validator = $.data( this[ 0 ], "validator" );
        if ( validator ) {
            return validator;
        }

        // Add novalidate tag if HTML5.
        this.attr( "novalidate", "novalidate" );

        validator = new $.validator( options, this[ 0 ] );
        $.data( this[ 0 ], "validator", validator );

        if ( validator.settings.onsubmit ) {

            this.validateDelegate( ":submit", "click", function( event ) {
                if ( validator.settings.submitHandler ) {
                    validator.submitButton = event.target;
                }
                // allow suppressing validation by adding a cancel class to the submit button
                if ( $( event.target ).hasClass( "cancel" ) ) {
                    validator.cancelSubmit = true;
                }

                // allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
                if ( $( event.target ).attr( "formnovalidate" ) !== undefined ) {
                    validator.cancelSubmit = true;
                }
            });

            // validate the form on submit
            this.submit( function( event ) {
                if ( validator.settings.debug ) {
                    // prevent form submit to be able to see console output
                    event.preventDefault();
                }
                function handle() {
                    var hidden;
                    if ( validator.settings.submitHandler ) {
                        if ( validator.submitButton ) {
                            // insert a hidden input as a replacement for the missing submit button
                            hidden = $( "<input type='hidden'/>" )
                                .attr( "name", validator.submitButton.name )
                                .val( $( validator.submitButton ).val() )
                                .appendTo( validator.currentForm );
                        }
                        validator.settings.submitHandler.call( validator, validator.currentForm, event );
                        if ( validator.submitButton ) {
                            // and clean up afterwards; thanks to no-block-scope, hidden can be referenced
                            hidden.remove();
                        }
                        return false;
                    }
                    return true;
                }

                // prevent submit for invalid forms or custom submit handlers
                if ( validator.cancelSubmit ) {
                    validator.cancelSubmit = false;
                    return handle();
                }
                if ( validator.form() ) {
                    if ( validator.pendingRequest ) {
                        validator.formSubmitted = true;
                        return false;
                    }
                    return handle();
                } else {
                    validator.focusInvalid();
                    return false;
                }
            });
        }

        return validator;
    },
    // http://jqueryvalidation.org/valid/
    valid: function() {
        var valid, validator;

        if ( $( this[ 0 ] ).is( "form" ) ) {
            valid = this.validate().form();
        } else if ( $( this [0] ).is( "div" ) ) {
            valid = this.validate().form();
        } else {
            valid = true;
            validator = $( this[ 0 ].form ).validate();
            this.each( function() {
                valid = validator.element( this ) && valid;
            });
        }
        return valid;
    },
    // attributes: space separated list of attributes to retrieve and remove
    removeAttrs: function( attributes ) {
        var result = {},
            $element = this;
        $.each( attributes.split( /\s/ ), function( index, value ) {
            result[ value ] = $element.attr( value );
            $element.removeAttr( value );
        });
        return result;
    },
    // http://jqueryvalidation.org/rules/
    rules: function( command, argument ) {
        var element = this[ 0 ],
            settings, staticRules, existingRules, data, param, filtered;

        if ( command ) {
            settings = $.data( element.form, "validator" ).settings;
            staticRules = settings.rules;
            existingRules = $.validator.staticRules( element );
            switch ( command ) {
            case "add":
                $.extend( existingRules, $.validator.normalizeRule( argument ) );
                // remove messages from rules, but allow them to be set separately
                delete existingRules.messages;
                staticRules[ element.name ] = existingRules;
                if ( argument.messages ) {
                    settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
                }
                break;
            case "remove":
                if ( !argument ) {
                    delete staticRules[ element.name ];
                    return existingRules;
                }
                filtered = {};
                $.each( argument.split( /\s/ ), function( index, method ) {
                    filtered[ method ] = existingRules[ method ];
                    delete existingRules[ method ];
                    if ( method === "required" ) {
                        $( element ).removeAttr( "aria-required" );
                    }
                });
                return filtered;
            }
        }

        data = $.validator.normalizeRules(
        $.extend(
            {},
            $.validator.classRules( element ),
            $.validator.attributeRules( element ),
            $.validator.dataRules( element ),
            $.validator.staticRules( element )
        ), element );

        // make sure required is at front
        if ( data.required ) {
            param = data.required;
            delete data.required;
            data = $.extend( { required: param }, data );
            $( element ).attr( "aria-required", "true" );
        }

        // make sure remote is at back
        if ( data.remote ) {
            param = data.remote;
            delete data.remote;
            data = $.extend( data, { remote: param });
        }

        return data;
    }
    });

    // Custom selectors
    $.extend( $.expr[ ":" ], {
        // http://jqueryvalidation.org/blank-selector/
        blank: function( a ) {
            return !$.trim( "" + $( a ).val() );
        },
        // http://jqueryvalidation.org/filled-selector/
        filled: function( a ) {
            return !!$.trim( "" + $( a ).val() );
        },
        // http://jqueryvalidation.org/unchecked-selector/
        unchecked: function( a ) {
            return !$( a ).prop( "checked" );
        }
    });

    // constructor for validator
    $.validator = function( options, form ) {
        this.settings = $.extend( true, {}, $.validator.defaults, options );
        this.currentForm = form;
        this.init();
    };

    // http://jqueryvalidation.org/jQuery.validator.format/
    $.validator.format = function( source, params ) {
        if ( arguments.length === 1 ) {
            return function() {
                var args = $.makeArray( arguments );
                args.unshift( source );
                return $.validator.format.apply( this, args );
            };
        }
        if ( arguments.length > 2 && params.constructor !== Array  ) {
            params = $.makeArray( arguments ).slice( 1 );
        }
        if ( params.constructor !== Array ) {
            params = [ params ];
        }
        $.each( params, function( i, n ) {
            source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
                return n;
            });
        });
        return source;
    };

    $.extend( $.validator, {

    defaults: {
        messages: {},
        groups: {},
        rules: {},
        errorClass: "error",
        validClass: "valid",
        errorElement: "label",
        focusInvalid: true,
        errorContainer: $( [] ),
        errorLabelContainer: $( [] ),
        onsubmit: true,
        ignore: ":hidden",
        ignoreTitle: false,
        onfocusin: function( element ) {
            this.lastActive = element;

            // hide error label and remove error class on focus if enabled
            if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {
                if ( this.settings.unhighlight ) {
                    this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
                }
                this.addWrapper( this.errorsFor( element ) ).hide();
            }
        },
        onfocusout: function( element ) {
            if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
                this.element( element );
            }
        },
        onkeyup: function( element, event ) {
            if ( event.which === 9 && this.elementValue( element ) === "" ) {

            } else if ( element.name in this.submitted || element === this.lastElement ) {
                this.element( element );
            }
        },
        onclick: function( element ) {
            // click on selects, radiobuttons and checkboxes
            if ( element.name in this.submitted ) {
                this.element( element );

            // or option elements, check parent select in that case
            } else if ( element.parentNode.name in this.submitted ) {
                this.element( element.parentNode );
            }
        },
        highlight: function( element, errorClass, validClass ) {
            if ( element.type === "radio" ) {
                this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
            } else {
                $( element ).addClass( errorClass ).removeClass( validClass );
            }
        },
        unhighlight: function( element, errorClass, validClass ) {
            if ( element.type === "radio" ) {
                this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
            } else {
                $( element ).removeClass( errorClass ).addClass( validClass );
            }
        }
    },

    // http://jqueryvalidation.org/jQuery.validator.setDefaults/
    setDefaults: function( settings ) {
        $.extend( $.validator.defaults, settings );
    },

    messages: {
        required: "Поле обязательное для заполнения.",
        remote: "Пожалуйста, исправьте это поле.",
        email: "Пожалуйста, введите верный e-mail.",
        url: "Пожалуйста, введите верный URL.",
        date: "Пожалуйста, введите верную дату.",
        dateISO: "Please enter a valid date ( ISO ).",
        number: "Пожалуйста, введите верное число.",
        digits: "Пожалуйста, вводите только числа.",
        phoneUA: "Введите корректный номер телефона.",
        creditcard: "Please enter a valid credit card number.",
        equalTo: "Пороли не совпадают.",
        bykvu: "Вводите только буквы.",
        maxlength: $.validator.format( "Пожалуйста, введите не более {0} символов." ),
        minlength: $.validator.format( "Пожалуйста, введите не менее, {0} символов." ),
        rangelength: $.validator.format( "Пожалуйста, введите значение от {0} до {1} символов." ),
        range: $.validator.format( "Пожалуйста, введите значение от {0} до {1}." ),
        max: $.validator.format( "Пожалуйста, введите значение меньше или равное {0}." ),
        min: $.validator.format( "Пожалуйста, введите значение больше или равно {0}." )
    },

    autoCreateRanges: false,

    prototype: {

        init: function() {
            this.labelContainer = $( this.settings.errorLabelContainer );
            this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
            this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
            this.submitted = {};
            this.valueCache = {};
            this.pendingRequest = 0;
            this.pending = {};
            this.invalid = {};
            this.reset();

            var groups = ( this.groups = {} ),
                rules;
            $.each( this.settings.groups, function( key, value ) {
                if ( typeof value === "string" ) {
                    value = value.split( /\s/ );
                }
                $.each( value, function( index, name ) {
                    groups[ name ] = key;
                });
            });
            rules = this.settings.rules;
            $.each( rules, function( key, value ) {
                rules[ key ] = $.validator.normalizeRule( value );
            });

            function delegate( event ) {
                var validator, form, eventType;
                form = this[ 0 ].form;

                if ( !form ) {
                    form = $( this ).closest( "div[form='true']" ).get( 0 );
                }
                validator = $.data( form, "validator" ),
                    eventType = "on" + event.type.replace( /^validate/, "" ),
                    this.settings = validator.settings;
                if ( this.settings[ eventType ] && !this.is( this.settings.ignore ) ) {
                    this.settings[ eventType ].call( validator, this[ 0 ], event );
                }
            }
            $( this.currentForm )
                .validateDelegate( ":text, [type='password'], [type='file'], select, textarea, " +
                    "[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
                    "[type='email'], [type='datetime'], [type='date'], [type='month'], " +
                    "[type='week'], [type='time'], [type='datetime-local'], " +
                    "[type='range'], [type='color'], [type='radio'], [type='checkbox']",
                    "focusin focusout keyup", delegate)
                // Support: Chrome, oldIE
                // "select" is provided as event.target when clicking a option
                .validateDelegate("select, option, [type='radio'], [type='checkbox']", "click", delegate);

            if ( this.settings.invalidHandler ) {
                $( this.currentForm ).bind( "invalid-form.validate", this.settings.invalidHandler );
            }

            // Add aria-required to any Static/Data/Class required fields before first validation
            // Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html
            $( this.currentForm ).find( "[required], [data-rule-required], .required" ).attr( "aria-required", "true" );
        },

        // http://jqueryvalidation.org/Validator.form/
        form: function() {
            this.checkForm();
            $.extend( this.submitted, this.errorMap );
            this.invalid = $.extend({}, this.errorMap );
            if ( !this.valid() ) {
                $( this.currentForm ).triggerHandler( "invalid-form", [ this ]);
            }
            this.showErrors();
            return this.valid();
        },

        checkForm: function() {
            this.prepareForm();
            for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
                this.check( elements[ i ] );
            }
            return this.valid();
        },

        // http://jqueryvalidation.org/Validator.element/
        element: function( element ) {
            var cleanElement = this.clean( element ),
                checkElement = this.validationTargetFor( cleanElement ),
                result = true;

            this.lastElement = checkElement;

            if ( checkElement === undefined ) {
                delete this.invalid[ cleanElement.name ];
            } else {
                this.prepareElement( checkElement );
                this.currentElements = $( checkElement );

                result = this.check( checkElement ) !== false;
                if ( result ) {
                    delete this.invalid[ checkElement.name ];
                } else {
                    this.invalid[ checkElement.name ] = true;
                }
            }
            // Add aria-invalid status for screen readers
            $( element ).attr( "aria-invalid", !result );

            if ( !this.numberOfInvalids() ) {
                // Hide error containers on last error
                this.toHide = this.toHide.add( this.containers );
            }
            this.showErrors();
            return result;
        },

        // http://jqueryvalidation.org/Validator.showErrors/
        showErrors: function( errors ) {
            if ( errors ) {
                // add items to error list and map
                $.extend( this.errorMap, errors );
                this.errorList = [];
                for ( var name in errors ) {
                    this.errorList.push({
                        message: errors[ name ],
                        element: this.findByName( name )[ 0 ]
                    });
                }
                // remove items from success list
                this.successList = $.grep( this.successList, function( element ) {
                    return !( element.name in errors );
                });
            }
            if ( this.settings.showErrors ) {
                this.settings.showErrors.call( this, this.errorMap, this.errorList );
            } else {
                this.defaultShowErrors();
            }
        },

        // http://jqueryvalidation.org/Validator.resetForm/
        resetForm: function() {
            if ( $.fn.resetForm ) {
                $( this.currentForm ).resetForm();
            }
            this.submitted = {};
            this.lastElement = null;
            this.prepareForm();
            this.hideErrors();
            this.elements()
                    .removeClass( this.settings.errorClass )
                    .removeData( "previousValue" )
                    .removeAttr( "aria-invalid" );
        },

        numberOfInvalids: function() {
            return this.objectLength( this.invalid );
        },

        objectLength: function( obj ) {
            /* jshint unused: false */
            var count = 0,
                i;
            for ( i in obj ) {
                count++;
            }
            return count;
        },

        hideErrors: function() {
            this.addWrapper( this.toHide ).hide();
        },

        valid: function() {
            return this.size() === 0;
        },

        size: function() {
            return this.errorList.length;
        },

        focusInvalid: function() {
            if ( this.settings.focusInvalid ) {
                try {
                    $( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [])
                    .filter( ":visible" )
                    .focus()
                    // manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
                    .trigger( "focusin" );
                } catch( e ) {
                    // ignore IE throwing errors when focusing hidden elements
                }
            }
        },

        findLastActive: function() {
            var lastActive = this.lastActive;
            return lastActive && $.grep( this.errorList, function( n ) {
                return n.element.name === lastActive.name;
            }).length === 1 && lastActive;
        },

        elements: function() {
            var validator = this,
                rulesCache = {};

            // select all valid inputs inside the form (no submit or reset buttons)
            return $( this.currentForm )
            .find( "input, select, textarea" )
            .not( ":submit, :reset, :image, [disabled]" )
            .not( this.settings.ignore )
            .filter( function() {
                if ( !this.name && validator.settings.debug && window.console ) {
                    console.error( "%o has no name assigned", this );
                }

                // select only the first element for each name, and only those with rules specified
                if ( this.name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
                    return false;
                }

                rulesCache[ this.name ] = true;
                return true;
            });
        },

        clean: function( selector ) {
            return $( selector )[ 0 ];
        },

        errors: function() {
            var errorClass = this.settings.errorClass.split( " " ).join( "." );
            return $( this.settings.errorElement + "." + errorClass, this.errorContext );
        },

        reset: function() {
            this.successList = [];
            this.errorList = [];
            this.errorMap = {};
            this.toShow = $( [] );
            this.toHide = $( [] );
            this.currentElements = $( [] );
        },

        prepareForm: function() {
            this.reset();
            this.toHide = this.errors().add( this.containers );
        },

        prepareElement: function( element ) {
            this.reset();
            this.toHide = this.errorsFor( element );
        },

        elementValue: function( element ) {
            var val,
                $element = $( element ),
                type = element.type;

            if ( type === "radio" || type === "checkbox" ) {
                return $( "input[name='" + element.name + "']:checked" ).val();
            } else if ( type === "number" && typeof element.validity !== "undefined" ) {
                return element.validity.badInput ? false : $element.val();
            }

            val = $element.val();
            if ( typeof val === "string" ) {
                return val.replace(/\r/g, "" );
            }
            return val;
        },

        check: function( element ) {
            element = this.validationTargetFor( this.clean( element ) );

            var rules = $( element ).rules(),
                rulesCount = $.map( rules, function( n, i ) {
                    return i;
                }).length,
                dependencyMismatch = false,
                val = this.elementValue( element ),
                result, method, rule;

            for ( method in rules ) {
                rule = { method: method, parameters: rules[ method ] };
                try {

                    result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

                    // if a method indicates that the field is optional and therefore valid,
                    // don't mark it as valid when there are no other rules
                    if ( result === "dependency-mismatch" && rulesCount === 1 ) {
                        dependencyMismatch = true;
                        continue;
                    }
                    dependencyMismatch = false;

                    if ( result === "pending" ) {
                        this.toHide = this.toHide.not( this.errorsFor( element ) );
                        return;
                    }

                    if ( !result ) {
                        this.formatAndAdd( element, rule );
                        return false;
                    }
                } catch( e ) {
                    if ( this.settings.debug && window.console ) {
                        console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
                    }
                    throw e;
                }
            }
            if ( dependencyMismatch ) {
                return;
            }
            if ( this.objectLength( rules ) ) {
                this.successList.push( element );
            }
            return true;
        },

        // return the custom message for the given element and validation method
        // specified in the element's HTML5 data attribute
        // return the generic message if present and no method specific message is present
        customDataMessage: function( element, method ) {
            return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
                method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
        },

        // return the custom message for the given element name and validation method
        customMessage: function( name, method ) {
            var m = this.settings.messages[ name ];
            return m && ( m.constructor === String ? m : m[ method ]);
        },

        // return the first defined argument, allowing empty strings
        findDefined: function() {
            for ( var i = 0; i < arguments.length; i++) {
                if ( arguments[ i ] !== undefined ) {
                    return arguments[ i ];
                }
            }
            return undefined;
        },

        defaultMessage: function( element, method ) {
            return this.findDefined(
                this.customMessage( element.name, method ),
                this.customDataMessage( element, method ),
                // title is never undefined, so handle empty string as undefined
                !this.settings.ignoreTitle && element.title || undefined,
                $.validator.messages[ method ],
                "<strong>Warning: No message defined for " + element.name + "</strong>"
            );
        },

        formatAndAdd: function( element, rule ) {
            var message = this.defaultMessage( element, rule.method ),
                theregex = /\$?\{(\d+)\}/g;
            if ( typeof message === "function" ) {
                message = message.call( this, rule.parameters, element );
            } else if ( theregex.test( message ) ) {
                message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
            }
            this.errorList.push({
                message: message,
                element: element,
                method: rule.method
            });

            this.errorMap[ element.name ] = message;
            this.submitted[ element.name ] = message;
        },

        addWrapper: function( toToggle ) {
            if ( this.settings.wrapper ) {
                toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
            }
            return toToggle;
        },

        defaultShowErrors: function() {
            var i, elements, error;
            for ( i = 0; this.errorList[ i ]; i++ ) {
                error = this.errorList[ i ];
                if ( this.settings.highlight ) {
                    this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
                }
                this.showLabel( error.element, error.message );
            }
            if ( this.errorList.length ) {
                this.toShow = this.toShow.add( this.containers );
            }
            if ( this.settings.success ) {
                for ( i = 0; this.successList[ i ]; i++ ) {
                    this.showLabel( this.successList[ i ] );
                }
            }
            if ( this.settings.unhighlight ) {
                for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
                    this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
                }
            }
            this.toHide = this.toHide.not( this.toShow );
            this.hideErrors();
            this.addWrapper( this.toShow ).show();
        },

        validElements: function() {
            return this.currentElements.not( this.invalidElements() );
        },

        invalidElements: function() {
            return $( this.errorList ).map(function() {
                return this.element;
            });
        },

        showLabel: function( element, message ) {
            var place, group,
                error = this.errorsFor( element ),
                elementID = this.idOrName( element );
            if ( error.length ) {
                // refresh error/success class
                error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );
                // replace message on existing label
                error.html( message );
            } else {
                // create error element
                error = $( "<" + this.settings.errorElement + ">" )
                    .attr( "id", elementID + "-error" )
                    .addClass( this.settings.errorClass )
                    .html( message || "" );

                // Maintain reference to the element to be placed into the DOM
                place = error;
                if ( this.settings.wrapper ) {
                    // make sure the element is visible, even in IE
                    // actually showing the wrapped element is handled elsewhere
                    place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
                }
                if ( this.labelContainer.length ) {
                    this.labelContainer.append( place );
                } else if ( this.settings.errorPlacement ) {
                    this.settings.errorPlacement( place, $( element ) );
                } else {
                    place.appendTo($(element).parent());
                    /*place.insertAfter( element );*/
                }

                // Link error back to the element
                if ( error.is( "label" ) ) {
                    // If the error is a label, then associate using 'for'
                    error.attr( "for", elementID );
                } else if ( error.parents( "label[for='" + elementID + "']" ).length === 0 ) {
                    // If the element is not a child of an associated label, then it's necessary
                    // to explicitly apply aria-describedby
                    $( element ).attr( "aria-describedby", error.attr( "id" ) );

                    // If this element is grouped, then assign to all elements in the same group
                    group = this.groups[ element.name ];
                    if ( group ) {
                        $.each( this.groups, function( name, testgroup ) {
                            if ( testgroup === group ) {
                                $( "[name='" + name + "']", this.currentForm )
                                    .attr( "aria-describedby", error.attr( "id" ) );
                            }
                        });
                    }
                }
            }
            if ( !message && this.settings.success ) {
                error.text( "" );
                if ( typeof this.settings.success === "string" ) {
                    error.addClass( this.settings.success );
                } else {
                    this.settings.success( error, element );
                }
            }
            this.toShow = this.toShow.add( error );
        },

        errorsFor: function( element ) {
            var name = this.idOrName( element ),
                describer = $( element ).attr( "aria-describedby" );
            if ( describer ) {
                // aria-describedby should directly reference the error element
                return $( "#" + describer, this.errorContext );
            } else {
                // If no describer is used then errors are either associated labels, or children of non-error labels
                return this
                    .errors()
                    .filter( "label[for='" + name + "'], label[for='" + name + "'] *" );
            }
        },

        idOrName: function( element ) {
            return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
        },

        validationTargetFor: function( element ) {
            // if radio/checkbox, validate first element in group instead
            if ( this.checkable( element ) ) {
                element = this.findByName( element.name ).not( this.settings.ignore )[ 0 ];
            }
            return element;
        },

        checkable: function( element ) {
            return ( /radio|checkbox/i ).test( element.type );
        },

        findByName: function( name ) {
            return $( this.currentForm ).find( "[name='" + name + "']" );
        },

        getLength: function( value, element ) {
            switch ( element.nodeName.toLowerCase() ) {
            case "select":
                return $( "option:selected", element ).length;
            case "input":
                if ( this.checkable( element ) ) {
                    return this.findByName( element.name ).filter( ":checked" ).length;
                }
            }
            return value.length;
        },

        depend: function( param, element ) {
            return this.dependTypes[typeof param] ? this.dependTypes[typeof param]( param, element ) : true;
        },

        dependTypes: {
            "boolean": function( param ) {
                return param;
            },
            "string": function( param, element ) {
                return !!$( param, element.form ).length;
            },
            "function": function( param, element ) {
                return param( element );
            }
        },

        optional: function( element ) {
            var val = this.elementValue( element );
            return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
        },

        startRequest: function( element ) {
            if ( !this.pending[ element.name ] ) {
                this.pendingRequest++;
                this.pending[ element.name ] = true;
            }
        },

        stopRequest: function( element, valid ) {
            this.pendingRequest--;
            // sometimes synchronization fails, make sure pendingRequest is never < 0
            if ( this.pendingRequest < 0 ) {
                this.pendingRequest = 0;
            }
            delete this.pending[ element.name ];
            if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
                $( this.currentForm ).submit();
                this.formSubmitted = false;
            } else if (!valid && this.pendingRequest === 0 && this.formSubmitted ) {
                $( this.currentForm ).triggerHandler( "invalid-form", [ this ]);
                this.formSubmitted = false;
            }
        },

        previousValue: function( element ) {
            return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
                old: null,
                valid: true,
                message: this.defaultMessage( element, "remote" )
            });
        }

    },

    classRuleSettings: {
        required: { required: true },
        email: { email: true },
        url: { url: true },
        date: { date: true },
        dateISO: { dateISO: true },
        number: { number: true },
        digits: { digits: true },
        creditcard: { creditcard: true }
    },

    addClassRules: function( className, rules ) {
        if ( className.constructor === String ) {
            this.classRuleSettings[ className ] = rules;
        } else {
            $.extend( this.classRuleSettings, className );
        }
    },

    classRules: function( element ) {
        var rules = {},
            classes = $( element ).attr( "class" );

        if ( classes ) {
            $.each( classes.split( " " ), function() {
                if ( this in $.validator.classRuleSettings ) {
                    $.extend( rules, $.validator.classRuleSettings[ this ]);
                }
            });
        }
        return rules;
    },

    attributeRules: function( element ) {
        var rules = {},
            $element = $( element ),
            type = element.getAttribute( "type" ),
            method, value;

        for ( method in $.validator.methods ) {

            // support for <input required> in both html5 and older browsers
            if ( method === "required" ) {
                value = element.getAttribute( method );
                // Some browsers return an empty string for the required attribute
                // and non-HTML5 browsers might have required="" markup
                if ( value === "" ) {
                    value = true;
                }
                // force non-HTML5 browsers to return bool
                value = !!value;
            } else {
                value = $element.attr( method );
            }

            // convert the value to a number for number inputs, and for text for backwards compability
            // allows type="date" and others to be compared as strings
            if ( /min|max/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
                value = Number( value );
            }

            if ( value || value === 0 ) {
                rules[ method ] = value;
            } else if ( type === method && type !== "range" ) {
                // exception: the jquery validate 'range' method
                // does not test for the html5 'range' type
                rules[ method ] = true;
            }
        }

        // maxlength may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
        if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
            delete rules.maxlength;
        }

        return rules;
    },

    dataRules: function( element ) {
        var method, value,
            rules = {}, $element = $( element );
        for ( method in $.validator.methods ) {
            value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );
            if ( value !== undefined ) {
                rules[ method ] = value;
            }
        }
        return rules;
    },

    staticRules: function( element ) {
        if ( element.form ) {
            validator = $.data( element.form, "validator" );
        } else {
            validator = $.data( $( element ).closest( "div[form='true']" ).get( 0 ), "validator");
        }

        var rules = {},
            validator = validator;

        if ( validator.settings.rules ) {
            rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
        }
        return rules;
    },

    normalizeRules: function( rules, element ) {
        // handle dependency check
        $.each( rules, function( prop, val ) {
            // ignore rule when param is explicitly false, eg. required:false
            if ( val === false ) {
                delete rules[ prop ];
                return;
            }
            if ( val.param || val.depends ) {
                var keepRule = true;
                switch ( typeof val.depends ) {
                case "string":
                    keepRule = !!$( val.depends, element.form ).length;
                    break;
                case "function":
                    keepRule = val.depends.call( element, element );
                    break;
                }
                if ( keepRule ) {
                    rules[ prop ] = val.param !== undefined ? val.param : true;
                } else {
                    delete rules[ prop ];
                }
            }
        });

        // evaluate parameters
        $.each( rules, function( rule, parameter ) {
            rules[ rule ] = $.isFunction( parameter ) ? parameter( element ) : parameter;
        });

        // clean number parameters
        $.each([ "minlength", "maxlength" ], function() {
            if ( rules[ this ] ) {
                rules[ this ] = Number( rules[ this ] );
            }
        });
        $.each([ "rangelength", "range" ], function() {
            var parts;
            if ( rules[ this ] ) {
                if ( $.isArray( rules[ this ] ) ) {
                    rules[ this ] = [ Number( rules[ this ][ 0 ]), Number( rules[ this ][ 1 ] ) ];
                } else if ( typeof rules[ this ] === "string" ) {
                    parts = rules[ this ].replace(/[\[\]]/g, "" ).split( /[\s,]+/ );
                    rules[ this ] = [ Number( parts[ 0 ]), Number( parts[ 1 ] ) ];
                }
            }
        });

        if ( $.validator.autoCreateRanges ) {
            // auto-create ranges
            if ( rules.min && rules.max ) {
                rules.range = [ rules.min, rules.max ];
                delete rules.min;
                delete rules.max;
            }
            if ( rules.minlength && rules.maxlength ) {
                rules.rangelength = [ rules.minlength, rules.maxlength ];
                delete rules.minlength;
                delete rules.maxlength;
            }
        }

        return rules;
    },

    // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
    normalizeRule: function( data ) {
        if ( typeof data === "string" ) {
            var transformed = {};
            $.each( data.split( /\s/ ), function() {
                transformed[ this ] = true;
            });
            data = transformed;
        }
        return data;
    },

    // http://jqueryvalidation.org/jQuery.validator.addMethod/
    addMethod: function( name, method, message ) {
        $.validator.methods[ name ] = method;
        $.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
        if ( method.length < 3 ) {
            $.validator.addClassRules( name, $.validator.normalizeRule( name ) );
        }
    },

    methods: {

        // http://jqueryvalidation.org/required-method/
        required: function( value, element, param ) {
            // check if dependency is met
            if ( !this.depend( param, element ) ) {
                return "dependency-mismatch";
            }
            if ( element.nodeName.toLowerCase() === "select" ) {
                // could be an array for select-multiple or a string, both are fine this way
                var val = $( element ).val();
                return val && val.length > 0;
            }
            if ( this.checkable( element ) ) {
                return this.getLength( value, element ) > 0;
            }
            return $.trim( value ).length > 0;
        },

        // http://jqueryvalidation.org/email-method/
        email: function( value, element ) {
            // From http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29
            // Retrieved 2014-01-14
            // If you have a problem with this implementation, report a bug against the above spec
            // Or use custom methods to implement your own email validation
            return this.optional( element ) || /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/.test( value );
        },

        // http://jqueryvalidation.org/url-method/
        url: function( value, element ) {
            // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
            return this.optional( element ) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test( value );
        },

        // http://jqueryvalidation.org/date-method/
        date: function( value, element ) {
            return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
        },

        // http://jqueryvalidation.org/dateISO-method/
        dateISO: function( value, element ) {
            return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
        },

        // http://jqueryvalidation.org/number-method/
        number: function( value, element ) {
            return this.optional( element ) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
        },

        // http://jqueryvalidation.org/digits-method/
        digits: function( value, element ) {
            return this.optional( element ) || /^\d+$/.test( value );
        },

        phoneUA: function( value, element, param ) {
            return this.optional(element) || /^([+]38)?\ \(([0-9]{3})\)\ ([\d]{3})\-([\d]{2})\-([\d]{2})$/.test(value);
        },

        bykvu: function( value, element, param ) {
            return this.optional(element) || /^[а-яА-ЯёЁіІїЇєЄa-zA-Z ]*$/.test(value);
        },

        // http://jqueryvalidation.org/creditcard-method/
        // based on http://en.wikipedia.org/wiki/Luhn/
        creditcard: function( value, element ) {
            if ( this.optional( element ) ) {
                return "dependency-mismatch";
            }
            // accept only spaces, digits and dashes
            if ( /[^0-9 \-]+/.test( value ) ) {
                return false;
            }
            var nCheck = 0,
                nDigit = 0,
                bEven = false,
                n, cDigit;

            value = value.replace( /\D/g, "" );

            // Basing min and max length on
            // http://developer.ean.com/general_info/Valid_Credit_Card_Types
            if ( value.length < 13 || value.length > 19 ) {
                return false;
            }

            for ( n = value.length - 1; n >= 0; n--) {
                cDigit = value.charAt( n );
                nDigit = parseInt( cDigit, 10 );
                if ( bEven ) {
                    if ( ( nDigit *= 2 ) > 9 ) {
                        nDigit -= 9;
                    }
                }
                nCheck += nDigit;
                bEven = !bEven;
            }

            return ( nCheck % 10 ) === 0;
        },

        // http://jqueryvalidation.org/minlength-method/
        minlength: function( value, element, param ) {
            var length = $.isArray( value ) ? value.length : this.getLength( $.trim( value ), element );
            return this.optional( element ) || length >= param;
        },

        // http://jqueryvalidation.org/maxlength-method/
        maxlength: function( value, element, param ) {
            var length = $.isArray( value ) ? value.length : this.getLength( $.trim( value ), element );
            return this.optional( element ) || length <= param;
        },

        // http://jqueryvalidation.org/rangelength-method/
        rangelength: function( value, element, param ) {
            var length = $.isArray( value ) ? value.length : this.getLength( $.trim( value ), element );
            return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
        },

        // http://jqueryvalidation.org/min-method/
        min: function( value, element, param ) {
            return this.optional( element ) || value >= param;
        },

        // http://jqueryvalidation.org/max-method/
        max: function( value, element, param ) {
            return this.optional( element ) || value <= param;
        },

        // http://jqueryvalidation.org/range-method/
        range: function( value, element, param ) {
            return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
        },

        // http://jqueryvalidation.org/equalTo-method/
        equalTo: function( value, element, param ) {
            // bind to the blur event of the target in order to revalidate whenever the target field is updated
            // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
            var target = $( param );
            if ( this.settings.onfocusout ) {
                target.unbind( ".validate-equalTo" ).bind( "blur.validate-equalTo", function() {
                    $( element ).valid();
                });
            }
            return value === target.val();
        },

        // http://jqueryvalidation.org/remote-method/
        remote: function( value, element, param ) {
            if ( this.optional( element ) ) {
                return "dependency-mismatch";
            }

            var previous = this.previousValue( element ),
                validator, data;

            if (!this.settings.messages[ element.name ] ) {
                this.settings.messages[ element.name ] = {};
            }
            previous.originalMessage = this.settings.messages[ element.name ].remote;
            this.settings.messages[ element.name ].remote = previous.message;

            param = typeof param === "string" && { url: param } || param;

            if ( previous.old === value ) {
                return previous.valid;
            }

            previous.old = value;
            validator = this;
            this.startRequest( element );
            data = {};
            data[ element.name ] = value;
            $.ajax( $.extend( true, {
                url: param,
                mode: "abort",
                port: "validate" + element.name,
                dataType: "json",
                data: data,
                context: validator.currentForm,
                success: function( response ) {
                    var valid = response === true || response === "true",
                        errors, message, submitted;

                    validator.settings.messages[ element.name ].remote = previous.originalMessage;
                    if ( valid ) {
                        submitted = validator.formSubmitted;
                        validator.prepareElement( element );
                        validator.formSubmitted = submitted;
                        validator.successList.push( element );
                        delete validator.invalid[ element.name ];
                        validator.showErrors();
                    } else {
                        errors = {};
                        message = response || validator.defaultMessage( element, "remote" );
                        errors[ element.name ] = previous.message = $.isFunction( message ) ? message( value ) : message;
                        validator.invalid[ element.name ] = true;
                        validator.showErrors( errors );
                    }
                    previous.valid = valid;
                    validator.stopRequest( element, valid );
                }
            }, param ) );
            return "pending";
        }

    }

    });

    $.format = function deprecated() {
        throw "$.format has been deprecated. Please use $.validator.format instead.";
    };
/*-------------------------------  Magnific  ------------------------------------*/
    /*! Magnific Popup - v0.9.9 - 2014-09-06
    * http://dimsemenov.com/plugins/magnific-popup/
    * Copyright (c) 2014 Dmitry Semenov; */
(function ($) {

    /*>>core*/
    /**
     * 
     * Magnific Popup Core JS file
     * 
     */


    /**
     * Private static constants
     */
    var CLOSE_EVENT = 'Close',
        BEFORE_CLOSE_EVENT = 'BeforeClose',
        AFTER_CLOSE_EVENT = 'AfterClose',
        BEFORE_APPEND_EVENT = 'BeforeAppend',
        MARKUP_PARSE_EVENT = 'MarkupParse',
        OPEN_EVENT = 'Open',
        CHANGE_EVENT = 'Change',
        NS = 'mfp',
        EVENT_NS = '.' + NS,
        READY_CLASS = 'mfp-ready',
        REMOVING_CLASS = 'mfp-removing',
        PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


    /**
     * Private vars 
     */
    var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
        MagnificPopup = function(){},
        _isJQ = !!(window.jQuery),
        _prevStatus,
        _window = $(window),
        _body,
        _document,
        _prevContentType,
        _wrapClasses,
        _currPopupType;


    /**
     * Private functions
     */
    var _mfpOn = function(name, f) {
            mfp.ev.on(NS + name + EVENT_NS, f);
        },
        _getEl = function(className, appendTo, html, raw) {
            var el = document.createElement('div');
            el.className = 'mfp-'+className;
            if(html) {
                el.innerHTML = html;
            }
            if(!raw) {
                el = $(el);
                if(appendTo) {
                    el.appendTo(appendTo);
                }
            } else if(appendTo) {
                appendTo.appendChild(el);
            }
            return el;
        },
        _mfpTrigger = function(e, data) {
            mfp.ev.triggerHandler(NS + e, data);

            if(mfp.st.callbacks) {
                // converts "mfpEventName" to "eventName" callback and triggers it if it's present
                e = e.charAt(0).toLowerCase() + e.slice(1);
                if(mfp.st.callbacks[e]) {
                    mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
                }
            }
        },
        _getCloseBtn = function(type) {
            if(type !== _currPopupType || !mfp.currTemplate.closeBtn) {
                mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace('%title%', mfp.st.tClose ) );
                _currPopupType = type;
            }
            return mfp.currTemplate.closeBtn;
        },
        // Initialize Magnific Popup only when called at least once
        _checkInstance = function() {
            if(!$.magnificPopup.instance) {
                mfp = new MagnificPopup();
                mfp.init();
                $.magnificPopup.instance = mfp;
            }
        },
        // CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
        supportsTransitions = function() {
            var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
                v = ['ms','O','Moz','Webkit']; // 'v' for vendor

            if( s['transition'] !== undefined ) {
                return true; 
            }
                
            while( v.length ) {
                if( v.pop() + 'Transition' in s ) {
                    return true;
                }
            }
                    
            return false;
        };



    /**
     * Public functions
     */
    MagnificPopup.prototype = {

        constructor: MagnificPopup,

        /**
         * Initializes Magnific Popup plugin. 
         * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
         */
        init: function() {
            var appVersion = navigator.appVersion;
            mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1; 
            mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
            mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
            mfp.isAndroid = (/android/gi).test(appVersion);
            mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
            mfp.supportsTransition = supportsTransitions();

            // We disable fixed positioned lightbox on devices that don't handle it nicely.
            // If you know a better way of detecting this - let me know.
            mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) );
            _document = $(document);

            mfp.popupsCache = {};
        },

        /**
         * Opens popup
         * @param  data [description]
         */
        open: function(data) {

            if(!_body) {
                _body = $(document.body);
            }

            var i;

            if(data.isObj === false) { 
                // convert jQuery collection to array to avoid conflicts later
                mfp.items = data.items.toArray();

                mfp.index = 0;
                var items = data.items,
                    item;
                for(i = 0; i < items.length; i++) {
                    item = items[i];
                    if(item.parsed) {
                        item = item.el[0];
                    }
                    if(item === data.el[0]) {
                        mfp.index = i;
                        break;
                    }
                }
            } else {
                mfp.items = $.isArray(data.items) ? data.items : [data.items];
                mfp.index = data.index || 0;
            }

            // if popup is already opened - we just update the content
            if(mfp.isOpen) {
                mfp.updateItemHTML();
                return;
            }
            
            mfp.types = []; 
            _wrapClasses = '';
            if(data.mainEl && data.mainEl.length) {
                mfp.ev = data.mainEl.eq(0);
            } else {
                mfp.ev = _document;
            }

            if(data.key) {
                if(!mfp.popupsCache[data.key]) {
                    mfp.popupsCache[data.key] = {};
                }
                mfp.currTemplate = mfp.popupsCache[data.key];
            } else {
                mfp.currTemplate = {};
            }



            mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data ); 
            mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

            if(mfp.st.modal) {
                mfp.st.closeOnContentClick = false;
                mfp.st.closeOnBgClick = false;
                mfp.st.showCloseBtn = false;
                mfp.st.enableEscapeKey = false;
            }
            

            // Building markup
            // main containers are created only once
            if(!mfp.bgOverlay) {

                // Dark overlay
                mfp.bgOverlay = _getEl('bg').on('click'+EVENT_NS, function() {
                    mfp.close();
                });

                mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click'+EVENT_NS, function(e) {
                    if(mfp._checkIfClose(e.target)) {
                        mfp.close();
                    }
                });

                mfp.container = _getEl('container', mfp.wrap);
            }

            mfp.contentContainer = _getEl('content');
            if(mfp.st.preloader) {
                mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
            }


            // Initializing modules
            var modules = $.magnificPopup.modules;
            for(i = 0; i < modules.length; i++) {
                var n = modules[i];
                n = n.charAt(0).toUpperCase() + n.slice(1);
                mfp['init'+n].call(mfp);
            }
            _mfpTrigger('BeforeOpen');


            if(mfp.st.showCloseBtn) {
                // Close button
                if(!mfp.st.closeBtnInside) {
                    mfp.wrap.append( _getCloseBtn() );
                } else {
                    _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
                        values.close_replaceWith = _getCloseBtn(item.type);
                    });
                    _wrapClasses += ' mfp-close-btn-in';
                }
            }

            if(mfp.st.alignTop) {
                _wrapClasses += ' mfp-align-top';
            }

        

            if(mfp.fixedContentPos) {
                mfp.wrap.css({
                    overflow: mfp.st.overflowY,
                    overflowX: 'hidden',
                    overflowY: mfp.st.overflowY
                });
            } else {
                mfp.wrap.css({ 
                    top: _window.scrollTop(),
                    position: 'absolute'
                });
            }
            if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) ) {
                mfp.bgOverlay.css({
                    height: _document.height(),
                    position: 'absolute'
                });
            }

            

            if(mfp.st.enableEscapeKey) {
                // Close on ESC key
                _document.on('keyup' + EVENT_NS, function(e) {
                    if(e.keyCode === 27) {
                        mfp.close();
                    }
                });
            }

            _window.on('resize' + EVENT_NS, function() {
                mfp.updateSize();
            });


            if(!mfp.st.closeOnContentClick) {
                _wrapClasses += ' mfp-auto-cursor';
            }
            
            if(_wrapClasses)
                mfp.wrap.addClass(_wrapClasses);


            // this triggers recalculation of layout, so we get it once to not to trigger twice
            var windowHeight = mfp.wH = _window.height();

            
            var windowStyles = {};

            if( mfp.fixedContentPos ) {
                if(mfp._hasScrollBar(windowHeight)){
                    var s = mfp._getScrollbarSize();
                    if(s) {
                        windowStyles.marginRight = s;
                    }
                }
            }

            if(mfp.fixedContentPos) {
                if(!mfp.isIE7) {
                    windowStyles.overflow = 'hidden';
                } else {
                    // ie7 double-scroll bug
                    $('body, html').css('overflow', 'hidden');
                }
            }

            
            
            var classesToadd = mfp.st.mainClass;
            if(mfp.isIE7) {
                classesToadd += ' mfp-ie7';
            }
            if(classesToadd) {
                mfp._addClassToMFP( classesToadd );
            }

            // add content
            mfp.updateItemHTML();

            _mfpTrigger('BuildControls');

            // remove scrollbar, add margin e.t.c
            $('html').css(windowStyles);
            
            // add everything to DOM
            mfp.bgOverlay.add(mfp.wrap).prependTo( mfp.st.prependTo || _body );

            // Save last focused element
            mfp._lastFocusedEl = document.activeElement;
            
            // Wait for next cycle to allow CSS transition
            setTimeout(function() {
                
                if(mfp.content) {
                    mfp._addClassToMFP(READY_CLASS);
                    mfp._setFocus();
                } else {
                    // if content is not defined (not loaded e.t.c) we add class only for BG
                    mfp.bgOverlay.addClass(READY_CLASS);
                }
                
                // Trap the focus in popup
                _document.on('focusin' + EVENT_NS, mfp._onFocusIn);

            }, 16);

            mfp.isOpen = true;
            mfp.updateSize(windowHeight);
            _mfpTrigger(OPEN_EVENT);

            return data;
        },

        /**
         * Closes the popup
         */
        close: function() {
            if(!mfp.isOpen) return;
            _mfpTrigger(BEFORE_CLOSE_EVENT);

            mfp.isOpen = false;
            // for CSS3 animation
            if(mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition )  {
                mfp._addClassToMFP(REMOVING_CLASS);
                setTimeout(function() {
                    mfp._close();
                }, mfp.st.removalDelay);
            } else {
                mfp._close();
            }
        },

        /**
         * Helper for close() function
         */
        _close: function() {
            _mfpTrigger(CLOSE_EVENT);

            var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

            mfp.bgOverlay.detach();
            mfp.wrap.detach();
            mfp.container.empty();

            if(mfp.st.mainClass) {
                classesToRemove += mfp.st.mainClass + ' ';
            }

            mfp._removeClassFromMFP(classesToRemove);

            if(mfp.fixedContentPos) {
                var windowStyles = {marginRight: ''};
                if(mfp.isIE7) {
                    $('body, html').css('overflow', '');
                } else {
                    windowStyles.overflow = '';
                }
                $('html').css(windowStyles);
            }
            
            _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
            mfp.ev.off(EVENT_NS);

            // clean up DOM elements that aren't removed
            mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
            mfp.bgOverlay.attr('class', 'mfp-bg');
            mfp.container.attr('class', 'mfp-container');

            // remove close button from target element
            if(mfp.st.showCloseBtn &&
            (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
                if(mfp.currTemplate.closeBtn)
                    mfp.currTemplate.closeBtn.detach();
            }


            if(mfp._lastFocusedEl) {
                $(mfp._lastFocusedEl).focus(); // put tab focus back
            }
            mfp.currItem = null;    
            mfp.content = null;
            mfp.currTemplate = null;
            mfp.prevHeight = 0;

            _mfpTrigger(AFTER_CLOSE_EVENT);
        },
        
        updateSize: function(winHeight) {

            if(mfp.isIOS) {
                // fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
                var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
                var height = window.innerHeight * zoomLevel;
                mfp.wrap.css('height', height);
                mfp.wH = height;
            } else {
                mfp.wH = winHeight || _window.height();
            }
            // Fixes #84: popup incorrectly positioned with position:relative on body
            if(!mfp.fixedContentPos) {
                mfp.wrap.css('height', mfp.wH);
            }

            _mfpTrigger('Resize');

        },

        /**
         * Set content of popup based on current index
         */
        updateItemHTML: function() {
            var item = mfp.items[mfp.index];

            // Detach and perform modifications
            mfp.contentContainer.detach();

            if(mfp.content)
                mfp.content.detach();

            if(!item.parsed) {
                item = mfp.parseEl( mfp.index );
            }

            var type = item.type;   

            _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
            // BeforeChange event works like so:
            // _mfpOn('BeforeChange', function(e, prevType, newType) { });
            
            mfp.currItem = item;

            

            

            if(!mfp.currTemplate[type]) {
                var markup = mfp.st[type] ? mfp.st[type].markup : false;

                // allows to modify markup
                _mfpTrigger('FirstMarkupParse', markup);

                if(markup) {
                    mfp.currTemplate[type] = $(markup);
                } else {
                    // if there is no markup found we just define that template is parsed
                    mfp.currTemplate[type] = true;
                }
            }

            if(_prevContentType && _prevContentType !== item.type) {
                mfp.container.removeClass('mfp-'+_prevContentType+'-holder');
            }
            
            var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
            mfp.appendContent(newContent, type);

            item.preloaded = true;

            _mfpTrigger(CHANGE_EVENT, item);
            _prevContentType = item.type;
            
            // Append container back after its content changed
            mfp.container.prepend(mfp.contentContainer);

            _mfpTrigger('AfterChange');
        },


        /**
         * Set HTML content of popup
         */
        appendContent: function(newContent, type) {
            mfp.content = newContent;
            
            if(newContent) {
                if(mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
                    mfp.currTemplate[type] === true) {
                    // if there is no markup, we just append close button element inside
                    if(!mfp.content.find('.mfp-close').length) {
                        mfp.content.append(_getCloseBtn());
                    }
                } else {
                    mfp.content = newContent;
                }
            } else {
                mfp.content = '';
            }

            _mfpTrigger(BEFORE_APPEND_EVENT);
            mfp.container.addClass('mfp-'+type+'-holder');

            mfp.contentContainer.append(mfp.content);
        },



        
        /**
         * Creates Magnific Popup data object based on given data
         * @param  {int} index Index of item to parse
         */
        parseEl: function(index) {
            var item = mfp.items[index],
                type;

            if(item.tagName) {
                item = { el: $(item) };
            } else {
                type = item.type;
                item = { data: item, src: item.src };
            }

            if(item.el) {
                var types = mfp.types;

                // check for 'mfp-TYPE' class
                for(var i = 0; i < types.length; i++) {
                    if( item.el.hasClass('mfp-'+types[i]) ) {
                        type = types[i];
                        break;
                    }
                }

                item.src = item.el.attr('data-mfp-src');
                if(!item.src) {
                    item.src = item.el.attr('href');
                }
            }

            item.type = type || mfp.st.type || 'inline';
            item.index = index;
            item.parsed = true;
            mfp.items[index] = item;
            _mfpTrigger('ElementParse', item);

            return mfp.items[index];
        },


        /**
         * Initializes single popup or a group of popups
         */
        addGroup: function(el, options) {
            var eHandler = function(e) {
                e.mfpEl = this;
                mfp._openClick(e, el, options);
            };

            if(!options) {
                options = {};
            } 

            var eName = 'click.magnificPopup';
            options.mainEl = el;
            
            if(options.items) {
                options.isObj = true;
                el.off(eName).on(eName, eHandler);
            } else {
                options.isObj = false;
                if(options.delegate) {
                    el.off(eName).on(eName, options.delegate , eHandler);
                } else {
                    options.items = el;
                    el.off(eName).on(eName, eHandler);
                }
            }
        },
        _openClick: function(e, el, options) {
            var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


            if(!midClick && ( e.which === 2 || e.ctrlKey || e.metaKey ) ) {
                return;
            }

            var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

            if(disableOn) {
                if($.isFunction(disableOn)) {
                    if( !disableOn.call(mfp) ) {
                        return true;
                    }
                } else { // else it's number
                    if( _window.width() < disableOn ) {
                        return true;
                    }
                }
            }
            
            if(e.type) {
                e.preventDefault();

                // This will prevent popup from closing if element is inside and popup is already opened
                if(mfp.isOpen) {
                    e.stopPropagation();
                }
            }
                

            options.el = $(e.mfpEl);
            if(options.delegate) {
                options.items = el.find(options.delegate);
            }
            mfp.open(options);
        },


        /**
         * Updates text on preloader
         */
        updateStatus: function(status, text) {

            if(mfp.preloader) {
                if(_prevStatus !== status) {
                    mfp.container.removeClass('mfp-s-'+_prevStatus);
                }

                if(!text && status === 'loading') {
                    text = mfp.st.tLoading;
                }

                var data = {
                    status: status,
                    text: text
                };
                // allows to modify status
                _mfpTrigger('UpdateStatus', data);

                status = data.status;
                text = data.text;

                mfp.preloader.html(text);

                mfp.preloader.find('a').on('click', function(e) {
                    e.stopImmediatePropagation();
                });

                mfp.container.addClass('mfp-s-'+status);
                _prevStatus = status;
            }
        },


        /*
            "Private" helpers that aren't private at all
         */
        // Check to close popup or not
        // "target" is an element that was clicked
        _checkIfClose: function(target) {

            if($(target).hasClass(PREVENT_CLOSE_CLASS)) {
                return;
            }

            var closeOnContent = mfp.st.closeOnContentClick;
            var closeOnBg = mfp.st.closeOnBgClick;

            if(closeOnContent && closeOnBg) {
                return true;
            } else {

                // We close the popup if click is on close button or on preloader. Or if there is no content.
                if(!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0]) ) {
                    return true;
                }

                // if click is outside the content
                if(  (target !== mfp.content[0] && !$.contains(mfp.content[0], target))  ) {
                    if(closeOnBg) {
                        // last check, if the clicked element is in DOM, (in case it's removed onclick)
                        if( $.contains(document, target) ) {
                            return true;
                        }
                    }
                } else if(closeOnContent) {
                    return true;
                }

            }
            return false;
        },
        _addClassToMFP: function(cName) {
            mfp.bgOverlay.addClass(cName);
            mfp.wrap.addClass(cName);
        },
        _removeClassFromMFP: function(cName) {
            this.bgOverlay.removeClass(cName);
            mfp.wrap.removeClass(cName);
        },
        _hasScrollBar: function(winHeight) {
            return (  (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()) );
        },
        _setFocus: function() {
            (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
        },
        _onFocusIn: function(e) {
            if( e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target) ) {
                mfp._setFocus();
                return false;
            }
        },
        _parseMarkup: function(template, values, item) {
            var arr;
            if(item.data) {
                values = $.extend(item.data, values);
            }
            _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] );

            $.each(values, function(key, value) {
                if(value === undefined || value === false) {
                    return true;
                }
                arr = key.split('_');
                if(arr.length > 1) {
                    var el = template.find(EVENT_NS + '-'+arr[0]);

                    if(el.length > 0) {
                        var attr = arr[1];
                        if(attr === 'replaceWith') {
                            if(el[0] !== value[0]) {
                                el.replaceWith(value);
                            }
                        } else if(attr === 'img') {
                            if(el.is('img')) {
                                el.attr('src', value);
                            } else {
                                el.replaceWith( '<img src="'+value+'" class="' + el.attr('class') + '" />' );
                            }
                        } else {
                            el.attr(arr[1], value);
                        }
                    }

                } else {
                    template.find(EVENT_NS + '-'+key).html(value);
                }
            });
        },

        _getScrollbarSize: function() {
            // thx David
            if(mfp.scrollbarSize === undefined) {
                var scrollDiv = document.createElement("div");
                scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
                document.body.appendChild(scrollDiv);
                mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
                document.body.removeChild(scrollDiv);
            }
            return mfp.scrollbarSize;
        }

    }; /* MagnificPopup core prototype end */




    /**
     * Public static functions
     */
    $.magnificPopup = {
        instance: null,
        proto: MagnificPopup.prototype,
        modules: [],

        open: function(options, index) {
            _checkInstance();   

            if(!options) {
                options = {};
            } else {
                options = $.extend(true, {}, options);
            }
                

            options.isObj = true;
            options.index = index || 0;
            return this.instance.open(options);
        },

        close: function() {
            return $.magnificPopup.instance && $.magnificPopup.instance.close();
        },

        registerModule: function(name, module) {
            if(module.options) {
                $.magnificPopup.defaults[name] = module.options;
            }
            $.extend(this.proto, module.proto);         
            this.modules.push(name);
        },

        defaults: {   

            // Info about options is in docs:
            // http://dimsemenov.com/plugins/magnific-popup/documentation.html#options
            
            disableOn: 0,   

            key: null,

            midClick: false,

            mainClass: '',

            preloader: true,

            focus: '', // CSS selector of input to focus after popup is opened
            
            closeOnContentClick: false,

            closeOnBgClick: true,

            closeBtnInside: true, 

            showCloseBtn: true,

            enableEscapeKey: true,

            modal: false,

            alignTop: false,
        
            removalDelay: 0,

            prependTo: null,
            
            fixedContentPos: 'auto', 
        
            fixedBgPos: 'auto',

            overflowY: 'auto',

            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>',

            tClose: 'Close (Esc)',

            tLoading: 'Loading...'

        }
    };



    $.fn.magnificPopup = function(options) {
        _checkInstance();

        var jqEl = $(this);

        // We call some API method of first param is a string
        if (typeof options === "string" ) {

            if(options === 'open') {
                var items,
                    itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
                    index = parseInt(arguments[1], 10) || 0;

                if(itemOpts.items) {
                    items = itemOpts.items[index];
                } else {
                    items = jqEl;
                    if(itemOpts.delegate) {
                        items = items.find(itemOpts.delegate);
                    }
                    items = items.eq( index );
                }
                mfp._openClick({mfpEl:items}, jqEl, itemOpts);
            } else {
                if(mfp.isOpen)
                    mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
            }

        } else {
            // clone options obj
            options = $.extend(true, {}, options);
            
            /*
             * As Zepto doesn't support .data() method for objects 
             * and it works only in normal browsers
             * we assign "options" object directly to the DOM element. FTW!
             */
            if(_isJQ) {
                jqEl.data('magnificPopup', options);
            } else {
                jqEl[0].magnificPopup = options;
            }

            mfp.addGroup(jqEl, options);

        }
        return jqEl;
    };


    //Quick benchmark
    /*
    var start = performance.now(),
        i,
        rounds = 1000;

    for(i = 0; i < rounds; i++) {

    }
    console.log('Test #1:', performance.now() - start);

    start = performance.now();
    for(i = 0; i < rounds; i++) {

    }
    console.log('Test #2:', performance.now() - start);
    */


    /*>>core*/

    /*>>inline*/

    var INLINE_NS = 'inline',
        _hiddenClass,
        _inlinePlaceholder, 
        _lastInlineElement,
        _putInlineElementsBack = function() {
            if(_lastInlineElement) {
                _inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach();
                _lastInlineElement = null;
            }
        };

    $.magnificPopup.registerModule(INLINE_NS, {
        options: {
            hiddenClass: 'hide', // will be appended with `mfp-` prefix
            markup: '',
            tNotFound: 'Content not found'
        },
        proto: {

            initInline: function() {
                mfp.types.push(INLINE_NS);

                _mfpOn(CLOSE_EVENT+'.'+INLINE_NS, function() {
                    _putInlineElementsBack();
                });
            },

            getInline: function(item, template) {

                _putInlineElementsBack();

                if(item.src) {
                    var inlineSt = mfp.st.inline,
                        el = $(item.src);

                    if(el.length) {

                        // If target element has parent - we replace it with placeholder and put it back after popup is closed
                        var parent = el[0].parentNode;
                        if(parent && parent.tagName) {
                            if(!_inlinePlaceholder) {
                                _hiddenClass = inlineSt.hiddenClass;
                                _inlinePlaceholder = _getEl(_hiddenClass);
                                _hiddenClass = 'mfp-'+_hiddenClass;
                            }
                            // replace target inline element with placeholder
                            _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
                        }

                        mfp.updateStatus('ready');
                    } else {
                        mfp.updateStatus('error', inlineSt.tNotFound);
                        el = $('<div>');
                    }

                    item.inlineElement = el;
                    return el;
                }

                mfp.updateStatus('ready');
                mfp._parseMarkup(template, {}, item);
                return template;
            }
        }
    });

    /*>>inline*/

    /*>>ajax*/
    var AJAX_NS = 'ajax',
        _ajaxCur,
        _removeAjaxCursor = function() {
            if(_ajaxCur) {
                _body.removeClass(_ajaxCur);
            }
        },
        _destroyAjaxRequest = function() {
            _removeAjaxCursor();
            if(mfp.req) {
                mfp.req.abort();
            }
        };

    $.magnificPopup.registerModule(AJAX_NS, {

        options: {
            settings: null,
            cursor: 'mfp-ajax-cur',
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },

        proto: {
            initAjax: function() {
                mfp.types.push(AJAX_NS);
                _ajaxCur = mfp.st.ajax.cursor;

                _mfpOn(CLOSE_EVENT+'.'+AJAX_NS, _destroyAjaxRequest);
                _mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
            },
            getAjax: function(item) {

                if(_ajaxCur)
                    _body.addClass(_ajaxCur);

                mfp.updateStatus('loading');

                var opts = $.extend({
                    url: item.src,
                    success: function(data, textStatus, jqXHR) {
                        var temp = {
                            data:data,
                            xhr:jqXHR
                        };

                        _mfpTrigger('ParseAjax', temp);

                        mfp.appendContent( $(temp.data), AJAX_NS );

                        item.finished = true;

                        _removeAjaxCursor();

                        mfp._setFocus();

                        setTimeout(function() {
                            mfp.wrap.addClass(READY_CLASS);
                        }, 16);

                        mfp.updateStatus('ready');

                        _mfpTrigger('AjaxContentAdded');
                    },
                    error: function() {
                        _removeAjaxCursor();
                        item.finished = item.loadError = true;
                        mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
                    }
                }, mfp.st.ajax.settings);

                mfp.req = $.ajax(opts);

                return '';
            }
        }
    });





        

    /*>>ajax*/

    /*>>image*/
    var _imgInterval,
        _getTitle = function(item) {
            if(item.data && item.data.title !== undefined) 
                return item.data.title;

            var src = mfp.st.image.titleSrc;

            if(src) {
                if($.isFunction(src)) {
                    return src.call(mfp, item);
                } else if(item.el) {
                    return item.el.attr(src) || '';
                }
            }
            return '';
        };

    $.magnificPopup.registerModule('image', {

        options: {
            markup: '<div class="mfp-figure">'+
                        '<div class="mfp-close"></div>'+
                        '<figure>'+
                            '<div class="mfp-img"></div>'+
                            '<figcaption>'+
                                '<div class="mfp-bottom-bar">'+
                                    '<div class="mfp-title"></div>'+
                                    '<div class="mfp-counter"></div>'+
                                '</div>'+
                            '</figcaption>'+
                        '</figure>'+
                    '</div>',
            cursor: 'mfp-zoom-out-cur',
            titleSrc: 'title', 
            verticalFit: true,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },

        proto: {
            initImage: function() {
                var imgSt = mfp.st.image,
                    ns = '.image';

                mfp.types.push('image');

                _mfpOn(OPEN_EVENT+ns, function() {
                    if(mfp.currItem.type === 'image' && imgSt.cursor) {
                        _body.addClass(imgSt.cursor);
                    }
                });

                _mfpOn(CLOSE_EVENT+ns, function() {
                    if(imgSt.cursor) {
                        _body.removeClass(imgSt.cursor);
                    }
                    _window.off('resize' + EVENT_NS);
                });

                _mfpOn('Resize'+ns, mfp.resizeImage);
                if(mfp.isLowIE) {
                    _mfpOn('AfterChange', mfp.resizeImage);
                }
            },
            resizeImage: function() {
                var item = mfp.currItem;
                if(!item || !item.img) return;

                if(mfp.st.image.verticalFit) {
                    var decr = 0;
                    // fix box-sizing in ie7/8
                    if(mfp.isLowIE) {
                        decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'),10);
                    }
                    item.img.css('max-height', mfp.wH-decr);
                }
            },
            _onImageHasSize: function(item) {
                if(item.img) {
                    
                    item.hasSize = true;

                    if(_imgInterval) {
                        clearInterval(_imgInterval);
                    }
                    
                    item.isCheckingImgSize = false;

                    _mfpTrigger('ImageHasSize', item);

                    if(item.imgHidden) {
                        if(mfp.content)
                            mfp.content.removeClass('mfp-loading');
                        
                        item.imgHidden = false;
                    }

                }
            },

            /**
             * Function that loops until the image has size to display elements that rely on it asap
             */
            findImageSize: function(item) {

                var counter = 0,
                    img = item.img[0],
                    mfpSetInterval = function(delay) {

                        if(_imgInterval) {
                            clearInterval(_imgInterval);
                        }
                        // decelerating interval that checks for size of an image
                        _imgInterval = setInterval(function() {
                            if(img.naturalWidth > 0) {
                                mfp._onImageHasSize(item);
                                return;
                            }

                            if(counter > 200) {
                                clearInterval(_imgInterval);
                            }

                            counter++;
                            if(counter === 3) {
                                mfpSetInterval(10);
                            } else if(counter === 40) {
                                mfpSetInterval(50);
                            } else if(counter === 100) {
                                mfpSetInterval(500);
                            }
                        }, delay);
                    };

                mfpSetInterval(1);
            },

            getImage: function(item, template) {

                var guard = 0,

                    // image load complete handler
                    onLoadComplete = function() {
                        if(item) {
                            if (item.img[0].complete) {
                                item.img.off('.mfploader');
                                
                                if(item === mfp.currItem){
                                    mfp._onImageHasSize(item);

                                    mfp.updateStatus('ready');
                                }

                                item.hasSize = true;
                                item.loaded = true;

                                _mfpTrigger('ImageLoadComplete');
                                
                            }
                            else {
                                // if image complete check fails 200 times (20 sec), we assume that there was an error.
                                guard++;
                                if(guard < 200) {
                                    setTimeout(onLoadComplete,100);
                                } else {
                                    onLoadError();
                                }
                            }
                        }
                    },

                    // image error handler
                    onLoadError = function() {
                        if(item) {
                            item.img.off('.mfploader');
                            if(item === mfp.currItem){
                                mfp._onImageHasSize(item);
                                mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
                            }

                            item.hasSize = true;
                            item.loaded = true;
                            item.loadError = true;
                        }
                    },
                    imgSt = mfp.st.image;


                var el = template.find('.mfp-img');
                if(el.length) {
                    var img = document.createElement('img');
                    img.className = 'mfp-img';
                    item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
                    img.src = item.src;

                    // without clone() "error" event is not firing when IMG is replaced by new IMG
                    // TODO: find a way to avoid such cloning
                    if(el.is('img')) {
                        item.img = item.img.clone();
                    }

                    img = item.img[0];
                    if(img.naturalWidth > 0) {
                        item.hasSize = true;
                    } else if(!img.width) {                                     
                        item.hasSize = false;
                    }
                }

                mfp._parseMarkup(template, {
                    title: _getTitle(item),
                    img_replaceWith: item.img
                }, item);

                mfp.resizeImage();

                if(item.hasSize) {
                    if(_imgInterval) clearInterval(_imgInterval);

                    if(item.loadError) {
                        template.addClass('mfp-loading');
                        mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
                    } else {
                        template.removeClass('mfp-loading');
                        mfp.updateStatus('ready');
                    }
                    return template;
                }

                mfp.updateStatus('loading');
                item.loading = true;

                if(!item.hasSize) {
                    item.imgHidden = true;
                    template.addClass('mfp-loading');
                    mfp.findImageSize(item);
                } 

                return template;
            }
        }
    });



    /*>>image*/

    /*>>zoom*/
    var hasMozTransform,
        getHasMozTransform = function() {
            if(hasMozTransform === undefined) {
                hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
            }
            return hasMozTransform;     
        };

    $.magnificPopup.registerModule('zoom', {

        options: {
            enabled: false,
            easing: 'ease-in-out',
            duration: 300,
            opener: function(element) {
                return element.is('img') ? element : element.find('img');
            }
        },

        proto: {

            initZoom: function() {
                var zoomSt = mfp.st.zoom,
                    ns = '.zoom',
                    image;
                    
                if(!zoomSt.enabled || !mfp.supportsTransition) {
                    return;
                }

                var duration = zoomSt.duration,
                    getElToAnimate = function(image) {
                        var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
                            transition = 'all '+(zoomSt.duration/1000)+'s ' + zoomSt.easing,
                            cssObj = {
                                position: 'fixed',
                                zIndex: 9999,
                                left: 0,
                                top: 0,
                                '-webkit-backface-visibility': 'hidden'
                            },
                            t = 'transition';

                        cssObj['-webkit-'+t] = cssObj['-moz-'+t] = cssObj['-o-'+t] = cssObj[t] = transition;

                        newImg.css(cssObj);
                        return newImg;
                    },
                    showMainContent = function() {
                        mfp.content.css('visibility', 'visible');
                    },
                    openTimeout,
                    animatedImg;

                _mfpOn('BuildControls'+ns, function() {
                    if(mfp._allowZoom()) {

                        clearTimeout(openTimeout);
                        mfp.content.css('visibility', 'hidden');

                        // Basically, all code below does is clones existing image, puts in on top of the current one and animated it
                        
                        image = mfp._getItemToZoom();

                        if(!image) {
                            showMainContent();
                            return;
                        }

                        animatedImg = getElToAnimate(image); 
                        
                        animatedImg.css( mfp._getOffset() );

                        mfp.wrap.append(animatedImg);

                        openTimeout = setTimeout(function() {
                            animatedImg.css( mfp._getOffset( true ) );
                            openTimeout = setTimeout(function() {

                                showMainContent();

                                setTimeout(function() {
                                    animatedImg.remove();
                                    image = animatedImg = null;
                                    _mfpTrigger('ZoomAnimationEnded');
                                }, 16); // avoid blink when switching images 

                            }, duration); // this timeout equals animation duration

                        }, 16); // by adding this timeout we avoid short glitch at the beginning of animation


                        // Lots of timeouts...
                    }
                });
                _mfpOn(BEFORE_CLOSE_EVENT+ns, function() {
                    if(mfp._allowZoom()) {

                        clearTimeout(openTimeout);

                        mfp.st.removalDelay = duration;

                        if(!image) {
                            image = mfp._getItemToZoom();
                            if(!image) {
                                return;
                            }
                            animatedImg = getElToAnimate(image);
                        }
                        
                        
                        animatedImg.css( mfp._getOffset(true) );
                        mfp.wrap.append(animatedImg);
                        mfp.content.css('visibility', 'hidden');
                        
                        setTimeout(function() {
                            animatedImg.css( mfp._getOffset() );
                        }, 16);
                    }

                });

                _mfpOn(CLOSE_EVENT+ns, function() {
                    if(mfp._allowZoom()) {
                        showMainContent();
                        if(animatedImg) {
                            animatedImg.remove();
                        }
                        image = null;
                    }   
                });
            },

            _allowZoom: function() {
                return mfp.currItem.type === 'image';
            },

            _getItemToZoom: function() {
                if(mfp.currItem.hasSize) {
                    return mfp.currItem.img;
                } else {
                    return false;
                }
            },

            // Get element postion relative to viewport
            _getOffset: function(isLarge) {
                var el;
                if(isLarge) {
                    el = mfp.currItem.img;
                } else {
                    el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
                }

                var offset = el.offset();
                var paddingTop = parseInt(el.css('padding-top'),10);
                var paddingBottom = parseInt(el.css('padding-bottom'),10);
                offset.top -= ( $(window).scrollTop() - paddingTop );


                /*
                
                Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

                 */
                var obj = {
                    width: el.width(),
                    // fix Zepto height+padding issue
                    height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
                };

                // I hate to do this, but there is no another option
                if( getHasMozTransform() ) {
                    obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
                } else {
                    obj.left = offset.left;
                    obj.top = offset.top;
                }
                return obj;
            }

        }
    });



    /*>>zoom*/

    /*>>iframe*/

    var IFRAME_NS = 'iframe',
        _emptyPage = '//about:blank',
        
        _fixIframeBugs = function(isShowing) {
            if(mfp.currTemplate[IFRAME_NS]) {
                var el = mfp.currTemplate[IFRAME_NS].find('iframe');
                if(el.length) { 
                    // reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
                    if(!isShowing) {
                        el[0].src = _emptyPage;
                    }

                    // IE8 black screen bug fix
                    if(mfp.isIE8) {
                        el.css('display', isShowing ? 'block' : 'none');
                    }
                }
            }
        };

    $.magnificPopup.registerModule(IFRAME_NS, {

        options: {
            markup: '<div class="mfp-iframe-scaler">'+
                        '<div class="mfp-close"></div>'+
                        '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>'+
                    '</div>',

            srcAction: 'iframe_src',

            // we don't care and support only one default type of URL by default
            patterns: {
                youtube: {
                    index: 'youtube.com', 
                    id: 'v=', 
                    src: '//www.youtube.com/embed/%id%?autoplay=1'
                },
                vimeo: {
                    index: 'vimeo.com/',
                    id: '/',
                    src: '//player.vimeo.com/video/%id%?autoplay=1'
                },
                gmaps: {
                    index: '//maps.google.',
                    src: '%id%&output=embed'
                }
            }
        },

        proto: {
            initIframe: function() {
                mfp.types.push(IFRAME_NS);

                _mfpOn('BeforeChange', function(e, prevType, newType) {
                    if(prevType !== newType) {
                        if(prevType === IFRAME_NS) {
                            _fixIframeBugs(); // iframe if removed
                        } else if(newType === IFRAME_NS) {
                            _fixIframeBugs(true); // iframe is showing
                        } 
                    }// else {
                        // iframe source is switched, don't do anything
                    //}
                });

                _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() {
                    _fixIframeBugs();
                });
            },

            getIframe: function(item, template) {
                var embedSrc = item.src;
                var iframeSt = mfp.st.iframe;
                    
                $.each(iframeSt.patterns, function() {
                    if(embedSrc.indexOf( this.index ) > -1) {
                        if(this.id) {
                            if(typeof this.id === 'string') {
                                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length);
                            } else {
                                embedSrc = this.id.call( this, embedSrc );
                            }
                        }
                        embedSrc = this.src.replace('%id%', embedSrc );
                        return false; // break;
                    }
                });
                
                var dataObj = {};
                if(iframeSt.srcAction) {
                    dataObj[iframeSt.srcAction] = embedSrc;
                }
                mfp._parseMarkup(template, dataObj, item);

                mfp.updateStatus('ready');

                return template;
            }
        }
    });



    /*>>iframe*/

    /*>>gallery*/
    /**
     * Get looped index depending on number of slides
     */
    var _getLoopedId = function(index) {
            var numSlides = mfp.items.length;
            if(index > numSlides - 1) {
                return index - numSlides;
            } else  if(index < 0) {
                return numSlides + index;
            }
            return index;
        },
        _replaceCurrTotal = function(text, curr, total) {
            return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
        };

    $.magnificPopup.registerModule('gallery', {

        options: {
            enabled: false,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [0,2],
            navigateByImgClick: true,
            arrows: true,

            tPrev: 'Previous (Left arrow key)',
            tNext: 'Next (Right arrow key)',
            tCounter: '%curr% of %total%'
        },

        proto: {
            initGallery: function() {

                var gSt = mfp.st.gallery,
                    ns = '.mfp-gallery',
                    supportsFastClick = Boolean($.fn.mfpFastClick);

                mfp.direction = true; // true - next, false - prev
                
                if(!gSt || !gSt.enabled ) return false;

                _wrapClasses += ' mfp-gallery';

                _mfpOn(OPEN_EVENT+ns, function() {

                    if(gSt.navigateByImgClick) {
                        mfp.wrap.on('click'+ns, '.mfp-img', function() {
                            if(mfp.items.length > 1) {
                                mfp.next();
                                return false;
                            }
                        });
                    }

                    _document.on('keydown'+ns, function(e) {
                        if (e.keyCode === 37) {
                            mfp.prev();
                        } else if (e.keyCode === 39) {
                            mfp.next();
                        }
                    });
                });

                _mfpOn('UpdateStatus'+ns, function(e, data) {
                    if(data.text) {
                        data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
                    }
                });

                _mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) {
                    var l = mfp.items.length;
                    values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
                });

                _mfpOn('BuildControls' + ns, function() {
                    if(mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                        var markup = gSt.arrowMarkup,
                            arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left') ).addClass(PREVENT_CLOSE_CLASS),           
                            arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right') ).addClass(PREVENT_CLOSE_CLASS);

                        var eName = supportsFastClick ? 'mfpFastClick' : 'click';
                        arrowLeft[eName](function() {
                            mfp.prev();
                        });         
                        arrowRight[eName](function() {
                            mfp.next();
                        }); 

                        // Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b)
                        if(mfp.isIE7) {
                            _getEl('b', arrowLeft[0], false, true);
                            _getEl('a', arrowLeft[0], false, true);
                            _getEl('b', arrowRight[0], false, true);
                            _getEl('a', arrowRight[0], false, true);
                        }

                        mfp.container.append(arrowLeft.add(arrowRight));
                    }
                });

                _mfpOn(CHANGE_EVENT+ns, function() {
                    if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

                    mfp._preloadTimeout = setTimeout(function() {
                        mfp.preloadNearbyImages();
                        mfp._preloadTimeout = null;
                    }, 16);     
                });


                _mfpOn(CLOSE_EVENT+ns, function() {
                    _document.off(ns);
                    mfp.wrap.off('click'+ns);
                
                    if(mfp.arrowLeft && supportsFastClick) {
                        mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
                    }
                    mfp.arrowRight = mfp.arrowLeft = null;
                });

            }, 
            next: function() {
                mfp.direction = true;
                mfp.index = _getLoopedId(mfp.index + 1);
                mfp.updateItemHTML();
            },
            prev: function() {
                mfp.direction = false;
                mfp.index = _getLoopedId(mfp.index - 1);
                mfp.updateItemHTML();
            },
            goTo: function(newIndex) {
                mfp.direction = (newIndex >= mfp.index);
                mfp.index = newIndex;
                mfp.updateItemHTML();
            },
            preloadNearbyImages: function() {
                var p = mfp.st.gallery.preload,
                    preloadBefore = Math.min(p[0], mfp.items.length),
                    preloadAfter = Math.min(p[1], mfp.items.length),
                    i;

                for(i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
                    mfp._preloadItem(mfp.index+i);
                }
                for(i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
                    mfp._preloadItem(mfp.index-i);
                }
            },
            _preloadItem: function(index) {
                index = _getLoopedId(index);

                if(mfp.items[index].preloaded) {
                    return;
                }

                var item = mfp.items[index];
                if(!item.parsed) {
                    item = mfp.parseEl( index );
                }

                _mfpTrigger('LazyLoad', item);

                if(item.type === 'image') {
                    item.img = $('<img class="mfp-img" />').on('load.mfploader', function() {
                        item.hasSize = true;
                    }).on('error.mfploader', function() {
                        item.hasSize = true;
                        item.loadError = true;
                        _mfpTrigger('LazyLoadError', item);
                    }).attr('src', item.src);
                }


                item.preloaded = true;
            }
        }
    });

    /*
    Touch Support that might be implemented some day

    addSwipeGesture: function() {
        var startX,
            moved,
            multipleTouches;

            return;

        var namespace = '.mfp',
            addEventNames = function(pref, down, move, up, cancel) {
                mfp._tStart = pref + down + namespace;
                mfp._tMove = pref + move + namespace;
                mfp._tEnd = pref + up + namespace;
                mfp._tCancel = pref + cancel + namespace;
            };

        if(window.navigator.msPointerEnabled) {
            addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
        } else if('ontouchstart' in window) {
            addEventNames('touch', 'start', 'move', 'end', 'cancel');
        } else {
            return;
        }
        _window.on(mfp._tStart, function(e) {
            var oE = e.originalEvent;
            multipleTouches = moved = false;
            startX = oE.pageX || oE.changedTouches[0].pageX;
        }).on(mfp._tMove, function(e) {
            if(e.originalEvent.touches.length > 1) {
                multipleTouches = e.originalEvent.touches.length;
            } else {
                //e.preventDefault();
                moved = true;
            }
        }).on(mfp._tEnd + ' ' + mfp._tCancel, function(e) {
            if(moved && !multipleTouches) {
                var oE = e.originalEvent,
                    diff = startX - (oE.pageX || oE.changedTouches[0].pageX);

                if(diff > 20) {
                    mfp.next();
                } else if(diff < -20) {
                    mfp.prev();
                }
            }
        });
    },
    */


    /*>>gallery*/

    /*>>retina*/

    var RETINA_NS = 'retina';

    $.magnificPopup.registerModule(RETINA_NS, {
        options: {
            replaceSrc: function(item) {
                return item.src.replace(/\.\w+$/, function(m) { return '@2x' + m; });
            },
            ratio: 1 // Function or number.  Set to 1 to disable.
        },
        proto: {
            initRetina: function() {
                if(window.devicePixelRatio > 1) {

                    var st = mfp.st.retina,
                        ratio = st.ratio;

                    ratio = !isNaN(ratio) ? ratio : ratio();

                    if(ratio > 1) {
                        _mfpOn('ImageHasSize' + '.' + RETINA_NS, function(e, item) {
                            item.img.css({
                                'max-width': item.img[0].naturalWidth / ratio,
                                'width': '100%'
                            });
                        });
                        _mfpOn('ElementParse' + '.' + RETINA_NS, function(e, item) {
                            item.src = st.replaceSrc(item, ratio);
                        });
                    }
                }

            }
        }
    });

    /*>>retina*/

    /*>>fastclick*/
    /**
     * FastClick event implementation. (removes 300ms delay on touch devices)
     * Based on https://developers.google.com/mobile/articles/fast_buttons
     *
     * You may use it outside the Magnific Popup by calling just:
     *
     * $('.your-el').mfpFastClick(function() {
     *     console.log('Clicked!');
     * });
     *
     * To unbind:
     * $('.your-el').destroyMfpFastClick();
     * 
     * 
     * Note that it's a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
     * If you need something more advanced, use plugin by FT Labs https://github.com/ftlabs/fastclick
     * 
     */

    (function() {
        var ghostClickDelay = 1000,
            supportsTouch = 'ontouchstart' in window,
            unbindTouchMove = function() {
                _window.off('touchmove'+ns+' touchend'+ns);
            },
            eName = 'mfpFastClick',
            ns = '.'+eName;


        // As Zepto.js doesn't have an easy way to add custom events (like jQuery), so we implement it in this way
        $.fn.mfpFastClick = function(callback) {

            return $(this).each(function() {

                var elem = $(this),
                    lock;

                if( supportsTouch ) {

                    var timeout,
                        startX,
                        startY,
                        pointerMoved,
                        point,
                        numPointers;

                    elem.on('touchstart' + ns, function(e) {
                        pointerMoved = false;
                        numPointers = 1;

                        point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
                        startX = point.clientX;
                        startY = point.clientY;

                        _window.on('touchmove'+ns, function(e) {
                            point = e.originalEvent ? e.originalEvent.touches : e.touches;
                            numPointers = point.length;
                            point = point[0];
                            if (Math.abs(point.clientX - startX) > 10 ||
                                Math.abs(point.clientY - startY) > 10) {
                                pointerMoved = true;
                                unbindTouchMove();
                            }
                        }).on('touchend'+ns, function(e) {
                            unbindTouchMove();
                            if(pointerMoved || numPointers > 1) {
                                return;
                            }
                            lock = true;
                            e.preventDefault();
                            clearTimeout(timeout);
                            timeout = setTimeout(function() {
                                lock = false;
                            }, ghostClickDelay);
                            callback();
                        });
                    });

                }

                elem.on('click' + ns, function() {
                    if(!lock) {
                        callback();
                    }
                });
            });
        };

        $.fn.destroyMfpFastClick = function() {
            $(this).off('touchstart' + ns + ' click' + ns);
            if(supportsTouch) _window.off('touchmove'+ns+' touchend'+ns);
        };
    })();

    /*>>fastclick*/
     _checkInstance(); })(window.jQuery || window.Zepto);
/*-------------------------------  Fred  ---------------------------------------*/
    /*
     *  jQuery carouFredSel 6.2.1
     *  Demo's and documentation:
     *  caroufredsel.dev7studios.com
     *
     *  Copyright (c) 2013 Fred Heusschen
     *  www.frebsite.nl
     *
     *  Dual licensed under the MIT and GPL licenses.
     *  http://en.wikipedia.org/wiki/MIT_License
     *  http://en.wikipedia.org/wiki/GNU_General_Public_License
     */


    (function($) {


        //  LOCAL

        if ( $.fn.carouFredSel )
        {
            return;
        }

        $.fn.caroufredsel = $.fn.carouFredSel = function(options, configs)
        {

            //  no element
            if (this.length == 0)
            {
                debug( true, 'No element found for "' + this.selector + '".' );
                return this;
            }

            //  multiple elements
            if (this.length > 1)
            {
                return this.each(function() {
                    $(this).carouFredSel(options, configs);
                });
            }


            var $cfs = this,
                $tt0 = this[0],
                starting_position = false;

            if ($cfs.data('_cfs_isCarousel'))
            {
                starting_position = $cfs.triggerHandler('_cfs_triggerEvent', 'currentPosition');
                $cfs.trigger('_cfs_triggerEvent', ['destroy', true]);
            }

            var FN = {};

            FN._init = function(o, setOrig, start)
            {
                o = go_getObject($tt0, o);

                o.items = go_getItemsObject($tt0, o.items);
                o.scroll = go_getScrollObject($tt0, o.scroll);
                o.auto = go_getAutoObject($tt0, o.auto);
                o.prev = go_getPrevNextObject($tt0, o.prev);
                o.next = go_getPrevNextObject($tt0, o.next);
                o.pagination = go_getPaginationObject($tt0, o.pagination);
                o.swipe = go_getSwipeObject($tt0, o.swipe);
                o.mousewheel = go_getMousewheelObject($tt0, o.mousewheel);

                if (setOrig)
                {
                    opts_orig = $.extend(true, {}, $.fn.carouFredSel.defaults, o);
                }

                opts = $.extend(true, {}, $.fn.carouFredSel.defaults, o);
                opts.d = cf_getDimensions(opts);

                crsl.direction = (opts.direction == 'up' || opts.direction == 'left') ? 'next' : 'prev';

                var a_itm = $cfs.children(),
                    avail_primary = ms_getParentSize($wrp, opts, 'width');

                if (is_true(opts.cookie))
                {
                    opts.cookie = 'caroufredsel_cookie_' + conf.serialNumber;
                }

                opts.maxDimension = ms_getMaxDimension(opts, avail_primary);

                //  complement items and sizes
                opts.items = in_complementItems(opts.items, opts, a_itm, start);
                opts[opts.d['width']] = in_complementPrimarySize(opts[opts.d['width']], opts, a_itm);
                opts[opts.d['height']] = in_complementSecondarySize(opts[opts.d['height']], opts, a_itm);

                //  primary size not set for a responsive carousel
                if (opts.responsive)
                {
                    if (!is_percentage(opts[opts.d['width']]))
                    {
                        opts[opts.d['width']] = '100%';
                    }
                }

                //  primary size is percentage
                if (is_percentage(opts[opts.d['width']]))
                {
                    crsl.upDateOnWindowResize = true;
                    crsl.primarySizePercentage = opts[opts.d['width']];
                    opts[opts.d['width']] = ms_getPercentage(avail_primary, crsl.primarySizePercentage);
                    if (!opts.items.visible)
                    {
                        opts.items.visibleConf.variable = true;
                    }
                }

                if (opts.responsive)
                {
                    opts.usePadding = false;
                    opts.padding = [0, 0, 0, 0];
                    opts.align = false;
                    opts.items.visibleConf.variable = false;
                }
                else
                {
                    //  visible-items not set
                    if (!opts.items.visible)
                    {
                        opts = in_complementVisibleItems(opts, avail_primary);
                    }

                    //  primary size not set -> calculate it or set to "variable"
                    if (!opts[opts.d['width']])
                    {
                        if (!opts.items.visibleConf.variable && is_number(opts.items[opts.d['width']]) && opts.items.filter == '*')
                        {
                            opts[opts.d['width']] = opts.items.visible * opts.items[opts.d['width']];
                            opts.align = false;
                        }
                        else
                        {
                            opts[opts.d['width']] = 'variable';
                        }
                    }
                    //  align not set -> set to center if primary size is number
                    if (is_undefined(opts.align))
                    {
                        opts.align = (is_number(opts[opts.d['width']]))
                            ? 'center'
                            : false;
                    }
                    //  set variabe visible-items
                    if (opts.items.visibleConf.variable)
                    {
                        opts.items.visible = gn_getVisibleItemsNext(a_itm, opts, 0);
                    }
                }

                //  set visible items by filter
                if (opts.items.filter != '*' && !opts.items.visibleConf.variable)
                {
                    opts.items.visibleConf.org = opts.items.visible;
                    opts.items.visible = gn_getVisibleItemsNextFilter(a_itm, opts, 0);
                }

                opts.items.visible = cf_getItemsAdjust(opts.items.visible, opts, opts.items.visibleConf.adjust, $tt0);
                opts.items.visibleConf.old = opts.items.visible;

                if (opts.responsive)
                {
                    if (!opts.items.visibleConf.min)
                    {
                        opts.items.visibleConf.min = opts.items.visible;
                    }
                    if (!opts.items.visibleConf.max)
                    {
                        opts.items.visibleConf.max = opts.items.visible;
                    }
                    opts = in_getResponsiveValues(opts, a_itm, avail_primary);
                }
                else
                {
                    opts.padding = cf_getPadding(opts.padding);

                    if (opts.align == 'top')
                    {
                        opts.align = 'left';
                    }
                    else if (opts.align == 'bottom')
                    {
                        opts.align = 'right';
                    }

                    switch (opts.align)
                    {
                        //  align: center, left or right
                        case 'center':
                        case 'left':
                        case 'right':
                            if (opts[opts.d['width']] != 'variable')
                            {
                                opts = in_getAlignPadding(opts, a_itm);
                                opts.usePadding = true;
                            }
                            break;

                        //  padding
                        default:
                            opts.align = false;
                            opts.usePadding = (
                                opts.padding[0] == 0 && 
                                opts.padding[1] == 0 && 
                                opts.padding[2] == 0 && 
                                opts.padding[3] == 0
                            ) ? false : true;
                            break;
                    }
                }

                if (!is_number(opts.scroll.duration))
                {
                    opts.scroll.duration = 500;
                }
                if (is_undefined(opts.scroll.items))
                {
                    opts.scroll.items = (opts.responsive || opts.items.visibleConf.variable || opts.items.filter != '*') 
                        ? 'visible'
                        : opts.items.visible;
                }

                opts.auto = $.extend(true, {}, opts.scroll, opts.auto);
                opts.prev = $.extend(true, {}, opts.scroll, opts.prev);
                opts.next = $.extend(true, {}, opts.scroll, opts.next);
                opts.pagination = $.extend(true, {}, opts.scroll, opts.pagination);
                //  swipe and mousewheel extend later on, per direction

                opts.auto = go_complementAutoObject($tt0, opts.auto);
                opts.prev = go_complementPrevNextObject($tt0, opts.prev);
                opts.next = go_complementPrevNextObject($tt0, opts.next);
                opts.pagination = go_complementPaginationObject($tt0, opts.pagination);
                opts.swipe = go_complementSwipeObject($tt0, opts.swipe);
                opts.mousewheel = go_complementMousewheelObject($tt0, opts.mousewheel);

                if (opts.synchronise)
                {
                    opts.synchronise = cf_getSynchArr(opts.synchronise);
                }


                //  DEPRECATED
                if (opts.auto.onPauseStart)
                {
                    opts.auto.onTimeoutStart = opts.auto.onPauseStart;
                    deprecated('auto.onPauseStart', 'auto.onTimeoutStart');
                }
                if (opts.auto.onPausePause)
                {
                    opts.auto.onTimeoutPause = opts.auto.onPausePause;
                    deprecated('auto.onPausePause', 'auto.onTimeoutPause');
                }
                if (opts.auto.onPauseEnd)
                {
                    opts.auto.onTimeoutEnd = opts.auto.onPauseEnd;
                    deprecated('auto.onPauseEnd', 'auto.onTimeoutEnd');
                }
                if (opts.auto.pauseDuration)
                {
                    opts.auto.timeoutDuration = opts.auto.pauseDuration;
                    deprecated('auto.pauseDuration', 'auto.timeoutDuration');
                }
                //  /DEPRECATED


            };  //  /init


            FN._build = function() {
                $cfs.data('_cfs_isCarousel', true);

                var a_itm = $cfs.children(),
                    orgCSS = in_mapCss($cfs, ['textAlign', 'float', 'position', 'top', 'right', 'bottom', 'left', 'zIndex', 'width', 'height', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft']),
                    newPosition = 'relative';

                switch (orgCSS.position)
                {
                    case 'absolute':
                    case 'fixed':
                        newPosition = orgCSS.position;
                        break;
                }

                if (conf.wrapper == 'parent')
                {
                    sz_storeOrigCss($wrp);
                }
                else
                {
                    $wrp.css(orgCSS);
                }
                $wrp.css({
                    'overflow'      : 'hidden',
                    'position'      : newPosition
                });

                sz_storeOrigCss($cfs);
                $cfs.data('_cfs_origCssZindex', orgCSS.zIndex);
                $cfs.css({
                    'textAlign'     : 'left',
                    'float'         : 'none',
                    'position'      : 'absolute',
                    'top'           : 0,
                    'right'         : 'auto',
                    'bottom'        : 'auto',
                    'left'          : 0,
                    'marginTop'     : 0,
                    'marginRight'   : 0,
                    'marginBottom'  : 0,
                    'marginLeft'    : 0
                });

                sz_storeMargin(a_itm, opts);
                sz_storeOrigCss(a_itm);
                if (opts.responsive)
                {
                    sz_setResponsiveSizes(opts, a_itm);
                }

            };  //  /build


            FN._bind_events = function() {
                FN._unbind_events();


                //  stop event
                $cfs.bind(cf_e('stop', conf), function(e, imm) {
                    e.stopPropagation();

                    //  button
                    if (!crsl.isStopped)
                    {
                        if (opts.auto.button)
                        {
                            opts.auto.button.addClass(cf_c('stopped', conf));
                        }
                    }

                    //  set stopped
                    crsl.isStopped = true;

                    if (opts.auto.play)
                    {
                        opts.auto.play = false;
                        $cfs.trigger(cf_e('pause', conf), imm);
                    }
                    return true;
                });


                //  finish event
                $cfs.bind(cf_e('finish', conf), function(e) {
                    e.stopPropagation();
                    if (crsl.isScrolling)
                    {
                        sc_stopScroll(scrl);
                    }
                    return true;
                });


                //  pause event
                $cfs.bind(cf_e('pause', conf), function(e, imm, res) {
                    e.stopPropagation();
                    tmrs = sc_clearTimers(tmrs);

                    //  immediately pause
                    if (imm && crsl.isScrolling)
                    {
                        scrl.isStopped = true;
                        var nst = getTime() - scrl.startTime;
                        scrl.duration -= nst;
                        if (scrl.pre)
                        {
                            scrl.pre.duration -= nst;
                        }
                        if (scrl.post)
                        {
                            scrl.post.duration -= nst;
                        }
                        sc_stopScroll(scrl, false);
                    }

                    //  update remaining pause-time
                    if (!crsl.isPaused && !crsl.isScrolling)
                    {
                        if (res)
                        {
                            tmrs.timePassed += getTime() - tmrs.startTime;
                        }
                    }

                    //  button
                    if (!crsl.isPaused)
                    {
                        if (opts.auto.button)
                        {
                            opts.auto.button.addClass(cf_c('paused', conf));
                        }
                    }

                    //  set paused
                    crsl.isPaused = true;

                    //  pause pause callback
                    if (opts.auto.onTimeoutPause)
                    {
                        var dur1 = opts.auto.timeoutDuration - tmrs.timePassed,
                            perc = 100 - Math.ceil( dur1 * 100 / opts.auto.timeoutDuration );

                        opts.auto.onTimeoutPause.call($tt0, perc, dur1);
                    }
                    return true;
                });


                //  play event
                $cfs.bind(cf_e('play', conf), function(e, dir, del, res) {
                    e.stopPropagation();
                    tmrs = sc_clearTimers(tmrs);

                    //  sort params
                    var v = [dir, del, res],
                        t = ['string', 'number', 'boolean'],
                        a = cf_sortParams(v, t);

                    dir = a[0];
                    del = a[1];
                    res = a[2];

                    if (dir != 'prev' && dir != 'next')
                    {
                        dir = crsl.direction;
                    }
                    if (!is_number(del))
                    {
                        del = 0;
                    }
                    if (!is_boolean(res))
                    {
                        res = false;
                    }

                    //  stopped?
                    if (res)
                    {
                        crsl.isStopped = false;
                        opts.auto.play = true;
                    }
                    if (!opts.auto.play)
                    {
                        e.stopImmediatePropagation();
                        return debug(conf, 'Carousel stopped: Not scrolling.');
                    }

                    //  button
                    if (crsl.isPaused)
                    {
                        if (opts.auto.button)
                        {
                            opts.auto.button.removeClass(cf_c('stopped', conf));
                            opts.auto.button.removeClass(cf_c('paused', conf));
                        }
                    }

                    //  set playing
                    crsl.isPaused = false;
                    tmrs.startTime = getTime();

                    //  timeout the scrolling
                    var dur1 = opts.auto.timeoutDuration + del;
                        dur2 = dur1 - tmrs.timePassed;
                        perc = 100 - Math.ceil(dur2 * 100 / dur1);

                    if (opts.auto.progress)
                    {
                        tmrs.progress = setInterval(function() {
                            var pasd = getTime() - tmrs.startTime + tmrs.timePassed,
                                perc = Math.ceil(pasd * 100 / dur1);
                            opts.auto.progress.updater.call(opts.auto.progress.bar[0], perc);
                        }, opts.auto.progress.interval);
                    }

                    tmrs.auto = setTimeout(function() {
                        if (opts.auto.progress)
                        {
                            opts.auto.progress.updater.call(opts.auto.progress.bar[0], 100);
                        }
                        if (opts.auto.onTimeoutEnd)
                        {
                            opts.auto.onTimeoutEnd.call($tt0, perc, dur2);
                        }
                        if (crsl.isScrolling)
                        {
                            $cfs.trigger(cf_e('play', conf), dir);
                        }
                        else
                        {
                            $cfs.trigger(cf_e(dir, conf), opts.auto);
                        }
                    }, dur2);

                    //  pause start callback
                    if (opts.auto.onTimeoutStart)
                    {
                        opts.auto.onTimeoutStart.call($tt0, perc, dur2);
                    }

                    return true;
                });


                //  resume event
                $cfs.bind(cf_e('resume', conf), function(e) {
                    e.stopPropagation();
                    if (scrl.isStopped)
                    {
                        scrl.isStopped = false;
                        crsl.isPaused = false;
                        crsl.isScrolling = true;
                        scrl.startTime = getTime();
                        sc_startScroll(scrl, conf);
                    }
                    else
                    {
                        $cfs.trigger(cf_e('play', conf));
                    }
                    return true;
                });


                //  prev + next events
                $cfs.bind(cf_e('prev', conf)+' '+cf_e('next', conf), function(e, obj, num, clb, que) {
                    e.stopPropagation();

                    //  stopped or hidden carousel, don't scroll, don't queue
                    if (crsl.isStopped || $cfs.is(':hidden'))
                    {
                        e.stopImmediatePropagation();
                        return debug(conf, 'Carousel stopped or hidden: Not scrolling.');
                    }

                    //  not enough items
                    var minimum = (is_number(opts.items.minimum)) ? opts.items.minimum : opts.items.visible + 1;
                    if (minimum > itms.total)
                    {
                        e.stopImmediatePropagation();
                        return debug(conf, 'Not enough items ('+itms.total+' total, '+minimum+' needed): Not scrolling.');
                    }

                    //  get config
                    var v = [obj, num, clb, que],
                        t = ['object', 'number/string', 'function', 'boolean'],
                        a = cf_sortParams(v, t);

                    obj = a[0];
                    num = a[1];
                    clb = a[2];
                    que = a[3];

                    var eType = e.type.slice(conf.events.prefix.length);

                    if (!is_object(obj))
                    {
                        obj = {};
                    }
                    if (is_function(clb))
                    {
                        obj.onAfter = clb;
                    }
                    if (is_boolean(que))
                    {
                        obj.queue = que;
                    }
                    obj = $.extend(true, {}, opts[eType], obj);

                    //  test conditions callback
                    if (obj.conditions && !obj.conditions.call($tt0, eType))
                    {
                        e.stopImmediatePropagation();
                        return debug(conf, 'Callback "conditions" returned false.');
                    }

                    if (!is_number(num))
                    {
                        if (opts.items.filter != '*')
                        {
                            num = 'visible';
                        }
                        else
                        {
                            var arr = [num, obj.items, opts[eType].items];
                            for (var a = 0, l = arr.length; a < l; a++)
                            {
                                if (is_number(arr[a]) || arr[a] == 'page' || arr[a] == 'visible') {
                                    num = arr[a];
                                    break;
                                }
                            }
                        }
                        switch(num) {
                            case 'page':
                                e.stopImmediatePropagation();
                                return $cfs.triggerHandler(cf_e(eType+'Page', conf), [obj, clb]);
                                break;

                            case 'visible':
                                if (!opts.items.visibleConf.variable && opts.items.filter == '*')
                                {
                                    num = opts.items.visible;
                                }
                                break;
                        }
                    }

                    //  resume animation, add current to queue
                    if (scrl.isStopped)
                    {
                        $cfs.trigger(cf_e('resume', conf));
                        $cfs.trigger(cf_e('queue', conf), [eType, [obj, num, clb]]);
                        e.stopImmediatePropagation();
                        return debug(conf, 'Carousel resumed scrolling.');
                    }

                    //  queue if scrolling
                    if (obj.duration > 0)
                    {
                        if (crsl.isScrolling)
                        {
                            if (obj.queue)
                            {
                                if (obj.queue == 'last')
                                {
                                    queu = [];
                                }
                                if (obj.queue != 'first' || queu.length == 0)
                                {
                                    $cfs.trigger(cf_e('queue', conf), [eType, [obj, num, clb]]);
                                }
                            }
                            e.stopImmediatePropagation();
                            return debug(conf, 'Carousel currently scrolling.');
                        }
                    }

                    tmrs.timePassed = 0;
                    $cfs.trigger(cf_e('slide_'+eType, conf), [obj, num]);

                    //  synchronise
                    if (opts.synchronise)
                    {
                        var s = opts.synchronise,
                            c = [obj, num];

                        for (var j = 0, l = s.length; j < l; j++) {
                            var d = eType;
                            if (!s[j][2])
                            {
                                d = (d == 'prev') ? 'next' : 'prev';
                            }
                            if (!s[j][1])
                            {
                                c[0] = s[j][0].triggerHandler('_cfs_triggerEvent', ['configuration', d]);
                            }
                            c[1] = num + s[j][3];
                            s[j][0].trigger('_cfs_triggerEvent', ['slide_'+d, c]);
                        }
                    }
                    return true;
                });


                //  prev event
                $cfs.bind(cf_e('slide_prev', conf), function(e, sO, nI) {
                    e.stopPropagation();
                    var a_itm = $cfs.children();

                    //  non-circular at start, scroll to end
                    if (!opts.circular)
                    {
                        if (itms.first == 0)
                        {
                            if (opts.infinite)
                            {
                                $cfs.trigger(cf_e('next', conf), itms.total-1);
                            }
                            return e.stopImmediatePropagation();
                        }
                    }

                    sz_resetMargin(a_itm, opts);

                    //  find number of items to scroll
                    if (!is_number(nI))
                    {
                        if (opts.items.visibleConf.variable)
                        {
                            nI = gn_getVisibleItemsPrev(a_itm, opts, itms.total-1);
                        }
                        else if (opts.items.filter != '*')
                        {
                            var xI = (is_number(sO.items)) ? sO.items : gn_getVisibleOrg($cfs, opts);
                            nI = gn_getScrollItemsPrevFilter(a_itm, opts, itms.total-1, xI);
                        }
                        else
                        {
                            nI = opts.items.visible;
                        }
                        nI = cf_getAdjust(nI, opts, sO.items, $tt0);
                    }

                    //  prevent non-circular from scrolling to far
                    if (!opts.circular)
                    {
                        if (itms.total - nI < itms.first)
                        {
                            nI = itms.total - itms.first;
                        }
                    }

                    //  set new number of visible items
                    opts.items.visibleConf.old = opts.items.visible;
                    if (opts.items.visibleConf.variable)
                    {
                        var vI = cf_getItemsAdjust(gn_getVisibleItemsNext(a_itm, opts, itms.total-nI), opts, opts.items.visibleConf.adjust, $tt0);
                        if (opts.items.visible+nI <= vI && nI < itms.total)
                        {
                            nI++;
                            vI = cf_getItemsAdjust(gn_getVisibleItemsNext(a_itm, opts, itms.total-nI), opts, opts.items.visibleConf.adjust, $tt0);
                        }
                        opts.items.visible = vI;
                    }
                    else if (opts.items.filter != '*')
                    {
                        var vI = gn_getVisibleItemsNextFilter(a_itm, opts, itms.total-nI);
                        opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
                    }

                    sz_resetMargin(a_itm, opts, true);

                    //  scroll 0, don't scroll
                    if (nI == 0)
                    {
                        e.stopImmediatePropagation();
                        return debug(conf, '0 items to scroll: Not scrolling.');
                    }
                    debug(conf, 'Scrolling '+nI+' items backward.');


                    //  save new config
                    itms.first += nI;
                    while (itms.first >= itms.total)
                    {
                        itms.first -= itms.total;
                    }

                    //  non-circular callback
                    if (!opts.circular)
                    {
                        if (itms.first == 0 && sO.onEnd)
                        {
                            sO.onEnd.call($tt0, 'prev');
                        }
                        if (!opts.infinite)
                        {
                            nv_enableNavi(opts, itms.first, conf);
                        }
                    }

                    //  rearrange items
                    $cfs.children().slice(itms.total-nI, itms.total).prependTo($cfs);
                    if (itms.total < opts.items.visible + nI)
                    {
                        $cfs.children().slice(0, (opts.items.visible+nI)-itms.total).clone(true).appendTo($cfs);
                    }

                    //  the needed items
                    var a_itm = $cfs.children(),
                        i_old = gi_getOldItemsPrev(a_itm, opts, nI),
                        i_new = gi_getNewItemsPrev(a_itm, opts),
                        i_cur_l = a_itm.eq(nI-1),
                        i_old_l = i_old.last(),
                        i_new_l = i_new.last();

                    sz_resetMargin(a_itm, opts);

                    var pL = 0,
                        pR = 0;

                    if (opts.align)
                    {
                        var p = cf_getAlignPadding(i_new, opts);
                        pL = p[0];
                        pR = p[1];
                    }
                    var oL = (pL < 0) ? opts.padding[opts.d[3]] : 0;

                    //  hide items for fx directscroll
                    var hiddenitems = false,
                        i_skp = $();
                    if (opts.items.visible < nI)
                    {
                        i_skp = a_itm.slice(opts.items.visibleConf.old, nI);
                        if (sO.fx == 'directscroll')
                        {
                            var orgW = opts.items[opts.d['width']];
                            hiddenitems = i_skp;
                            i_cur_l = i_new_l;
                            sc_hideHiddenItems(hiddenitems);
                            opts.items[opts.d['width']] = 'variable';
                        }
                    }

                    //  save new sizes
                    var $cf2 = false,
                        i_siz = ms_getTotalSize(a_itm.slice(0, nI), opts, 'width'),
                        w_siz = cf_mapWrapperSizes(ms_getSizes(i_new, opts, true), opts, !opts.usePadding),
                        i_siz_vis = 0,
                        a_cfs = {},
                        a_wsz = {},
                        a_cur = {},
                        a_old = {},
                        a_new = {},
                        a_lef = {},
                        a_lef_vis = {},
                        a_dur = sc_getDuration(sO, opts, nI, i_siz);

                    switch(sO.fx)
                    {
                        case 'cover':
                        case 'cover-fade':
                            i_siz_vis = ms_getTotalSize(a_itm.slice(0, opts.items.visible), opts, 'width');
                            break;
                    }

                    if (hiddenitems)
                    {
                        opts.items[opts.d['width']] = orgW;
                    }

                    sz_resetMargin(a_itm, opts, true);
                    if (pR >= 0)
                    {
                        sz_resetMargin(i_old_l, opts, opts.padding[opts.d[1]]);
                    }
                    if (pL >= 0)
                    {
                        sz_resetMargin(i_cur_l, opts, opts.padding[opts.d[3]]);
                    }

                    if (opts.align)
                    {
                        opts.padding[opts.d[1]] = pR;
                        opts.padding[opts.d[3]] = pL;
                    }

                    a_lef[opts.d['left']] = -(i_siz - oL);
                    a_lef_vis[opts.d['left']] = -(i_siz_vis - oL);
                    a_wsz[opts.d['left']] = w_siz[opts.d['width']];

                    //  scrolling functions
                    var _s_wrapper = function() {},
                        _a_wrapper = function() {},
                        _s_paddingold = function() {},
                        _a_paddingold = function() {},
                        _s_paddingnew = function() {},
                        _a_paddingnew = function() {},
                        _s_paddingcur = function() {},
                        _a_paddingcur = function() {},
                        _onafter = function() {},
                        _moveitems = function() {},
                        _position = function() {};

                    //  clone carousel
                    switch(sO.fx)
                    {
                        case 'crossfade':
                        case 'cover':
                        case 'cover-fade':
                        case 'uncover':
                        case 'uncover-fade':
                            $cf2 = $cfs.clone(true).appendTo($wrp);
                            break;
                    }
                    switch(sO.fx)
                    {
                        case 'crossfade':
                        case 'uncover':
                        case 'uncover-fade':
                            $cf2.children().slice(0, nI).remove();
                            $cf2.children().slice(opts.items.visibleConf.old).remove();
                            break;

                        case 'cover':
                        case 'cover-fade':
                            $cf2.children().slice(opts.items.visible).remove();
                            $cf2.css(a_lef_vis);
                            break;
                    }

                    $cfs.css(a_lef);

                    //  reset all scrolls
                    scrl = sc_setScroll(a_dur, sO.easing, conf);

                    //  animate / set carousel
                    a_cfs[opts.d['left']] = (opts.usePadding) ? opts.padding[opts.d[3]] : 0;

                    //  animate / set wrapper
                    if (opts[opts.d['width']] == 'variable' || opts[opts.d['height']] == 'variable')
                    {
                        _s_wrapper = function() {
                            $wrp.css(w_siz);
                        };
                        _a_wrapper = function() {
                            scrl.anims.push([$wrp, w_siz]);
                        };
                    }

                    //  animate / set items
                    if (opts.usePadding)
                    {
                        if (i_new_l.not(i_cur_l).length)
                        {
                            a_cur[opts.d['marginRight']] = i_cur_l.data('_cfs_origCssMargin');

                            if (pL < 0)
                            {
                                i_cur_l.css(a_cur);
                            }
                            else
                            {
                                _s_paddingcur = function() {
                                    i_cur_l.css(a_cur);
                                };
                                _a_paddingcur = function() {
                                    scrl.anims.push([i_cur_l, a_cur]);
                                };
                            }
                        }
                        switch(sO.fx)
                        {
                            case 'cover':
                            case 'cover-fade':
                                $cf2.children().eq(nI-1).css(a_cur);
                                break;
                        }

                        if (i_new_l.not(i_old_l).length)
                        {
                            a_old[opts.d['marginRight']] = i_old_l.data('_cfs_origCssMargin');
                            _s_paddingold = function() {
                                i_old_l.css(a_old);
                            };
                            _a_paddingold = function() {
                                scrl.anims.push([i_old_l, a_old]);
                            };
                        }

                        if (pR >= 0)
                        {
                            a_new[opts.d['marginRight']] = i_new_l.data('_cfs_origCssMargin') + opts.padding[opts.d[1]];
                            _s_paddingnew = function() {
                                i_new_l.css(a_new);
                            };
                            _a_paddingnew = function() {
                                scrl.anims.push([i_new_l, a_new]);
                            };
                        }
                    }

                    //  set position
                    _position = function() {
                        $cfs.css(a_cfs);
                    };


                    var overFill = opts.items.visible+nI-itms.total;

                    //  rearrange items
                    _moveitems = function() {
                        if (overFill > 0)
                        {
                            $cfs.children().slice(itms.total).remove();
                            i_old = $( $cfs.children().slice(itms.total-(opts.items.visible-overFill)).get().concat( $cfs.children().slice(0, overFill).get() ) );
                        }
                        sc_showHiddenItems(hiddenitems);

                        if (opts.usePadding)
                        {
                            var l_itm = $cfs.children().eq(opts.items.visible+nI-1);
                            l_itm.css(opts.d['marginRight'], l_itm.data('_cfs_origCssMargin'));
                        }
                    };


                    var cb_arguments = sc_mapCallbackArguments(i_old, i_skp, i_new, nI, 'prev', a_dur, w_siz);

                    //  fire onAfter callbacks
                    _onafter = function() {
                        sc_afterScroll($cfs, $cf2, sO);
                        crsl.isScrolling = false;
                        clbk.onAfter = sc_fireCallbacks($tt0, sO, 'onAfter', cb_arguments, clbk);
                        queu = sc_fireQueue($cfs, queu, conf);

                        if (!crsl.isPaused)
                        {
                            $cfs.trigger(cf_e('play', conf));
                        }
                    };

                    //  fire onBefore callback
                    crsl.isScrolling = true;
                    tmrs = sc_clearTimers(tmrs);
                    clbk.onBefore = sc_fireCallbacks($tt0, sO, 'onBefore', cb_arguments, clbk);

                    switch(sO.fx)
                    {
                        case 'none':
                            $cfs.css(a_cfs);
                            _s_wrapper();
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            _onafter();
                            break;

                        case 'fade':
                            scrl.anims.push([$cfs, { 'opacity': 0 }, function() {
                                _s_wrapper();
                                _s_paddingold();
                                _s_paddingnew();
                                _s_paddingcur();
                                _position();
                                _moveitems();
                                scrl = sc_setScroll(a_dur, sO.easing, conf);
                                scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                                sc_startScroll(scrl, conf);
                            }]);
                            break;

                        case 'crossfade':
                            $cfs.css({ 'opacity': 0 });
                            scrl.anims.push([$cf2, { 'opacity': 0 }]);
                            scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            break;

                        case 'cover':
                            scrl.anims.push([$cf2, a_cfs, function() {
                                _s_paddingold();
                                _s_paddingnew();
                                _s_paddingcur();
                                _position();
                                _moveitems();
                                _onafter();
                            }]);
                            _a_wrapper();
                            break;

                        case 'cover-fade':
                            scrl.anims.push([$cfs, { 'opacity': 0 }]);
                            scrl.anims.push([$cf2, a_cfs, function() {
                                _s_paddingold();
                                _s_paddingnew();
                                _s_paddingcur();
                                _position();
                                _moveitems();
                                _onafter();
                            }]);
                            _a_wrapper();
                            break;

                        case 'uncover':
                            scrl.anims.push([$cf2, a_wsz, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            break;

                        case 'uncover-fade':
                            $cfs.css({ 'opacity': 0 });
                            scrl.anims.push([$cfs, { 'opacity': 1 }]);
                            scrl.anims.push([$cf2, a_wsz, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            break;

                        default:
                            scrl.anims.push([$cfs, a_cfs, function() {
                                _moveitems();
                                _onafter();
                            }]);
                            _a_wrapper();
                            _a_paddingold();
                            _a_paddingnew();
                            _a_paddingcur();
                            break;
                    }

                    sc_startScroll(scrl, conf);
                    cf_setCookie(opts.cookie, $cfs, conf);

                    $cfs.trigger(cf_e('updatePageStatus', conf), [false, w_siz]);

                    return true;
                });


                //  next event
                $cfs.bind(cf_e('slide_next', conf), function(e, sO, nI) {
                    e.stopPropagation();
                    var a_itm = $cfs.children();

                    //  non-circular at end, scroll to start
                    if (!opts.circular)
                    {
                        if (itms.first == opts.items.visible)
                        {
                            if (opts.infinite)
                            {
                                $cfs.trigger(cf_e('prev', conf), itms.total-1);
                            }
                            return e.stopImmediatePropagation();
                        }
                    }

                    sz_resetMargin(a_itm, opts);

                    //  find number of items to scroll
                    if (!is_number(nI))
                    {
                        if (opts.items.filter != '*')
                        {
                            var xI = (is_number(sO.items)) ? sO.items : gn_getVisibleOrg($cfs, opts);
                            nI = gn_getScrollItemsNextFilter(a_itm, opts, 0, xI);
                        }
                        else
                        {
                            nI = opts.items.visible;
                        }
                        nI = cf_getAdjust(nI, opts, sO.items, $tt0);
                    }

                    var lastItemNr = (itms.first == 0) ? itms.total : itms.first;

                    //  prevent non-circular from scrolling to far
                    if (!opts.circular)
                    {
                        if (opts.items.visibleConf.variable)
                        {
                            var vI = gn_getVisibleItemsNext(a_itm, opts, nI),
                                xI = gn_getVisibleItemsPrev(a_itm, opts, lastItemNr-1);
                        }
                        else
                        {
                            var vI = opts.items.visible,
                                xI = opts.items.visible;
                        }

                        if (nI + vI > lastItemNr)
                        {
                            nI = lastItemNr - xI;
                        }
                    }

                    //  set new number of visible items
                    opts.items.visibleConf.old = opts.items.visible;
                    if (opts.items.visibleConf.variable)
                    {
                        var vI = cf_getItemsAdjust(gn_getVisibleItemsNextTestCircular(a_itm, opts, nI, lastItemNr), opts, opts.items.visibleConf.adjust, $tt0);
                        while (opts.items.visible-nI >= vI && nI < itms.total)
                        {
                            nI++;
                            vI = cf_getItemsAdjust(gn_getVisibleItemsNextTestCircular(a_itm, opts, nI, lastItemNr), opts, opts.items.visibleConf.adjust, $tt0);
                        }
                        opts.items.visible = vI;
                    }
                    else if (opts.items.filter != '*')
                    {
                        var vI = gn_getVisibleItemsNextFilter(a_itm, opts, nI);
                        opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
                    }

                    sz_resetMargin(a_itm, opts, true);

                    //  scroll 0, don't scroll
                    if (nI == 0)
                    {
                        e.stopImmediatePropagation();
                        return debug(conf, '0 items to scroll: Not scrolling.');
                    }
                    debug(conf, 'Scrolling '+nI+' items forward.');


                    //  save new config
                    itms.first -= nI;
                    while (itms.first < 0)
                    {
                        itms.first += itms.total;
                    }

                    //  non-circular callback
                    if (!opts.circular)
                    {
                        if (itms.first == opts.items.visible && sO.onEnd)
                        {
                            sO.onEnd.call($tt0, 'next');
                        }
                        if (!opts.infinite)
                        {
                            nv_enableNavi(opts, itms.first, conf);
                        }
                    }

                    //  rearrange items
                    if (itms.total < opts.items.visible+nI)
                    {
                        $cfs.children().slice(0, (opts.items.visible+nI)-itms.total).clone(true).appendTo($cfs);
                    }

                    //  the needed items
                    var a_itm = $cfs.children(),
                        i_old = gi_getOldItemsNext(a_itm, opts),
                        i_new = gi_getNewItemsNext(a_itm, opts, nI),
                        i_cur_l = a_itm.eq(nI-1),
                        i_old_l = i_old.last(),
                        i_new_l = i_new.last();

                    sz_resetMargin(a_itm, opts);

                    var pL = 0,
                        pR = 0;

                    if (opts.align)
                    {
                        var p = cf_getAlignPadding(i_new, opts);
                        pL = p[0];
                        pR = p[1];
                    }

                    //  hide items for fx directscroll
                    var hiddenitems = false,
                        i_skp = $();
                    if (opts.items.visibleConf.old < nI)
                    {
                        i_skp = a_itm.slice(opts.items.visibleConf.old, nI);
                        if (sO.fx == 'directscroll')
                        {
                            var orgW = opts.items[opts.d['width']];
                            hiddenitems = i_skp;
                            i_cur_l = i_old_l;
                            sc_hideHiddenItems(hiddenitems);
                            opts.items[opts.d['width']] = 'variable';
                        }
                    }

                    //  save new sizes
                    var $cf2 = false,
                        i_siz = ms_getTotalSize(a_itm.slice(0, nI), opts, 'width'),
                        w_siz = cf_mapWrapperSizes(ms_getSizes(i_new, opts, true), opts, !opts.usePadding),
                        i_siz_vis = 0,
                        a_cfs = {},
                        a_cfs_vis = {},
                        a_cur = {},
                        a_old = {},
                        a_lef = {},
                        a_dur = sc_getDuration(sO, opts, nI, i_siz);

                    switch(sO.fx)
                    {
                        case 'uncover':
                        case 'uncover-fade':
                            i_siz_vis = ms_getTotalSize(a_itm.slice(0, opts.items.visibleConf.old), opts, 'width');
                            break;
                    }

                    if (hiddenitems)
                    {
                        opts.items[opts.d['width']] = orgW;
                    }

                    if (opts.align)
                    {
                        if (opts.padding[opts.d[1]] < 0)
                        {
                            opts.padding[opts.d[1]] = 0;
                        }
                    }
                    sz_resetMargin(a_itm, opts, true);
                    sz_resetMargin(i_old_l, opts, opts.padding[opts.d[1]]);

                    if (opts.align)
                    {
                        opts.padding[opts.d[1]] = pR;
                        opts.padding[opts.d[3]] = pL;
                    }

                    a_lef[opts.d['left']] = (opts.usePadding) ? opts.padding[opts.d[3]] : 0;

                    //  scrolling functions
                    var _s_wrapper = function() {},
                        _a_wrapper = function() {},
                        _s_paddingold = function() {},
                        _a_paddingold = function() {},
                        _s_paddingcur = function() {},
                        _a_paddingcur = function() {},
                        _onafter = function() {},
                        _moveitems = function() {},
                        _position = function() {};

                    //  clone carousel
                    switch(sO.fx)
                    {
                        case 'crossfade':
                        case 'cover':
                        case 'cover-fade':
                        case 'uncover':
                        case 'uncover-fade':
                            $cf2 = $cfs.clone(true).appendTo($wrp);
                            $cf2.children().slice(opts.items.visibleConf.old).remove();
                            break;
                    }
                    switch(sO.fx)
                    {
                        case 'crossfade':
                        case 'cover':
                        case 'cover-fade':
                            $cfs.css('zIndex', 1);
                            $cf2.css('zIndex', 0);
                            break;
                    }

                    //  reset all scrolls
                    scrl = sc_setScroll(a_dur, sO.easing, conf);

                    //  animate / set carousel
                    a_cfs[opts.d['left']] = -i_siz;
                    a_cfs_vis[opts.d['left']] = -i_siz_vis;

                    if (pL < 0)
                    {
                        a_cfs[opts.d['left']] += pL;
                    }

                    //  animate / set wrapper
                    if (opts[opts.d['width']] == 'variable' || opts[opts.d['height']] == 'variable')
                    {
                        _s_wrapper = function() {
                            $wrp.css(w_siz);
                        };
                        _a_wrapper = function() {
                            scrl.anims.push([$wrp, w_siz]);
                        };
                    }

                    //  animate / set items
                    if (opts.usePadding)
                    {
                        var i_new_l_m = i_new_l.data('_cfs_origCssMargin');

                        if (pR >= 0)
                        {
                            i_new_l_m += opts.padding[opts.d[1]];
                        }
                        i_new_l.css(opts.d['marginRight'], i_new_l_m);

                        if (i_cur_l.not(i_old_l).length)
                        {
                            a_old[opts.d['marginRight']] = i_old_l.data('_cfs_origCssMargin');
                        }
                        _s_paddingold = function() {
                            i_old_l.css(a_old);
                        };
                        _a_paddingold = function() {
                            scrl.anims.push([i_old_l, a_old]);
                        };

                        var i_cur_l_m = i_cur_l.data('_cfs_origCssMargin');
                        if (pL > 0)
                        {
                            i_cur_l_m += opts.padding[opts.d[3]];
                        }

                        a_cur[opts.d['marginRight']] = i_cur_l_m;

                        _s_paddingcur = function() {
                            i_cur_l.css(a_cur);
                        };
                        _a_paddingcur = function() {
                            scrl.anims.push([i_cur_l, a_cur]);
                        };
                    }

                    //  set position
                    _position = function() {
                        $cfs.css(a_lef);
                    };


                    var overFill = opts.items.visible+nI-itms.total;

                    //  rearrange items
                    _moveitems = function() {
                        if (overFill > 0)
                        {
                            $cfs.children().slice(itms.total).remove();
                        }
                        var l_itm = $cfs.children().slice(0, nI).appendTo($cfs).last();
                        if (overFill > 0)
                        {
                            i_new = gi_getCurrentItems(a_itm, opts);
                        }
                        sc_showHiddenItems(hiddenitems);

                        if (opts.usePadding)
                        {
                            if (itms.total < opts.items.visible+nI) {
                                var i_cur_l = $cfs.children().eq(opts.items.visible-1);
                                i_cur_l.css(opts.d['marginRight'], i_cur_l.data('_cfs_origCssMargin') + opts.padding[opts.d[1]]);
                            }
                            l_itm.css(opts.d['marginRight'], l_itm.data('_cfs_origCssMargin'));
                        }
                    };


                    var cb_arguments = sc_mapCallbackArguments(i_old, i_skp, i_new, nI, 'next', a_dur, w_siz);

                    //  fire onAfter callbacks
                    _onafter = function() {
                        $cfs.css('zIndex', $cfs.data('_cfs_origCssZindex'));
                        sc_afterScroll($cfs, $cf2, sO);
                        crsl.isScrolling = false;
                        clbk.onAfter = sc_fireCallbacks($tt0, sO, 'onAfter', cb_arguments, clbk);
                        queu = sc_fireQueue($cfs, queu, conf);
                        
                        if (!crsl.isPaused)
                        {
                            $cfs.trigger(cf_e('play', conf));
                        }
                    };

                    //  fire onBefore callbacks
                    crsl.isScrolling = true;
                    tmrs = sc_clearTimers(tmrs);
                    clbk.onBefore = sc_fireCallbacks($tt0, sO, 'onBefore', cb_arguments, clbk);

                    switch(sO.fx)
                    {
                        case 'none':
                            $cfs.css(a_cfs);
                            _s_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            _onafter();
                            break;

                        case 'fade':
                            scrl.anims.push([$cfs, { 'opacity': 0 }, function() {
                                _s_wrapper();
                                _s_paddingold();
                                _s_paddingcur();
                                _position();
                                _moveitems();
                                scrl = sc_setScroll(a_dur, sO.easing, conf);
                                scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                                sc_startScroll(scrl, conf);
                            }]);
                            break;

                        case 'crossfade':
                            $cfs.css({ 'opacity': 0 });
                            scrl.anims.push([$cf2, { 'opacity': 0 }]);
                            scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            break;

                        case 'cover':
                            $cfs.css(opts.d['left'], $wrp[opts.d['width']]());
                            scrl.anims.push([$cfs, a_lef, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _moveitems();
                            break;

                        case 'cover-fade':
                            $cfs.css(opts.d['left'], $wrp[opts.d['width']]());
                            scrl.anims.push([$cf2, { 'opacity': 0 }]);
                            scrl.anims.push([$cfs, a_lef, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _moveitems();
                            break;

                        case 'uncover':
                            scrl.anims.push([$cf2, a_cfs_vis, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            break;

                        case 'uncover-fade':
                            $cfs.css({ 'opacity': 0 });
                            scrl.anims.push([$cfs, { 'opacity': 1 }]);
                            scrl.anims.push([$cf2, a_cfs_vis, _onafter]);
                            _a_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            break;

                        default:
                            scrl.anims.push([$cfs, a_cfs, function() {
                                _position();
                                _moveitems();
                                _onafter();
                            }]);
                            _a_wrapper();
                            _a_paddingold();
                            _a_paddingcur();
                            break;
                    }

                    sc_startScroll(scrl, conf);
                    cf_setCookie(opts.cookie, $cfs, conf);

                    $cfs.trigger(cf_e('updatePageStatus', conf), [false, w_siz]);

                    return true;
                });


                //  slideTo event
                $cfs.bind(cf_e('slideTo', conf), function(e, num, dev, org, obj, dir, clb) {
                    e.stopPropagation();

                    var v = [num, dev, org, obj, dir, clb],
                        t = ['string/number/object', 'number', 'boolean', 'object', 'string', 'function'],
                        a = cf_sortParams(v, t);

                    obj = a[3];
                    dir = a[4];
                    clb = a[5];

                    num = gn_getItemIndex(a[0], a[1], a[2], itms, $cfs);

                    if (num == 0)
                    {
                        return false;
                    }
                    if (!is_object(obj))
                    {
                        obj = false;
                    }

                    if (dir != 'prev' && dir != 'next')
                    {
                        if (opts.circular)
                        {
                            dir = (num <= itms.total / 2) ? 'next' : 'prev';
                        }
                        else
                        {
                            dir = (itms.first == 0 || itms.first > num) ? 'next' : 'prev';
                        }
                    }

                    if (dir == 'prev')
                    {
                        num = itms.total-num;
                    }
                    $cfs.trigger(cf_e(dir, conf), [obj, num, clb]);

                    return true;
                });


                //  prevPage event
                $cfs.bind(cf_e('prevPage', conf), function(e, obj, clb) {
                    e.stopPropagation();
                    var cur = $cfs.triggerHandler(cf_e('currentPage', conf));
                    return $cfs.triggerHandler(cf_e('slideToPage', conf), [cur-1, obj, 'prev', clb]);
                });


                //  nextPage event
                $cfs.bind(cf_e('nextPage', conf), function(e, obj, clb) {
                    e.stopPropagation();
                    var cur = $cfs.triggerHandler(cf_e('currentPage', conf));
                    return $cfs.triggerHandler(cf_e('slideToPage', conf), [cur+1, obj, 'next', clb]);
                });


                //  slideToPage event
                $cfs.bind(cf_e('slideToPage', conf), function(e, pag, obj, dir, clb) {
                    e.stopPropagation();
                    if (!is_number(pag))
                    {
                        pag = $cfs.triggerHandler(cf_e('currentPage', conf));
                    }
                    var ipp = opts.pagination.items || opts.items.visible,
                        max = Math.ceil(itms.total / ipp)-1;

                    if (pag < 0)
                    {
                        pag = max;
                    }
                    if (pag > max)
                    {
                        pag = 0;
                    }
                    return $cfs.triggerHandler(cf_e('slideTo', conf), [pag*ipp, 0, true, obj, dir, clb]);
                });

                //  jumpToStart event
                $cfs.bind(cf_e('jumpToStart', conf), function(e, s) {
                    e.stopPropagation();
                    if (s)
                    {
                        s = gn_getItemIndex(s, 0, true, itms, $cfs);
                    }
                    else
                    {
                        s = 0;
                    }

                    s += itms.first;
                    if (s != 0)
                    {
                        if (itms.total > 0)
                        {
                            while (s > itms.total)
                            {
                                s -= itms.total;
                            }
                        }
                        $cfs.prepend($cfs.children().slice(s, itms.total));
                    }
                    return true;
                });


                //  synchronise event
                $cfs.bind(cf_e('synchronise', conf), function(e, s) {
                    e.stopPropagation();
                    if (s)
                    {
                        s = cf_getSynchArr(s);
                    }
                    else if (opts.synchronise)
                    {
                        s = opts.synchronise;
                    }
                    else
                    {
                        return debug(conf, 'No carousel to synchronise.');
                    }

                    var n = $cfs.triggerHandler(cf_e('currentPosition', conf)),
                        x = true;

                    for (var j = 0, l = s.length; j < l; j++)
                    {
                        if (!s[j][0].triggerHandler(cf_e('slideTo', conf), [n, s[j][3], true]))
                        {
                            x = false;
                        }
                    }
                    return x;
                });


                //  queue event
                $cfs.bind(cf_e('queue', conf), function(e, dir, opt) {
                    e.stopPropagation();
                    if (is_function(dir))
                    {
                        dir.call($tt0, queu);
                    }
                    else if (is_array(dir))
                    {
                        queu = dir;
                    }
                    else if (!is_undefined(dir))
                    {
                        queu.push([dir, opt]);
                    }
                    return queu;
                });


                //  insertItem event
                $cfs.bind(cf_e('insertItem', conf), function(e, itm, num, org, dev) {
                    e.stopPropagation();

                    var v = [itm, num, org, dev],
                        t = ['string/object', 'string/number/object', 'boolean', 'number'],
                        a = cf_sortParams(v, t);

                    itm = a[0];
                    num = a[1];
                    org = a[2];
                    dev = a[3];

                    if (is_object(itm) && !is_jquery(itm))
                    { 
                        itm = $(itm);
                    }
                    else if (is_string(itm))
                    {
                        itm = $(itm);
                    }
                    if (!is_jquery(itm) || itm.length == 0)
                    {
                        return debug(conf, 'Not a valid object.');
                    }

                    if (is_undefined(num))
                    {
                        num = 'end';
                    }

                    sz_storeMargin(itm, opts);
                    sz_storeOrigCss(itm);

                    var orgNum = num,
                        before = 'before';

                    if (num == 'end')
                    {
                        if (org)
                        {
                            if (itms.first == 0)
                            {
                                num = itms.total-1;
                                before = 'after';
                            }
                            else
                            {
                                num = itms.first;
                                itms.first += itm.length;
                            }
                            if (num < 0)
                            {
                                num = 0;
                            }
                        }
                        else
                        {
                            num = itms.total-1;
                            before = 'after';
                        }
                    }
                    else
                    {
                        num = gn_getItemIndex(num, dev, org, itms, $cfs);
                    }

                    var $cit = $cfs.children().eq(num);
                    if ($cit.length)
                    {
                        $cit[before](itm);
                    }
                    else
                    {
                        debug(conf, 'Correct insert-position not found! Appending item to the end.');
                        $cfs.append(itm);
                    }

                    if (orgNum != 'end' && !org)
                    {
                        if (num < itms.first)
                        {
                            itms.first += itm.length;
                        }
                    }
                    itms.total = $cfs.children().length;
                    if (itms.first >= itms.total)
                    {
                        itms.first -= itms.total;
                    }

                    $cfs.trigger(cf_e('updateSizes', conf));
                    $cfs.trigger(cf_e('linkAnchors', conf));

                    return true;
                });


                //  removeItem event
                $cfs.bind(cf_e('removeItem', conf), function(e, num, org, dev) {
                    e.stopPropagation();

                    var v = [num, org, dev],
                        t = ['string/number/object', 'boolean', 'number'],
                        a = cf_sortParams(v, t);

                    num = a[0];
                    org = a[1];
                    dev = a[2];

                    var removed = false;

                    if (num instanceof $ && num.length > 1)
                    {
                        $removed = $();
                        num.each(function(i, el) {
                            var $rem = $cfs.trigger(cf_e('removeItem', conf), [$(this), org, dev]);
                            if ( $rem ) 
                            {
                                $removed = $removed.add($rem);
                            }
                        });
                        return $removed;
                    }

                    if (is_undefined(num) || num == 'end')
                    {
                        $removed = $cfs.children().last();
                    }
                    else
                    {
                        num = gn_getItemIndex(num, dev, org, itms, $cfs);
                        var $removed = $cfs.children().eq(num);
                        if ( $removed.length )
                        {
                            if (num < itms.first)
                            {
                                itms.first -= $removed.length;
                            }
                        }
                    }
                    if ( $removed && $removed.length )
                    {
                        $removed.detach();
                        itms.total = $cfs.children().length;
                        $cfs.trigger(cf_e('updateSizes', conf));
                    }

                    return $removed;
                });


                //  onBefore and onAfter event
                $cfs.bind(cf_e('onBefore', conf)+' '+cf_e('onAfter', conf), function(e, fn) {
                    e.stopPropagation();
                    var eType = e.type.slice(conf.events.prefix.length);
                    if (is_array(fn))
                    {
                        clbk[eType] = fn;
                    }
                    if (is_function(fn))
                    {
                        clbk[eType].push(fn);
                    }
                    return clbk[eType];
                });


                //  currentPosition event
                $cfs.bind(cf_e('currentPosition', conf), function(e, fn) {
                    e.stopPropagation();
                    if (itms.first == 0)
                    {
                        var val = 0;
                    }
                    else
                    {
                        var val = itms.total - itms.first;
                    }
                    if (is_function(fn))
                    {
                        fn.call($tt0, val);
                    }
                    return val;
                });


                //  currentPage event
                $cfs.bind(cf_e('currentPage', conf), function(e, fn) {
                    e.stopPropagation();
                    var ipp = opts.pagination.items || opts.items.visible,
                        max = Math.ceil(itms.total/ipp-1),
                        nr;
                    if (itms.first == 0)
                    {
                        nr = 0;
                    }
                    else if (itms.first < itms.total % ipp)
                    {
                        nr = 0;
                    }
                    else if (itms.first == ipp && !opts.circular)
                    {
                        nr = max;
                    }
                    else 
                    {
                         nr = Math.round((itms.total-itms.first)/ipp);
                    }
                    if (nr < 0)
                    {
                        nr = 0;
                    }
                    if (nr > max)
                    {
                        nr = max;
                    }
                    if (is_function(fn))
                    {
                        fn.call($tt0, nr);
                    }
                    return nr;
                });


                //  currentVisible event
                $cfs.bind(cf_e('currentVisible', conf), function(e, fn) {
                    e.stopPropagation();
                    var $i = gi_getCurrentItems($cfs.children(), opts);
                    if (is_function(fn))
                    {
                        fn.call($tt0, $i);
                    }
                    return $i;
                });


                //  slice event
                $cfs.bind(cf_e('slice', conf), function(e, f, l, fn) {
                    e.stopPropagation();

                    if (itms.total == 0)
                    {
                        return false;
                    }

                    var v = [f, l, fn],
                        t = ['number', 'number', 'function'],
                        a = cf_sortParams(v, t);

                    f = (is_number(a[0])) ? a[0] : 0;
                    l = (is_number(a[1])) ? a[1] : itms.total;
                    fn = a[2];

                    f += itms.first;
                    l += itms.first;

                    if (items.total > 0)
                    {
                        while (f > itms.total)
                        {
                            f -= itms.total;
                        }
                        while (l > itms.total)
                        {
                            l -= itms.total;
                        }
                        while (f < 0)
                        {
                            f += itms.total;
                        }
                        while (l < 0)
                        {
                            l += itms.total;
                        }
                    }
                    var $iA = $cfs.children(),
                        $i;

                    if (l > f)
                    {
                        $i = $iA.slice(f, l);
                    }
                    else
                    {
                        $i = $( $iA.slice(f, itms.total).get().concat( $iA.slice(0, l).get() ) );
                    }

                    if (is_function(fn))
                    {
                        fn.call($tt0, $i);
                    }
                    return $i;
                });


                //  isPaused, isStopped and isScrolling events
                $cfs.bind(cf_e('isPaused', conf)+' '+cf_e('isStopped', conf)+' '+cf_e('isScrolling', conf), function(e, fn) {
                    e.stopPropagation();
                    var eType = e.type.slice(conf.events.prefix.length),
                        value = crsl[eType];
                    if (is_function(fn))
                    {
                        fn.call($tt0, value);
                    }
                    return value;
                });


                //  configuration event
                $cfs.bind(cf_e('configuration', conf), function(e, a, b, c) {
                    e.stopPropagation();
                    var reInit = false;

                    //  return entire configuration-object
                    if (is_function(a))
                    {
                        a.call($tt0, opts);
                    }
                    //  set multiple options via object
                    else if (is_object(a))
                    {
                        opts_orig = $.extend(true, {}, opts_orig, a);
                        if (b !== false) reInit = true;
                        else opts = $.extend(true, {}, opts, a);

                    }
                    else if (!is_undefined(a))
                    {

                        //  callback function for specific option
                        if (is_function(b))
                        {
                            var val = eval('opts.'+a);
                            if (is_undefined(val))
                            {
                                val = '';
                            }
                            b.call($tt0, val);
                        }
                        //  set individual option
                        else if (!is_undefined(b))
                        {
                            if (typeof c !== 'boolean') c = true;
                            eval('opts_orig.'+a+' = b');
                            if (c !== false) reInit = true;
                            else eval('opts.'+a+' = b');
                        }
                        //  return value for specific option
                        else
                        {
                            return eval('opts.'+a);
                        }
                    }
                    if (reInit)
                    {
                        sz_resetMargin($cfs.children(), opts);
                        FN._init(opts_orig);
                        FN._bind_buttons();
                        var sz = sz_setSizes($cfs, opts);
                        $cfs.trigger(cf_e('updatePageStatus', conf), [true, sz]);
                    }
                    return opts;
                });


                //  linkAnchors event
                $cfs.bind(cf_e('linkAnchors', conf), function(e, $con, sel) {
                    e.stopPropagation();

                    if (is_undefined($con))
                    {
                        $con = $('body');
                    }
                    else if (is_string($con))
                    {
                        $con = $($con);
                    }
                    if (!is_jquery($con) || $con.length == 0)
                    {
                        return debug(conf, 'Not a valid object.');
                    }
                    if (!is_string(sel))
                    {
                        sel = 'a.caroufredsel';
                    }

                    $con.find(sel).each(function() {
                        var h = this.hash || '';
                        if (h.length > 0 && $cfs.children().index($(h)) != -1)
                        {
                            $(this).unbind('click').click(function(e) {
                                e.preventDefault();
                                $cfs.trigger(cf_e('slideTo', conf), h);
                            });
                        }
                    });
                    return true;
                });


                //  updatePageStatus event
                $cfs.bind(cf_e('updatePageStatus', conf), function(e, build, sizes) {
                    e.stopPropagation();
                    if (!opts.pagination.container)
                    {
                        return;
                    }

                    var ipp = opts.pagination.items || opts.items.visible,
                        pgs = Math.ceil(itms.total/ipp);

                    if (build)
                    {
                        if (opts.pagination.anchorBuilder)
                        {
                            opts.pagination.container.children().remove();
                            opts.pagination.container.each(function() {
                                for (var a = 0; a < pgs; a++)
                                {
                                    var i = $cfs.children().eq( gn_getItemIndex(a*ipp, 0, true, itms, $cfs) );
                                    $(this).append(opts.pagination.anchorBuilder.call(i[0], a+1));
                                }
                            });
                        }
                        opts.pagination.container.each(function() {
                            $(this).children().unbind(opts.pagination.event).each(function(a) {
                                $(this).bind(opts.pagination.event, function(e) {
                                    e.preventDefault();
                                    $cfs.trigger(cf_e('slideTo', conf), [a*ipp, -opts.pagination.deviation, true, opts.pagination]);
                                });
                            });
                        });
                    }

                    var selected = $cfs.triggerHandler(cf_e('currentPage', conf)) + opts.pagination.deviation;
                    if (selected >= pgs)
                    {
                        selected = 0;
                    }
                    if (selected < 0)
                    {
                        selected = pgs-1;
                    }
                    opts.pagination.container.each(function() {
                        $(this).children().removeClass(cf_c('selected', conf)).eq(selected).addClass(cf_c('selected', conf));
                    });
                    return true;
                });


                //  updateSizes event
                $cfs.bind(cf_e('updateSizes', conf), function(e) {
                    var vI = opts.items.visible,
                        a_itm = $cfs.children(),
                        avail_primary = ms_getParentSize($wrp, opts, 'width');

                    itms.total = a_itm.length;

                    if (crsl.primarySizePercentage)
                    {
                        opts.maxDimension = avail_primary;
                        opts[opts.d['width']] = ms_getPercentage(avail_primary, crsl.primarySizePercentage);
                    }
                    else
                    {
                        opts.maxDimension = ms_getMaxDimension(opts, avail_primary);
                    }

                    if (opts.responsive)
                    {
                        opts.items.width = opts.items.sizesConf.width;
                        opts.items.height = opts.items.sizesConf.height;
                        opts = in_getResponsiveValues(opts, a_itm, avail_primary);
                        vI = opts.items.visible;
                        sz_setResponsiveSizes(opts, a_itm);
                    }
                    else if (opts.items.visibleConf.variable)
                    {
                        vI = gn_getVisibleItemsNext(a_itm, opts, 0);
                    }
                    else if (opts.items.filter != '*')
                    {
                        vI = gn_getVisibleItemsNextFilter(a_itm, opts, 0);
                    }

                    if (!opts.circular && itms.first != 0 && vI > itms.first) {
                        if (opts.items.visibleConf.variable)
                        {
                            var nI = gn_getVisibleItemsPrev(a_itm, opts, itms.first) - itms.first;
                        }
                        else if (opts.items.filter != '*')
                        {
                            var nI = gn_getVisibleItemsPrevFilter(a_itm, opts, itms.first) - itms.first;
                        }
                        else
                        {
                            var nI = opts.items.visible - itms.first;
                        }
                        debug(conf, 'Preventing non-circular: sliding '+nI+' items backward.');
                        $cfs.trigger(cf_e('prev', conf), nI);
                    }

                    opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
                    opts.items.visibleConf.old = opts.items.visible;
                    opts = in_getAlignPadding(opts, a_itm);

                    var sz = sz_setSizes($cfs, opts);
                    $cfs.trigger(cf_e('updatePageStatus', conf), [true, sz]);
                    nv_showNavi(opts, itms.total, conf);
                    nv_enableNavi(opts, itms.first, conf);

                    return sz;
                });


                //  destroy event
                $cfs.bind(cf_e('destroy', conf), function(e, orgOrder) {
                    e.stopPropagation();
                    tmrs = sc_clearTimers(tmrs);

                    $cfs.data('_cfs_isCarousel', false);
                    $cfs.trigger(cf_e('finish', conf));
                    if (orgOrder)
                    {
                        $cfs.trigger(cf_e('jumpToStart', conf));
                    }
                    sz_restoreOrigCss($cfs.children());
                    sz_restoreOrigCss($cfs);
                    FN._unbind_events();
                    FN._unbind_buttons();
                    if (conf.wrapper == 'parent')
                    {
                        sz_restoreOrigCss($wrp);
                    }
                    else
                    {
                        $wrp.replaceWith($cfs);
                    }

                    return true;
                });


                //  debug event
                $cfs.bind(cf_e('debug', conf), function(e) {
                    debug(conf, 'Carousel width: ' + opts.width);
                    debug(conf, 'Carousel height: ' + opts.height);
                    debug(conf, 'Item widths: ' + opts.items.width);
                    debug(conf, 'Item heights: ' + opts.items.height);
                    debug(conf, 'Number of items visible: ' + opts.items.visible);
                    if (opts.auto.play)
                    {
                        debug(conf, 'Number of items scrolled automatically: ' + opts.auto.items);
                    }
                    if (opts.prev.button)
                    {
                        debug(conf, 'Number of items scrolled backward: ' + opts.prev.items);
                    }
                    if (opts.next.button)
                    {
                        debug(conf, 'Number of items scrolled forward: ' + opts.next.items);
                    }
                    return conf.debug;
                });


                //  triggerEvent, making prefixed and namespaced events accessible from outside
                $cfs.bind('_cfs_triggerEvent', function(e, n, o) {
                    e.stopPropagation();
                    return $cfs.triggerHandler(cf_e(n, conf), o);
                });
            };  //  /bind_events


            FN._unbind_events = function() {
                $cfs.unbind(cf_e('', conf));
                $cfs.unbind(cf_e('', conf, false));
                $cfs.unbind('_cfs_triggerEvent');
            };  //  /unbind_events


            FN._bind_buttons = function() {
                FN._unbind_buttons();
                nv_showNavi(opts, itms.total, conf);
                nv_enableNavi(opts, itms.first, conf);

                if (opts.auto.pauseOnHover)
                {
                    var pC = bt_pauseOnHoverConfig(opts.auto.pauseOnHover);
                    $wrp.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC);  })
                        .bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));     });
                }

                //  play button
                if (opts.auto.button)
                {
                    opts.auto.button.bind(cf_e(opts.auto.event, conf, false), function(e) {
                        e.preventDefault();
                        var ev = false,
                            pC = null;

                        if (crsl.isPaused)
                        {
                            ev = 'play';
                        }
                        else if (opts.auto.pauseOnEvent)
                        {
                            ev = 'pause';
                            pC = bt_pauseOnHoverConfig(opts.auto.pauseOnEvent);
                        }
                        if (ev)
                        {
                            $cfs.trigger(cf_e(ev, conf), pC);
                        }
                    });
                }

                //  prev button
                if (opts.prev.button)
                {
                    opts.prev.button.bind(cf_e(opts.prev.event, conf, false), function(e) {
                        e.preventDefault();
                        $cfs.trigger(cf_e('prev', conf));
                    });
                    if (opts.prev.pauseOnHover)
                    {
                        var pC = bt_pauseOnHoverConfig(opts.prev.pauseOnHover);
                        opts.prev.button.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC);  })
                                        .bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));     });
                    }
                }

                //  next butotn
                if (opts.next.button)
                {
                    opts.next.button.bind(cf_e(opts.next.event, conf, false), function(e) {
                        e.preventDefault();
                        $cfs.trigger(cf_e('next', conf));
                    });
                    if (opts.next.pauseOnHover)
                    {
                        var pC = bt_pauseOnHoverConfig(opts.next.pauseOnHover);
                        opts.next.button.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC);  })
                                        .bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));     });
                    }
                }

                //  pagination
                if (opts.pagination.container)
                {
                    if (opts.pagination.pauseOnHover)
                    {
                        var pC = bt_pauseOnHoverConfig(opts.pagination.pauseOnHover);
                        opts.pagination.container.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC); })
                                                 .bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));    });
                    }
                }

                //  prev/next keys
                if (opts.prev.key || opts.next.key)
                {
                    $(document).bind(cf_e('keyup', conf, false, true, true), function(e) {
                        var k = e.keyCode;
                        if (k == opts.next.key)
                        {
                            e.preventDefault();
                            $cfs.trigger(cf_e('next', conf));
                        }
                        if (k == opts.prev.key)
                        {
                            e.preventDefault();
                            $cfs.trigger(cf_e('prev', conf));
                        }
                    });
                }

                //  pagination keys
                if (opts.pagination.keys)
                {
                    $(document).bind(cf_e('keyup', conf, false, true, true), function(e) {
                        var k = e.keyCode;
                        if (k >= 49 && k < 58)
                        {
                            k = (k-49) * opts.items.visible;
                            if (k <= itms.total)
                            {
                                e.preventDefault();
                                $cfs.trigger(cf_e('slideTo', conf), [k, 0, true, opts.pagination]);
                            }
                        }
                    });
                }

                //  swipe
                if ($.fn.swipe)
                {
                    var isTouch = 'ontouchstart' in window;
                    if ((isTouch && opts.swipe.onTouch) || (!isTouch && opts.swipe.onMouse))
                    {
                        var scP = $.extend(true, {}, opts.prev, opts.swipe),
                            scN = $.extend(true, {}, opts.next, opts.swipe),
                            swP = function() { $cfs.trigger(cf_e('prev', conf), [scP]) },
                            swN = function() { $cfs.trigger(cf_e('next', conf), [scN]) };

                        switch (opts.direction)
                        {
                            case 'up':
                            case 'down':
                                opts.swipe.options.swipeUp = swN;
                                opts.swipe.options.swipeDown = swP;
                                break;
                            default:
                                opts.swipe.options.swipeLeft = swN;
                                opts.swipe.options.swipeRight = swP;
                        }
                        if (crsl.swipe)
                        {
                            $cfs.swipe('destroy');
                        }
                        $wrp.swipe(opts.swipe.options);
                        $wrp.css('cursor', 'move');
                        crsl.swipe = true;
                    }
                }

                //  mousewheel
                if ($.fn.mousewheel)
                {

                    if (opts.mousewheel)
                    {
                        var mcP = $.extend(true, {}, opts.prev, opts.mousewheel),
                            mcN = $.extend(true, {}, opts.next, opts.mousewheel);

                        if (crsl.mousewheel)
                        {
                            $wrp.unbind(cf_e('mousewheel', conf, false));
                        }
                        $wrp.bind(cf_e('mousewheel', conf, false), function(e, delta) { 
                            e.preventDefault();
                            if (delta > 0)
                            {
                                $cfs.trigger(cf_e('prev', conf), [mcP]);
                            }
                            else
                            {
                                $cfs.trigger(cf_e('next', conf), [mcN]);
                            }
                        });
                        crsl.mousewheel = true;
                    }
                }

                if (opts.auto.play)
                {
                    $cfs.trigger(cf_e('play', conf), opts.auto.delay);
                }

                if (crsl.upDateOnWindowResize)
                {
                    var resizeFn = function(e) {
                        $cfs.trigger(cf_e('finish', conf));
                        if (opts.auto.pauseOnResize && !crsl.isPaused)
                        {
                            $cfs.trigger(cf_e('play', conf));
                        }
                        sz_resetMargin($cfs.children(), opts);
                        $cfs.trigger(cf_e('updateSizes', conf));
                    };

                    var $w = $(window),
                        onResize = null;

                    if ($.debounce && conf.onWindowResize == 'debounce')
                    {
                        onResize = $.debounce(200, resizeFn);
                    }
                    else if ($.throttle && conf.onWindowResize == 'throttle')
                    {
                        onResize = $.throttle(300, resizeFn);
                    }
                    else
                    {
                        var _windowWidth = 0,
                            _windowHeight = 0;

                        onResize = function() {
                            var nw = $w.width(),
                                nh = $w.height();

                            if (nw != _windowWidth || nh != _windowHeight)
                            {
                                resizeFn();
                                _windowWidth = nw;
                                _windowHeight = nh;
                            }
                        };
                    }
                    $w.bind(cf_e('resize', conf, false, true, true), onResize);
                }
            };  //  /bind_buttons


            FN._unbind_buttons = function() {
                var ns1 = cf_e('', conf),
                    ns2 = cf_e('', conf, false);
                    ns3 = cf_e('', conf, false, true, true);

                $(document).unbind(ns3);
                $(window).unbind(ns3);
                $wrp.unbind(ns2);

                if (opts.auto.button)
                {
                    opts.auto.button.unbind(ns2);
                }
                if (opts.prev.button)
                {
                    opts.prev.button.unbind(ns2);
                }
                if (opts.next.button)
                {
                    opts.next.button.unbind(ns2);
                }
                if (opts.pagination.container)
                {
                    opts.pagination.container.unbind(ns2);
                    if (opts.pagination.anchorBuilder)
                    {
                        opts.pagination.container.children().remove();
                    }
                }
                if (crsl.swipe)
                {
                    $cfs.swipe('destroy');
                    $wrp.css('cursor', 'default');
                    crsl.swipe = false;
                }
                if (crsl.mousewheel)
                {
                    crsl.mousewheel = false;
                }

                nv_showNavi(opts, 'hide', conf);
                nv_enableNavi(opts, 'removeClass', conf);

            };  //  /unbind_buttons



            //  START

            if (is_boolean(configs))
            {
                configs = {
                    'debug': configs
                };
            }

            //  set vars
            var crsl = {
                    'direction'     : 'next',
                    'isPaused'      : true,
                    'isScrolling'   : false,
                    'isStopped'     : false,
                    'mousewheel'    : false,
                    'swipe'         : false
                },
                itms = {
                    'total'         : $cfs.children().length,
                    'first'         : 0
                },
                tmrs = {
                    'auto'          : null,
                    'progress'      : null,
                    'startTime'     : getTime(),
                    'timePassed'    : 0
                },
                scrl = {
                    'isStopped'     : false,
                    'duration'      : 0,
                    'startTime'     : 0,
                    'easing'        : '',
                    'anims'         : []
                },
                clbk = {
                    'onBefore'      : [],
                    'onAfter'       : []
                },
                queu = [],
                conf = $.extend(true, {}, $.fn.carouFredSel.configs, configs),
                opts = {},
                opts_orig = $.extend(true, {}, options),
                $wrp = (conf.wrapper == 'parent')
                    ? $cfs.parent()
                    : $cfs.wrap('<'+conf.wrapper.element+' class="'+conf.wrapper.classname+'" />').parent();


            conf.selector       = $cfs.selector;
            conf.serialNumber   = $.fn.carouFredSel.serialNumber++;

            conf.transition = (conf.transition && $.fn.transition) ? 'transition' : 'animate';

            //  create carousel
            FN._init(opts_orig, true, starting_position);
            FN._build();
            FN._bind_events();
            FN._bind_buttons();

            //  find item to start
            if (is_array(opts.items.start))
            {
                var start_arr = opts.items.start;
            }
            else
            {
                var start_arr = [];
                if (opts.items.start != 0)
                {
                    start_arr.push(opts.items.start);
                }
            }
            if (opts.cookie)
            {
                start_arr.unshift(parseInt(cf_getCookie(opts.cookie), 10));
            }

            if (start_arr.length > 0)
            {
                for (var a = 0, l = start_arr.length; a < l; a++)
                {
                    var s = start_arr[a];
                    if (s == 0)
                    {
                        continue;
                    }
                    if (s === true)
                    {
                        s = window.location.hash;
                        if (s.length < 1)
                        {
                            continue;
                        }
                    }
                    else if (s === 'random')
                    {
                        s = Math.floor(Math.random()*itms.total);
                    }
                    if ($cfs.triggerHandler(cf_e('slideTo', conf), [s, 0, true, { fx: 'none' }]))
                    {
                        break;
                    }
                }
            }
            var siz = sz_setSizes($cfs, opts),
                itm = gi_getCurrentItems($cfs.children(), opts);

            if (opts.onCreate)
            {
                opts.onCreate.call($tt0, {
                    'width': siz.width,
                    'height': siz.height,
                    'items': itm
                });
            }

            $cfs.trigger(cf_e('updatePageStatus', conf), [true, siz]);
            $cfs.trigger(cf_e('linkAnchors', conf));

            if (conf.debug)
            {
                $cfs.trigger(cf_e('debug', conf));
            }

            return $cfs;
        };



        //  GLOBAL PUBLIC

        $.fn.carouFredSel.serialNumber = 1;
        $.fn.carouFredSel.defaults = {
            'synchronise'   : false,
            'infinite'      : true,
            'circular'      : true,
            'responsive'    : false,
            'direction'     : 'left',
            'items'         : {
                'start'         : 0
            },
            'scroll'        : {
                'easing'        : 'swing',
                'duration'      : 500,
                'pauseOnHover'  : false,
                'event'         : 'click',
                'queue'         : false
            }
        };
        $.fn.carouFredSel.configs = {
            'debug'         : false,
            'transition'    : false,
            'onWindowResize': 'throttle',
            'events'        : {
                'prefix'        : '',
                'namespace'     : 'cfs'
            },
            'wrapper'       : {
                'element'       : 'div',
                'classname'     : 'caroufredsel_wrapper'
            },
            'classnames'    : {}
        };
        $.fn.carouFredSel.pageAnchorBuilder = function(nr) {
            return '<a href="#"><span>'+nr+'</span></a>';
        };
        $.fn.carouFredSel.progressbarUpdater = function(perc) {
            $(this).css('width', perc+'%');
        };

        $.fn.carouFredSel.cookie = {
            get: function(n) {
                n += '=';
                var ca = document.cookie.split(';');
                for (var a = 0, l = ca.length; a < l; a++)
                {
                    var c = ca[a];
                    while (c.charAt(0) == ' ')
                    {
                        c = c.slice(1);
                    }
                    if (c.indexOf(n) == 0)
                    {
                        return c.slice(n.length);
                    }
                }
                return 0;
            },
            set: function(n, v, d) {
                var e = "";
                if (d)
                {
                    var date = new Date();
                    date.setTime(date.getTime() + (d * 24 * 60 * 60 * 1000));
                    e = "; expires=" + date.toGMTString();
                }
                document.cookie = n + '=' + v + e + '; path=/';
            },
            remove: function(n) {
                $.fn.carouFredSel.cookie.set(n, "", -1);
            }
        };


        //  GLOBAL PRIVATE

        //  scrolling functions
        function sc_setScroll(d, e, c) {
            if (c.transition == 'transition')
            {
                if (e == 'swing')
                {
                    e = 'ease';
                }
            }
            return {
                anims: [],
                duration: d,
                orgDuration: d,
                easing: e,
                startTime: getTime()
            };
        }
        function sc_startScroll(s, c) {
            for (var a = 0, l = s.anims.length; a < l; a++)
            {
                var b = s.anims[a];
                if (!b)
                {
                    continue;
                }
                b[0][c.transition](b[1], s.duration, s.easing, b[2]);
            }
        }
        function sc_stopScroll(s, finish) {
            if (!is_boolean(finish))
            {
                finish = true;
            }
            if (is_object(s.pre))
            {
                sc_stopScroll(s.pre, finish);
            }
            for (var a = 0, l = s.anims.length; a < l; a++)
            {
                var b = s.anims[a];
                b[0].stop(true);
                if (finish)
                {
                    b[0].css(b[1]);
                    if (is_function(b[2]))
                    {
                        b[2]();
                    }
                }
            }
            if (is_object(s.post))
            {
                sc_stopScroll(s.post, finish);
            }
        }
        function sc_afterScroll( $c, $c2, o ) {
            if ($c2)
            {
                $c2.remove();
            }

            switch(o.fx) {
                case 'fade':
                case 'crossfade':
                case 'cover-fade':
                case 'uncover-fade':
                    $c.css('opacity', 1);
                    $c.css('filter', '');
                    break;
            }
        }
        function sc_fireCallbacks($t, o, b, a, c) {
            if (o[b])
            {
                o[b].call($t, a);
            }
            if (c[b].length)
            {
                for (var i = 0, l = c[b].length; i < l; i++)
                {
                    c[b][i].call($t, a);
                }
            }
            return [];
        }
        function sc_fireQueue($c, q, c) {

            if (q.length)
            {
                $c.trigger(cf_e(q[0][0], c), q[0][1]);
                q.shift();
            }
            return q;
        }
        function sc_hideHiddenItems(hiddenitems) {
            hiddenitems.each(function() {
                var hi = $(this);
                hi.data('_cfs_isHidden', hi.is(':hidden')).hide();
            });
        }
        function sc_showHiddenItems(hiddenitems) {
            if (hiddenitems)
            {
                hiddenitems.each(function() {
                    var hi = $(this);
                    if (!hi.data('_cfs_isHidden'))
                    {
                        hi.show();
                    }
                });
            }
        }
        function sc_clearTimers(t) {
            if (t.auto)
            {
                clearTimeout(t.auto);
            }
            if (t.progress)
            {
                clearInterval(t.progress);
            }
            return t;
        }
        function sc_mapCallbackArguments(i_old, i_skp, i_new, s_itm, s_dir, s_dur, w_siz) {
            return {
                'width': w_siz.width,
                'height': w_siz.height,
                'items': {
                    'old': i_old,
                    'skipped': i_skp,
                    'visible': i_new
                },
                'scroll': {
                    'items': s_itm,
                    'direction': s_dir,
                    'duration': s_dur
                }
            };
        }
        function sc_getDuration( sO, o, nI, siz ) {
            var dur = sO.duration;
            if (sO.fx == 'none')
            {
                return 0;
            }
            if (dur == 'auto')
            {
                dur = o.scroll.duration / o.scroll.items * nI;
            }
            else if (dur < 10)
            {
                dur = siz / dur;
            }
            if (dur < 1)
            {
                return 0;
            }
            if (sO.fx == 'fade')
            {
                dur = dur / 2;
            }
            return Math.round(dur);
        }

        //  navigation functions
        function nv_showNavi(o, t, c) {
            var minimum = (is_number(o.items.minimum)) ? o.items.minimum : o.items.visible + 1;
            if (t == 'show' || t == 'hide')
            {
                var f = t;
            }
            else if (minimum > t)
            {
                debug(c, 'Not enough items ('+t+' total, '+minimum+' needed): Hiding navigation.');
                var f = 'hide';
            }
            else
            {
                var f = 'show';
            }
            var s = (f == 'show') ? 'removeClass' : 'addClass',
                h = cf_c('hidden', c);

            if (o.auto.button)
            {
                o.auto.button[f]()[s](h);
            }
            if (o.prev.button)
            {
                o.prev.button[f]()[s](h);
            }
            if (o.next.button)
            {
                o.next.button[f]()[s](h);
            }
            if (o.pagination.container)
            {
                o.pagination.container[f]()[s](h);
            }
        }
        function nv_enableNavi(o, f, c) {
            if (o.circular || o.infinite) return;
            var fx = (f == 'removeClass' || f == 'addClass') ? f : false,
                di = cf_c('disabled', c);

            if (o.auto.button && fx)
            {
                o.auto.button[fx](di);
            }
            if (o.prev.button)
            {
                var fn = fx || (f == 0) ? 'addClass' : 'removeClass';
                o.prev.button[fn](di);
            }
            if (o.next.button)
            {
                var fn = fx || (f == o.items.visible) ? 'addClass' : 'removeClass';
                o.next.button[fn](di);
            }
        }

        //  get object functions
        function go_getObject($tt, obj) {
            if (is_function(obj))
            {
                obj = obj.call($tt);
            }
            else if (is_undefined(obj))
            {
                obj = {};
            }
            return obj;
        }
        function go_getItemsObject($tt, obj) {
            obj = go_getObject($tt, obj);
            if (is_number(obj))
            {
                obj = {
                    'visible': obj
                };
            }
            else if (obj == 'variable')
            {
                obj = {
                    'visible': obj,
                    'width': obj, 
                    'height': obj
                };
            }
            else if (!is_object(obj))
            {
                obj = {};
            }
            return obj;
        }
        function go_getScrollObject($tt, obj) {
            obj = go_getObject($tt, obj);
            if (is_number(obj))
            {
                if (obj <= 50)
                {
                    obj = {
                        'items': obj
                    };
                }
                else
                {
                    obj = {
                        'duration': obj
                    };
                }
            }
            else if (is_string(obj))
            {
                obj = {
                    'easing': obj
                };
            }
            else if (!is_object(obj))
            {
                obj = {};
            }
            return obj;
        }
        function go_getNaviObject($tt, obj) {
            obj = go_getObject($tt, obj);
            if (is_string(obj))
            {
                var temp = cf_getKeyCode(obj);
                if (temp == -1)
                {
                    obj = $(obj);
                }
                else
                {
                    obj = temp;
                }
            }
            return obj;
        }

        function go_getAutoObject($tt, obj) {
            obj = go_getNaviObject($tt, obj);
            if (is_jquery(obj))
            {
                obj = {
                    'button': obj
                };
            }
            else if (is_boolean(obj))
            {
                obj = {
                    'play': obj
                };
            }
            else if (is_number(obj))
            {
                obj = {
                    'timeoutDuration': obj
                };
            }
            if (obj.progress)
            {
                if (is_string(obj.progress) || is_jquery(obj.progress))
                {
                    obj.progress = {
                        'bar': obj.progress
                    };
                }
            }
            return obj;
        }
        function go_complementAutoObject($tt, obj) {
            if (is_function(obj.button))
            {
                obj.button = obj.button.call($tt);
            }
            if (is_string(obj.button))
            {
                obj.button = $(obj.button);
            }
            if (!is_boolean(obj.play))
            {
                obj.play = true;
            }
            if (!is_number(obj.delay))
            {
                obj.delay = 0;
            }
            if (is_undefined(obj.pauseOnEvent))
            {
                obj.pauseOnEvent = true;
            }
            if (!is_boolean(obj.pauseOnResize))
            {
                obj.pauseOnResize = true;
            }
            if (!is_number(obj.timeoutDuration))
            {
                obj.timeoutDuration = (obj.duration < 10)
                    ? 2500
                    : obj.duration * 5;
            }
            if (obj.progress)
            {
                if (is_function(obj.progress.bar))
                {
                    obj.progress.bar = obj.progress.bar.call($tt);
                }
                if (is_string(obj.progress.bar))
                {
                    obj.progress.bar = $(obj.progress.bar);
                }
                if (obj.progress.bar)
                {
                    if (!is_function(obj.progress.updater))
                    {
                        obj.progress.updater = $.fn.carouFredSel.progressbarUpdater;
                    }
                    if (!is_number(obj.progress.interval))
                    {
                        obj.progress.interval = 50;
                    }
                }
                else
                {
                    obj.progress = false;
                }
            }
            return obj;
        }

        function go_getPrevNextObject($tt, obj) {
            obj = go_getNaviObject($tt, obj);
            if (is_jquery(obj))
            {
                obj = {
                    'button': obj
                };
            }
            else if (is_number(obj))
            {
                obj = {
                    'key': obj
                };
            }
            return obj;
        }
        function go_complementPrevNextObject($tt, obj) {
            if (is_function(obj.button))
            {
                obj.button = obj.button.call($tt);
            }
            if (is_string(obj.button))
            {
                obj.button = $(obj.button);
            }
            if (is_string(obj.key))
            {
                obj.key = cf_getKeyCode(obj.key);
            }
            return obj;
        }

        function go_getPaginationObject($tt, obj) {
            obj = go_getNaviObject($tt, obj);
            if (is_jquery(obj))
            {
                obj = {
                    'container': obj
                };
            }
            else if (is_boolean(obj))
            {
                obj = {
                    'keys': obj
                };
            }
            return obj;
        }
        function go_complementPaginationObject($tt, obj) {
            if (is_function(obj.container))
            {
                obj.container = obj.container.call($tt);
            }
            if (is_string(obj.container))
            {
                obj.container = $(obj.container);
            }
            if (!is_number(obj.items))
            {
                obj.items = false;
            }
            if (!is_boolean(obj.keys))
            {
                obj.keys = false;
            }
            if (!is_function(obj.anchorBuilder) && !is_false(obj.anchorBuilder))
            {
                obj.anchorBuilder = $.fn.carouFredSel.pageAnchorBuilder;
            }
            if (!is_number(obj.deviation))
            {
                obj.deviation = 0;
            }
            return obj;
        }

        function go_getSwipeObject($tt, obj) {
            if (is_function(obj))
            {
                obj = obj.call($tt);
            }
            if (is_undefined(obj))
            {
                obj = {
                    'onTouch': false
                };
            }
            if (is_true(obj))
            {
                obj = {
                    'onTouch': obj
                };
            }
            else if (is_number(obj))
            {
                obj = {
                    'items': obj
                };
            }
            return obj;
        }
        function go_complementSwipeObject($tt, obj) {
            if (!is_boolean(obj.onTouch))
            {
                obj.onTouch = true;
            }
            if (!is_boolean(obj.onMouse))
            {
                obj.onMouse = false;
            }
            if (!is_object(obj.options))
            {
                obj.options = {};
            }
            if (!is_boolean(obj.options.triggerOnTouchEnd))
            {
                obj.options.triggerOnTouchEnd = false;
            }
            return obj;
        }
        function go_getMousewheelObject($tt, obj) {
            if (is_function(obj))
            {
                obj = obj.call($tt);
            }
            if (is_true(obj))
            {
                obj = {};
            }
            else if (is_number(obj))
            {
                obj = {
                    'items': obj
                };
            }
            else if (is_undefined(obj))
            {
                obj = false;
            }
            return obj;
        }
        function go_complementMousewheelObject($tt, obj) {
            return obj;
        }

        //  get number functions
        function gn_getItemIndex(num, dev, org, items, $cfs) {
            if (is_string(num))
            {
                num = $(num, $cfs);
            }

            if (is_object(num))
            {
                num = $(num, $cfs);
            }
            if (is_jquery(num))
            {
                num = $cfs.children().index(num);
                if (!is_boolean(org))
                {
                    org = false;
                }
            }
            else
            {
                if (!is_boolean(org))
                {
                    org = true;
                }
            }
            if (!is_number(num))
            {
                num = 0;
            }
            if (!is_number(dev))
            {
                dev = 0;
            }

            if (org)
            {
                num += items.first;
            }
            num += dev;
            if (items.total > 0)
            {
                while (num >= items.total)
                {
                    num -= items.total;
                }
                while (num < 0)
                {
                    num += items.total;
                }
            }
            return num;
        }

        //  items prev
        function gn_getVisibleItemsPrev(i, o, s) {
            var t = 0,
                x = 0;

            for (var a = s; a >= 0; a--)
            {
                var j = i.eq(a);
                t += (j.is(':visible')) ? j[o.d['outerWidth']](true) : 0;
                if (t > o.maxDimension)
                {
                    return x;
                }
                if (a == 0)
                {
                    a = i.length;
                }
                x++;
            }
        }
        function gn_getVisibleItemsPrevFilter(i, o, s) {
            return gn_getItemsPrevFilter(i, o.items.filter, o.items.visibleConf.org, s);
        }
        function gn_getScrollItemsPrevFilter(i, o, s, m) {
            return gn_getItemsPrevFilter(i, o.items.filter, m, s);
        }
        function gn_getItemsPrevFilter(i, f, m, s) {
            var t = 0,
                x = 0;

            for (var a = s, l = i.length; a >= 0; a--)
            {
                x++;
                if (x == l)
                {
                    return x;
                }

                var j = i.eq(a);
                if (j.is(f))
                {
                    t++;
                    if (t == m)
                    {
                        return x;
                    }
                }
                if (a == 0)
                {
                    a = l;
                }
            }
        }

        function gn_getVisibleOrg($c, o) {
            return o.items.visibleConf.org || $c.children().slice(0, o.items.visible).filter(o.items.filter).length;
        }

        //  items next
        function gn_getVisibleItemsNext(i, o, s) {
            var t = 0,
                x = 0;

            for (var a = s, l = i.length-1; a <= l; a++)
            {
                var j = i.eq(a);

                t += (j.is(':visible')) ? j[o.d['outerWidth']](true) : 0;
                if (t > o.maxDimension)
                {
                    return x;
                }

                x++;
                if (x == l+1)
                {
                    return x;
                }
                if (a == l)
                {
                    a = -1;
                }
            }
        }
        function gn_getVisibleItemsNextTestCircular(i, o, s, l) {
            var v = gn_getVisibleItemsNext(i, o, s);
            if (!o.circular)
            {
                if (s + v > l)
                {
                    v = l - s;
                }
            }
            return v;
        }
        function gn_getVisibleItemsNextFilter(i, o, s) {
            return gn_getItemsNextFilter(i, o.items.filter, o.items.visibleConf.org, s, o.circular);
        }
        function gn_getScrollItemsNextFilter(i, o, s, m) {
            return gn_getItemsNextFilter(i, o.items.filter, m+1, s, o.circular) - 1;
        }
        function gn_getItemsNextFilter(i, f, m, s, c) {
            var t = 0,
                x = 0;

            for (var a = s, l = i.length-1; a <= l; a++)
            {
                x++;
                if (x >= l)
                {
                    return x;
                }

                var j = i.eq(a);
                if (j.is(f))
                {
                    t++;
                    if (t == m)
                    {
                        return x;
                    }
                }
                if (a == l)
                {
                    a = -1;
                }
            }
        }

        //  get items functions
        function gi_getCurrentItems(i, o) {
            return i.slice(0, o.items.visible);
        }
        function gi_getOldItemsPrev(i, o, n) {
            return i.slice(n, o.items.visibleConf.old+n);
        }
        function gi_getNewItemsPrev(i, o) {
            return i.slice(0, o.items.visible);
        }
        function gi_getOldItemsNext(i, o) {
            return i.slice(0, o.items.visibleConf.old);
        }
        function gi_getNewItemsNext(i, o, n) {
            return i.slice(n, o.items.visible+n);
        }

        //  sizes functions
        function sz_storeMargin(i, o, d) {
            if (o.usePadding)
            {
                if (!is_string(d))
                {
                    d = '_cfs_origCssMargin';
                }
                i.each(function() {
                    var j = $(this),
                        m = parseInt(j.css(o.d['marginRight']), 10);
                    if (!is_number(m)) 
                    {
                        m = 0;
                    }
                    j.data(d, m);
                });
            }
        }
        function sz_resetMargin(i, o, m) {
            if (o.usePadding)
            {
                var x = (is_boolean(m)) ? m : false;
                if (!is_number(m))
                {
                    m = 0;
                }
                sz_storeMargin(i, o, '_cfs_tempCssMargin');
                i.each(function() {
                    var j = $(this);
                    j.css(o.d['marginRight'], ((x) ? j.data('_cfs_tempCssMargin') : m + j.data('_cfs_origCssMargin')));
                });
            }
        }
        function sz_storeOrigCss(i) {
            i.each(function() {
                var j = $(this);
                j.data('_cfs_origCss', j.attr('style') || '');
            });
        }
        function sz_restoreOrigCss(i) {
            i.each(function() {
                var j = $(this);
                j.attr('style', j.data('_cfs_origCss') || '');
            });
        }
        function sz_setResponsiveSizes(o, all) {
            var visb = o.items.visible,
                newS = o.items[o.d['width']],
                seco = o[o.d['height']],
                secp = is_percentage(seco);

            all.each(function() {
                var $t = $(this),
                    nw = newS - ms_getPaddingBorderMargin($t, o, 'Width');

                $t[o.d['width']](nw);
                if (secp)
                {
                    $t[o.d['height']](ms_getPercentage(nw, seco));
                }
            });
        }
        function sz_setSizes($c, o) {
            var $w = $c.parent(),
                $i = $c.children(),
                $v = gi_getCurrentItems($i, o),
                sz = cf_mapWrapperSizes(ms_getSizes($v, o, true), o, false);

            $w.css(sz);

            if (o.usePadding)
            {
                var p = o.padding,
                    r = p[o.d[1]];

                if (o.align && r < 0)
                {
                    r = 0;
                }
                var $l = $v.last();
                $l.css(o.d['marginRight'], $l.data('_cfs_origCssMargin') + r);
                $c.css(o.d['top'], p[o.d[0]]);
                $c.css(o.d['left'], p[o.d[3]]);
            }

            $c.css(o.d['width'], sz[o.d['width']]+(ms_getTotalSize($i, o, 'width')*2));
            $c.css(o.d['height'], ms_getLargestSize($i, o, 'height'));
            return sz;
        }

        //  measuring functions
        function ms_getSizes(i, o, wrapper) {
            return [ms_getTotalSize(i, o, 'width', wrapper), ms_getLargestSize(i, o, 'height', wrapper)];
        }
        function ms_getLargestSize(i, o, dim, wrapper) {
            if (!is_boolean(wrapper))
            {
                wrapper = false;
            }
            if (is_number(o[o.d[dim]]) && wrapper)
            {
                return o[o.d[dim]];
            }
            if (is_number(o.items[o.d[dim]]))
            {
                return o.items[o.d[dim]];
            }
            dim = (dim.toLowerCase().indexOf('width') > -1) ? 'outerWidth' : 'outerHeight';
            return ms_getTrueLargestSize(i, o, dim);
        }
        function ms_getTrueLargestSize(i, o, dim) {
            var s = 0;

            for (var a = 0, l = i.length; a < l; a++)
            {
                var j = i.eq(a);

                var m = (j.is(':visible')) ? j[o.d[dim]](true) : 0;
                if (s < m)
                {
                    s = m;
                }
            }
            return s;
        }

        function ms_getTotalSize(i, o, dim, wrapper) {
            if (!is_boolean(wrapper))
            {
                wrapper = false;
            }
            if (is_number(o[o.d[dim]]) && wrapper)
            {
                return o[o.d[dim]];
            }
            if (is_number(o.items[o.d[dim]]))
            {
                return o.items[o.d[dim]] * i.length;
            }

            var d = (dim.toLowerCase().indexOf('width') > -1) ? 'outerWidth' : 'outerHeight',
                s = 0;

            for (var a = 0, l = i.length; a < l; a++)
            {
                var j = i.eq(a);
                s += (j.is(':visible')) ? j[o.d[d]](true) : 0;
            }
            return s;
        }
        function ms_getParentSize($w, o, d) {
            var isVisible = $w.is(':visible');
            if (isVisible)
            {
                $w.hide();
            }
            var s = $w.parent()[o.d[d]]();
            if (isVisible)
            {
                $w.show();
            }
            return s;
        }
        function ms_getMaxDimension(o, a) {
            return (is_number(o[o.d['width']])) ? o[o.d['width']] : a;
        }
        function ms_hasVariableSizes(i, o, dim) {
            var s = false,
                v = false;

            for (var a = 0, l = i.length; a < l; a++)
            {
                var j = i.eq(a);

                var c = (j.is(':visible')) ? j[o.d[dim]](true) : 0;
                if (s === false)
                {
                    s = c;
                }
                else if (s != c)
                {
                    v = true;
                }
                if (s == 0)
                {
                    v = true;
                }
            }
            return v;
        }
        function ms_getPaddingBorderMargin(i, o, d) {
            return i[o.d['outer'+d]](true) - i[o.d[d.toLowerCase()]]();
        }
        function ms_getPercentage(s, o) {
            if (is_percentage(o))
            {
                o = parseInt( o.slice(0, -1), 10 );
                if (!is_number(o))
                {
                    return s;
                }
                s *= o/100;
            }
            return s;
        }

        //  config functions
        function cf_e(n, c, pf, ns, rd) {
            if (!is_boolean(pf))
            {
                pf = true;
            }
            if (!is_boolean(ns))
            {
                ns = true;
            }
            if (!is_boolean(rd))
            {
                rd = false;
            }

            if (pf)
            {
                n = c.events.prefix + n;
            }
            if (ns)
            {
                n = n +'.'+ c.events.namespace;
            }
            if (ns && rd)
            {
                n += c.serialNumber;
            }

            return n;
        }
        function cf_c(n, c) {
            return (is_string(c.classnames[n])) ? c.classnames[n] : n;
        }
        function cf_mapWrapperSizes(ws, o, p) {
            if (!is_boolean(p))
            {
                p = true;
            }
            var pad = (o.usePadding && p) ? o.padding : [0, 0, 0, 0];
            var wra = {};

            wra[o.d['width']] = ws[0] + pad[1] + pad[3];
            wra[o.d['height']] = ws[1] + pad[0] + pad[2];

            return wra;
        }
        function cf_sortParams(vals, typs) {
            var arr = [];
            for (var a = 0, l1 = vals.length; a < l1; a++)
            {
                for (var b = 0, l2 = typs.length; b < l2; b++)
                {
                    if (typs[b].indexOf(typeof vals[a]) > -1 && is_undefined(arr[b]))
                    {
                        arr[b] = vals[a];
                        break;
                    }
                }
            }
            return arr;
        }
        function cf_getPadding(p) {
            if (is_undefined(p))
            {
                return [0, 0, 0, 0];
            }
            if (is_number(p))
            {
                return [p, p, p, p];
            }
            if (is_string(p))
            {
                p = p.split('px').join('').split('em').join('').split(' ');
            }

            if (!is_array(p))
            {
                return [0, 0, 0, 0];
            }
            for (var i = 0; i < 4; i++)
            {
                p[i] = parseInt(p[i], 10);
            }
            switch (p.length)
            {
                case 0:
                    return [0, 0, 0, 0];
                case 1:
                    return [p[0], p[0], p[0], p[0]];
                case 2:
                    return [p[0], p[1], p[0], p[1]];
                case 3:
                    return [p[0], p[1], p[2], p[1]];
                default:
                    return [p[0], p[1], p[2], p[3]];
            }
        }
        function cf_getAlignPadding(itm, o) {
            var x = (is_number(o[o.d['width']])) ? Math.ceil(o[o.d['width']] - ms_getTotalSize(itm, o, 'width')) : 0;
            switch (o.align)
            {
                case 'left': 
                    return [0, x];
                case 'right':
                    return [x, 0];
                case 'center':
                default:
                    return [Math.ceil(x/2), Math.floor(x/2)];
            }
        }
        function cf_getDimensions(o) {
            var dm = [
                    ['width'    , 'innerWidth'  , 'outerWidth'  , 'height'  , 'innerHeight' , 'outerHeight' , 'left', 'top' , 'marginRight' , 0, 1, 2, 3],
                    ['height'   , 'innerHeight' , 'outerHeight' , 'width'   , 'innerWidth'  , 'outerWidth'  , 'top' , 'left', 'marginBottom', 3, 2, 1, 0]
                ];

            var dl = dm[0].length,
                dx = (o.direction == 'right' || o.direction == 'left') ? 0 : 1;

            var dimensions = {};
            for (var d = 0; d < dl; d++)
            {
                dimensions[dm[0][d]] = dm[dx][d];
            }
            return dimensions;
        }
        function cf_getAdjust(x, o, a, $t) {
            var v = x;
            if (is_function(a))
            {
                v = a.call($t, v);

            }
            else if (is_string(a))
            {
                var p = a.split('+'),
                    m = a.split('-');

                if (m.length > p.length)
                {
                    var neg = true,
                        sta = m[0],
                        adj = m[1];
                }
                else
                {
                    var neg = false,
                        sta = p[0],
                        adj = p[1];
                }

                switch(sta)
                {
                    case 'even':
                        v = (x % 2 == 1) ? x-1 : x;
                        break;
                    case 'odd':
                        v = (x % 2 == 0) ? x-1 : x;
                        break;
                    default:
                        v = x;
                        break;
                }
                adj = parseInt(adj, 10);
                if (is_number(adj))
                {
                    if (neg)
                    {
                        adj = -adj;
                    }
                    v += adj;
                }
            }
            if (!is_number(v) || v < 1)
            {
                v = 1;
            }
            return v;
        }
        function cf_getItemsAdjust(x, o, a, $t) {
            return cf_getItemAdjustMinMax(cf_getAdjust(x, o, a, $t), o.items.visibleConf);
        }
        function cf_getItemAdjustMinMax(v, i) {
            if (is_number(i.min) && v < i.min)
            {
                v = i.min;
            }
            if (is_number(i.max) && v > i.max)
            {
                v = i.max;
            }
            if (v < 1)
            {
                v = 1;
            }
            return v;
        }
        function cf_getSynchArr(s) {
            if (!is_array(s))
            {
                s = [[s]];
            }
            if (!is_array(s[0]))
            {
                s = [s];
            }
            for (var j = 0, l = s.length; j < l; j++)
            {
                if (is_string(s[j][0]))
                {
                    s[j][0] = $(s[j][0]);
                }
                if (!is_boolean(s[j][1]))
                {
                    s[j][1] = true;
                }
                if (!is_boolean(s[j][2]))
                {
                    s[j][2] = true;
                }
                if (!is_number(s[j][3]))
                {
                    s[j][3] = 0;
                }
            }
            return s;
        }
        function cf_getKeyCode(k) {
            if (k == 'right')
            {
                return 39;
            }
            if (k == 'left')
            {
                return 37;
            }
            if (k == 'up')
            {
                return 38;
            }
            if (k == 'down')
            {
                return 40;
            }
            return -1;
        }
        function cf_setCookie(n, $c, c) {
            if (n)
            {
                var v = $c.triggerHandler(cf_e('currentPosition', c));
                $.fn.carouFredSel.cookie.set(n, v);
            }
        }
        function cf_getCookie(n) {
            var c = $.fn.carouFredSel.cookie.get(n);
            return (c == '') ? 0 : c;
        }

        //  init function
        function in_mapCss($elem, props) {
            var css = {};
            for (var p = 0, l = props.length; p < l; p++)
            {
                css[props[p]] = $elem.css(props[p]);
            }
            return css;
        }
        function in_complementItems(obj, opt, itm, sta) {
            if (!is_object(obj.visibleConf))
            {
                obj.visibleConf = {};
            }
            if (!is_object(obj.sizesConf))
            {
                obj.sizesConf = {};
            }

            if (obj.start == 0 && is_number(sta))
            {
                obj.start = sta;
            }

            //  visible items
            if (is_object(obj.visible))
            {
                obj.visibleConf.min = obj.visible.min;
                obj.visibleConf.max = obj.visible.max;
                obj.visible = false;
            }
            else if (is_string(obj.visible))
            {
                //  variable visible items
                if (obj.visible == 'variable')
                {
                    obj.visibleConf.variable = true;
                }
                //  adjust string visible items
                else
                {
                    obj.visibleConf.adjust = obj.visible;
                }
                obj.visible = false;
            }
            else if (is_function(obj.visible))
            {
                obj.visibleConf.adjust = obj.visible;
                obj.visible = false;
            }

            //  set items filter
            if (!is_string(obj.filter))
            {
                obj.filter = (itm.filter(':hidden').length > 0) ? ':visible' : '*';
            }

            //  primary item-size not set
            if (!obj[opt.d['width']])
            {
                //  responsive carousel -> set to largest
                if (opt.responsive)
                {
                    debug(true, 'Set a '+opt.d['width']+' for the items!');
                    obj[opt.d['width']] = ms_getTrueLargestSize(itm, opt, 'outerWidth');
                }
                //   non-responsive -> measure it or set to "variable"
                else
                {
                    obj[opt.d['width']] = (ms_hasVariableSizes(itm, opt, 'outerWidth')) 
                        ? 'variable' 
                        : itm[opt.d['outerWidth']](true);
                }
            }

            //  secondary item-size not set -> measure it or set to "variable"
            if (!obj[opt.d['height']])
            {
                obj[opt.d['height']] = (ms_hasVariableSizes(itm, opt, 'outerHeight')) 
                    ? 'variable' 
                    : itm[opt.d['outerHeight']](true);
            }

            obj.sizesConf.width = obj.width;
            obj.sizesConf.height = obj.height;
            return obj;
        }
        function in_complementVisibleItems(opt, avl) {
            //  primary item-size variable -> set visible items variable
            if (opt.items[opt.d['width']] == 'variable')
            {
                opt.items.visibleConf.variable = true;
            }
            if (!opt.items.visibleConf.variable) {
                //  primary size is number -> calculate visible-items
                if (is_number(opt[opt.d['width']]))
                {
                    opt.items.visible = Math.floor(opt[opt.d['width']] / opt.items[opt.d['width']]);
                }
                //  measure and calculate primary size and visible-items
                else
                {
                    opt.items.visible = Math.floor(avl / opt.items[opt.d['width']]);
                    opt[opt.d['width']] = opt.items.visible * opt.items[opt.d['width']];
                    if (!opt.items.visibleConf.adjust)
                    {
                        opt.align = false;
                    }
                }
                if (opt.items.visible == 'Infinity' || opt.items.visible < 1)
                {
                    debug(true, 'Not a valid number of visible items: Set to "variable".');
                    opt.items.visibleConf.variable = true;
                }
            }
            return opt;
        }
        function in_complementPrimarySize(obj, opt, all) {
            //  primary size set to auto -> measure largest item-size and set it
            if (obj == 'auto')
            {
                obj = ms_getTrueLargestSize(all, opt, 'outerWidth');
            }
            return obj;
        }
        function in_complementSecondarySize(obj, opt, all) {
            //  secondary size set to auto -> measure largest item-size and set it
            if (obj == 'auto')
            {
                obj = ms_getTrueLargestSize(all, opt, 'outerHeight');
            }
            //  secondary size not set -> set to secondary item-size
            if (!obj)
            {
                obj = opt.items[opt.d['height']];
            }
            return obj;
        }
        function in_getAlignPadding(o, all) {
            var p = cf_getAlignPadding(gi_getCurrentItems(all, o), o);
            o.padding[o.d[1]] = p[1];
            o.padding[o.d[3]] = p[0];
            return o;
        }
        function in_getResponsiveValues(o, all, avl) {

            var visb = cf_getItemAdjustMinMax(Math.ceil(o[o.d['width']] / o.items[o.d['width']]), o.items.visibleConf);
            if (visb > all.length)
            {
                visb = all.length;
            }

            var newS = Math.floor(o[o.d['width']]/visb);

            o.items.visible = visb;
            o.items[o.d['width']] = newS;
            o[o.d['width']] = visb * newS;
            return o;
        }


        //  buttons functions
        function bt_pauseOnHoverConfig(p) {
            if (is_string(p))
            {
                var i = (p.indexOf('immediate') > -1) ? true : false,
                    r = (p.indexOf('resume')    > -1) ? true : false;
            }
            else
            {
                var i = r = false;
            }
            return [i, r];
        }
        function bt_mousesheelNumber(mw) {
            return (is_number(mw)) ? mw : null
        }

        //  helper functions
        function is_null(a) {
            return (a === null);
        }
        function is_undefined(a) {
            return (is_null(a) || typeof a == 'undefined' || a === '' || a === 'undefined');
        }
        function is_array(a) {
            return (a instanceof Array);
        }
        function is_jquery(a) {
            return (a instanceof jQuery);
        }
        function is_object(a) {
            return ((a instanceof Object || typeof a == 'object') && !is_null(a) && !is_jquery(a) && !is_array(a) && !is_function(a));
        }
        function is_number(a) {
            return ((a instanceof Number || typeof a == 'number') && !isNaN(a));
        }
        function is_string(a) {
            return ((a instanceof String || typeof a == 'string') && !is_undefined(a) && !is_true(a) && !is_false(a));
        }
        function is_function(a) {
            return (a instanceof Function || typeof a == 'function');
        }
        function is_boolean(a) {
            return (a instanceof Boolean || typeof a == 'boolean' || is_true(a) || is_false(a));
        }
        function is_true(a) {
            return (a === true || a === 'true');
        }
        function is_false(a) {
            return (a === false || a === 'false');
        }
        function is_percentage(x) {
            return (is_string(x) && x.slice(-1) == '%');
        }


        function getTime() {
            return new Date().getTime();
        }

        function deprecated( o, n ) {
            debug(true, o+' is DEPRECATED, support for it will be removed. Use '+n+' instead.');
        }
        function debug(d, m) {
            if (!is_undefined(window.console) && !is_undefined(window.console.log))
            {
                if (is_object(d))
                {
                    var s = ' ('+d.selector+')';
                    d = d.debug;
                }
                else
                {
                    var s = '';
                }
                if (!d)
                {
                    return false;
                }
        
                if (is_string(m))
                {
                    m = 'carouFredSel'+s+': ' + m;
                }
                else
                {
                    m = ['carouFredSel'+s+':', m];
                }
                window.console.log(m);
            }
            return false;
        }



        //  EASING FUNCTIONS
        $.extend($.easing, {
            'quadratic': function(t) {
                var t2 = t * t;
                return t * (-t2 * t + 4 * t2 - 6 * t + 4);
            },
            'cubic': function(t) {
                return t * (4 * t * t - 9 * t + 6);
            },
            'elastic': function(t) {
                var t2 = t * t;
                return t * (33 * t2 * t2 - 106 * t2 * t + 126 * t2 - 67 * t + 15);
            }
        });


    })(jQuery);
/*-------------------------------  Fred_plug  -------------------------------------*/   
    /*!
     * jQuery Transit - CSS3 transitions and transformations
     * (c) 2011-2012 Rico Sta. Cruz <rico@ricostacruz.com>
     * MIT Licensed.
     *
     * http://ricostacruz.com/jquery.transit
     * http://github.com/rstacruz/jquery.transit
     */
        (function(d){function m(a){if(a in j.style)return a;var b=["Moz","Webkit","O","ms"],c=a.charAt(0).toUpperCase()+a.substr(1);if(a in j.style)return a;for(a=0;a<b.length;++a){var d=b[a]+c;if(d in j.style)return d}}function l(a){"string"===typeof a&&this.parse(a);return this}function q(a,b,c,e){var h=[];d.each(a,function(a){a=d.camelCase(a);a=d.transit.propertyMap[a]||d.cssProps[a]||a;a=a.replace(/([A-Z])/g,function(a){return"-"+a.toLowerCase()});-1===d.inArray(a,h)&&h.push(a)});d.cssEase[c]&&(c=d.cssEase[c]);
        var f=""+n(b)+" "+c;0<parseInt(e,10)&&(f+=" "+n(e));var g=[];d.each(h,function(a,b){g.push(b+" "+f)});return g.join(", ")}function f(a,b){b||(d.cssNumber[a]=!0);d.transit.propertyMap[a]=e.transform;d.cssHooks[a]={get:function(b){return d(b).css("transit:transform").get(a)},set:function(b,e){var h=d(b).css("transit:transform");h.setFromString(a,e);d(b).css({"transit:transform":h})}}}function g(a,b){return"string"===typeof a&&!a.match(/^[\-0-9\.]+$/)?a:""+a+b}function n(a){d.fx.speeds[a]&&(a=d.fx.speeds[a]);
        return g(a,"ms")}d.transit={version:"0.9.9",propertyMap:{marginLeft:"margin",marginRight:"margin",marginBottom:"margin",marginTop:"margin",paddingLeft:"padding",paddingRight:"padding",paddingBottom:"padding",paddingTop:"padding"},enabled:!0,useTransitionEnd:!1};var j=document.createElement("div"),e={},r=-1<navigator.userAgent.toLowerCase().indexOf("chrome");e.transition=m("transition");e.transitionDelay=m("transitionDelay");e.transform=m("transform");e.transformOrigin=m("transformOrigin");j.style[e.transform]=
        "";j.style[e.transform]="rotateY(90deg)";e.transform3d=""!==j.style[e.transform];var p=e.transitionEnd={transition:"transitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",WebkitTransition:"webkitTransitionEnd",msTransition:"MSTransitionEnd"}[e.transition]||null,k;for(k in e)e.hasOwnProperty(k)&&"undefined"===typeof d.support[k]&&(d.support[k]=e[k]);j=null;d.cssEase={_default:"ease","in":"ease-in",out:"ease-out","in-out":"ease-in-out",snap:"cubic-bezier(0,1,.5,1)",easeOutCubic:"cubic-bezier(.215,.61,.355,1)",
        easeInOutCubic:"cubic-bezier(.645,.045,.355,1)",easeInCirc:"cubic-bezier(.6,.04,.98,.335)",easeOutCirc:"cubic-bezier(.075,.82,.165,1)",easeInOutCirc:"cubic-bezier(.785,.135,.15,.86)",easeInExpo:"cubic-bezier(.95,.05,.795,.035)",easeOutExpo:"cubic-bezier(.19,1,.22,1)",easeInOutExpo:"cubic-bezier(1,0,0,1)",easeInQuad:"cubic-bezier(.55,.085,.68,.53)",easeOutQuad:"cubic-bezier(.25,.46,.45,.94)",easeInOutQuad:"cubic-bezier(.455,.03,.515,.955)",easeInQuart:"cubic-bezier(.895,.03,.685,.22)",easeOutQuart:"cubic-bezier(.165,.84,.44,1)",
        easeInOutQuart:"cubic-bezier(.77,0,.175,1)",easeInQuint:"cubic-bezier(.755,.05,.855,.06)",easeOutQuint:"cubic-bezier(.23,1,.32,1)",easeInOutQuint:"cubic-bezier(.86,0,.07,1)",easeInSine:"cubic-bezier(.47,0,.745,.715)",easeOutSine:"cubic-bezier(.39,.575,.565,1)",easeInOutSine:"cubic-bezier(.445,.05,.55,.95)",easeInBack:"cubic-bezier(.6,-.28,.735,.045)",easeOutBack:"cubic-bezier(.175, .885,.32,1.275)",easeInOutBack:"cubic-bezier(.68,-.55,.265,1.55)"};d.cssHooks["transit:transform"]={get:function(a){return d(a).data("transform")||
        new l},set:function(a,b){var c=b;c instanceof l||(c=new l(c));a.style[e.transform]="WebkitTransform"===e.transform&&!r?c.toString(!0):c.toString();d(a).data("transform",c)}};d.cssHooks.transform={set:d.cssHooks["transit:transform"].set};"1.8">d.fn.jquery&&(d.cssHooks.transformOrigin={get:function(a){return a.style[e.transformOrigin]},set:function(a,b){a.style[e.transformOrigin]=b}},d.cssHooks.transition={get:function(a){return a.style[e.transition]},set:function(a,b){a.style[e.transition]=b}});f("scale");
        f("translate");f("rotate");f("rotateX");f("rotateY");f("rotate3d");f("perspective");f("skewX");f("skewY");f("x",!0);f("y",!0);l.prototype={setFromString:function(a,b){var c="string"===typeof b?b.split(","):b.constructor===Array?b:[b];c.unshift(a);l.prototype.set.apply(this,c)},set:function(a){var b=Array.prototype.slice.apply(arguments,[1]);this.setter[a]?this.setter[a].apply(this,b):this[a]=b.join(",")},get:function(a){return this.getter[a]?this.getter[a].apply(this):this[a]||0},setter:{rotate:function(a){this.rotate=
        g(a,"deg")},rotateX:function(a){this.rotateX=g(a,"deg")},rotateY:function(a){this.rotateY=g(a,"deg")},scale:function(a,b){void 0===b&&(b=a);this.scale=a+","+b},skewX:function(a){this.skewX=g(a,"deg")},skewY:function(a){this.skewY=g(a,"deg")},perspective:function(a){this.perspective=g(a,"px")},x:function(a){this.set("translate",a,null)},y:function(a){this.set("translate",null,a)},translate:function(a,b){void 0===this._translateX&&(this._translateX=0);void 0===this._translateY&&(this._translateY=0);
        null!==a&&void 0!==a&&(this._translateX=g(a,"px"));null!==b&&void 0!==b&&(this._translateY=g(b,"px"));this.translate=this._translateX+","+this._translateY}},getter:{x:function(){return this._translateX||0},y:function(){return this._translateY||0},scale:function(){var a=(this.scale||"1,1").split(",");a[0]&&(a[0]=parseFloat(a[0]));a[1]&&(a[1]=parseFloat(a[1]));return a[0]===a[1]?a[0]:a},rotate3d:function(){for(var a=(this.rotate3d||"0,0,0,0deg").split(","),b=0;3>=b;++b)a[b]&&(a[b]=parseFloat(a[b]));
        a[3]&&(a[3]=g(a[3],"deg"));return a}},parse:function(a){var b=this;a.replace(/([a-zA-Z0-9]+)\((.*?)\)/g,function(a,d,e){b.setFromString(d,e)})},toString:function(a){var b=[],c;for(c in this)if(this.hasOwnProperty(c)&&(e.transform3d||!("rotateX"===c||"rotateY"===c||"perspective"===c||"transformOrigin"===c)))"_"!==c[0]&&(a&&"scale"===c?b.push(c+"3d("+this[c]+",1)"):a&&"translate"===c?b.push(c+"3d("+this[c]+",0)"):b.push(c+"("+this[c]+")"));return b.join(" ")}};d.fn.transition=d.fn.transit=function(a,
        b,c,f){var h=this,g=0,j=!0;"function"===typeof b&&(f=b,b=void 0);"function"===typeof c&&(f=c,c=void 0);"undefined"!==typeof a.easing&&(c=a.easing,delete a.easing);"undefined"!==typeof a.duration&&(b=a.duration,delete a.duration);"undefined"!==typeof a.complete&&(f=a.complete,delete a.complete);"undefined"!==typeof a.queue&&(j=a.queue,delete a.queue);"undefined"!==typeof a.delay&&(g=a.delay,delete a.delay);"undefined"===typeof b&&(b=d.fx.speeds._default);"undefined"===typeof c&&(c=d.cssEase._default);
        b=n(b);var l=q(a,b,c,g),k=d.transit.enabled&&e.transition?parseInt(b,10)+parseInt(g,10):0;if(0===k)return b=j,c=function(b){h.css(a);f&&f.apply(h);b&&b()},!0===b?h.queue(c):b?h.queue(b,c):c(),h;var m={};b=j;c=function(b){this.offsetWidth;var c=!1,g=function(){c&&h.unbind(p,g);0<k&&h.each(function(){this.style[e.transition]=m[this]||null});"function"===typeof f&&f.apply(h);"function"===typeof b&&b()};0<k&&p&&d.transit.useTransitionEnd?(c=!0,h.bind(p,g)):window.setTimeout(g,k);h.each(function(){0<k&&
        (this.style[e.transition]=l);d(this).css(a)})};!0===b?h.queue(c):b?h.queue(b,c):c();return this};d.transit.getTransitionValue=q})(jQuery);

    /*
    * touchSwipe - jQuery Plugin
    * https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
    * http://labs.skinkers.com/touchSwipe/
    * http://plugins.jquery.com/project/touchSwipe
    *
    * Copyright (c) 2010 Matt Bryson (www.skinkers.com)
    * Dual licensed under the MIT or GPL Version 2 licenses.
    *
    * $version: 1.3.3
    */

        (function(g){function P(c){if(c&&void 0===c.allowPageScroll&&(void 0!==c.swipe||void 0!==c.swipeStatus))c.allowPageScroll=G;c||(c={});c=g.extend({},g.fn.swipe.defaults,c);return this.each(function(){var b=g(this),f=b.data(w);f||(f=new W(this,c),b.data(w,f))})}function W(c,b){var f,p,r,s;function H(a){var a=a.originalEvent,c,Q=n?a.touches[0]:a;d=R;n?h=a.touches.length:a.preventDefault();i=0;j=null;k=0;!n||h===b.fingers||b.fingers===x?(r=f=Q.pageX,s=p=Q.pageY,y=(new Date).getTime(),b.swipeStatus&&(c= l(a,d))):t(a);if(!1===c)return d=m,l(a,d),c;e.bind(I,J);e.bind(K,L)}function J(a){a=a.originalEvent;if(!(d===q||d===m)){var c,e=n?a.touches[0]:a;f=e.pageX;p=e.pageY;u=(new Date).getTime();j=S();n&&(h=a.touches.length);d=z;var e=a,g=j;if(b.allowPageScroll===G)e.preventDefault();else{var o=b.allowPageScroll===T;switch(g){case v:(b.swipeLeft&&o||!o&&b.allowPageScroll!=M)&&e.preventDefault();break;case A:(b.swipeRight&&o||!o&&b.allowPageScroll!=M)&&e.preventDefault();break;case B:(b.swipeUp&&o||!o&&b.allowPageScroll!= N)&&e.preventDefault();break;case C:(b.swipeDown&&o||!o&&b.allowPageScroll!=N)&&e.preventDefault()}}h===b.fingers||b.fingers===x||!n?(i=U(),k=u-y,b.swipeStatus&&(c=l(a,d,j,i,k)),b.triggerOnTouchEnd||(e=!(b.maxTimeThreshold?!(k>=b.maxTimeThreshold):1),!0===D()?(d=q,c=l(a,d)):e&&(d=m,l(a,d)))):(d=m,l(a,d));!1===c&&(d=m,l(a,d))}}function L(a){a=a.originalEvent;a.preventDefault();u=(new Date).getTime();i=U();j=S();k=u-y;if(b.triggerOnTouchEnd||!1===b.triggerOnTouchEnd&&d===z)if(d=q,(h===b.fingers||b.fingers=== x||!n)&&0!==f){var c=!(b.maxTimeThreshold?!(k>=b.maxTimeThreshold):1);if((!0===D()||null===D())&&!c)l(a,d);else if(c||!1===D())d=m,l(a,d)}else d=m,l(a,d);else d===z&&(d=m,l(a,d));e.unbind(I,J,!1);e.unbind(K,L,!1)}function t(){y=u=p=f=s=r=h=0}function l(a,c){var d=void 0;b.swipeStatus&&(d=b.swipeStatus.call(e,a,c,j||null,i||0,k||0,h));if(c===m&&b.click&&(1===h||!n)&&(isNaN(i)||0===i))d=b.click.call(e,a,a.target);if(c==q)switch(b.swipe&&(d=b.swipe.call(e,a,j,i,k,h)),j){case v:b.swipeLeft&&(d=b.swipeLeft.call(e, a,j,i,k,h));break;case A:b.swipeRight&&(d=b.swipeRight.call(e,a,j,i,k,h));break;case B:b.swipeUp&&(d=b.swipeUp.call(e,a,j,i,k,h));break;case C:b.swipeDown&&(d=b.swipeDown.call(e,a,j,i,k,h))}(c===m||c===q)&&t(a);return d}function D(){return null!==b.threshold?i>=b.threshold:null}function U(){return Math.round(Math.sqrt(Math.pow(f-r,2)+Math.pow(p-s,2)))}function S(){var a;a=Math.atan2(p-s,r-f);a=Math.round(180*a/Math.PI);0>a&&(a=360-Math.abs(a));return 45>=a&&0<=a?v:360>=a&&315<=a?v:135<=a&&225>=a? A:45<a&&135>a?C:B}function V(){e.unbind(E,H);e.unbind(F,t);e.unbind(I,J);e.unbind(K,L)}var O=n||!b.fallbackToMouseEvents,E=O?"touchstart":"mousedown",I=O?"touchmove":"mousemove",K=O?"touchend":"mouseup",F="touchcancel",i=0,j=null,k=0,e=g(c),d="start",h=0,y=p=f=s=r=0,u=0;try{e.bind(E,H),e.bind(F,t)}catch(P){g.error("events not supported "+E+","+F+" on jQuery.swipe")}this.enable=function(){e.bind(E,H);e.bind(F,t);return e};this.disable=function(){V();return e};this.destroy=function(){V();e.data(w,null); return e}}var v="left",A="right",B="up",C="down",G="none",T="auto",M="horizontal",N="vertical",x="all",R="start",z="move",q="end",m="cancel",n="ontouchstart"in window,w="TouchSwipe";g.fn.swipe=function(c){var b=g(this),f=b.data(w);if(f&&"string"===typeof c){if(f[c])return f[c].apply(this,Array.prototype.slice.call(arguments,1));g.error("Method "+c+" does not exist on jQuery.swipe")}else if(!f&&("object"===typeof c||!c))return P.apply(this,arguments);return b};g.fn.swipe.defaults={fingers:1,threshold:75, maxTimeThreshold:null,swipe:null,swipeLeft:null,swipeRight:null,swipeUp:null,swipeDown:null,swipeStatus:null,click:null,triggerOnTouchEnd:!0,allowPageScroll:"auto",fallbackToMouseEvents:!0};g.fn.swipe.phases={PHASE_START:R,PHASE_MOVE:z,PHASE_END:q,PHASE_CANCEL:m};g.fn.swipe.directions={LEFT:v,RIGHT:A,UP:B,DOWN:C};g.fn.swipe.pageScroll={NONE:G,HORIZONTAL:M,VERTICAL:N,AUTO:T};g.fn.swipe.fingers={ONE:1,TWO:2,THREE:3,ALL:x}})(jQuery);
/*-------------------------------  UI slider  -------------------------------*/

    /*! jQuery UI - v1.11.2 - 2014-11-18
    * http://jqueryui.com
    * Includes: core.js, widget.js, mouse.js, position.js, draggable.js, resizable.js, slider.js
    * Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

    (function( factory ) {
        if ( typeof define === "function" && define.amd ) {

            // AMD. Register as an anonymous module.
            define([ "jquery" ], factory );
        } else {

            // Browser globals
            factory( jQuery );
        }
    }(function( $ ) {
    /*!
     * jQuery UI Core 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/category/ui-core/
     */


    // $.ui might exist from components with no dependencies, e.g., $.ui.position
    $.ui = $.ui || {};

    $.extend( $.ui, {
        version: "1.11.2",

        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });

    // plugins
    $.fn.extend({
        scrollParent: function( includeHidden ) {
            var position = this.css( "position" ),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter( function() {
                    var parent = $( this );
                    if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                        return false;
                    }
                    return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
                }).eq( 0 );

            return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
        },

        uniqueId: (function() {
            var uuid = 0;

            return function() {
                return this.each(function() {
                    if ( !this.id ) {
                        this.id = "ui-id-" + ( ++uuid );
                    }
                });
            };
        })(),

        removeUniqueId: function() {
            return this.each(function() {
                if ( /^ui-id-\d+$/.test( this.id ) ) {
                    $( this ).removeAttr( "id" );
                }
            });
        }
    });

    // selectors
    function focusable( element, isTabIndexNotNaN ) {
        var map, mapName, img,
            nodeName = element.nodeName.toLowerCase();
        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
            return !!img && visible( img );
        }
        return ( /input|select|textarea|button|object/.test( nodeName ) ?
            !element.disabled :
            "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN) &&
            // the element and all of its ancestors must be visible
            visible( element );
    }

    function visible( element ) {
        return $.expr.filters.visible( element ) &&
            !$( element ).parents().addBack().filter(function() {
                return $.css( this, "visibility" ) === "hidden";
            }).length;
    }

    $.extend( $.expr[ ":" ], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function( dataName ) {
                return function( elem ) {
                    return !!$.data( elem, dataName );
                };
            }) :
            // support: jQuery <1.8
            function( elem, i, match ) {
                return !!$.data( elem, match[ 3 ] );
            },

        focusable: function( element ) {
            return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
        },

        tabbable: function( element ) {
            var tabIndex = $.attr( element, "tabindex" ),
                isTabIndexNaN = isNaN( tabIndex );
            return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
        }
    });

    // support: jQuery <1.8
    if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
        $.each( [ "Width", "Height" ], function( i, name ) {
            var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce( elem, size, border, margin ) {
                $.each( side, function() {
                    size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
                    if ( border ) {
                        size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
                    }
                    if ( margin ) {
                        size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
                    }
                });
                return size;
            }

            $.fn[ "inner" + name ] = function( size ) {
                if ( size === undefined ) {
                    return orig[ "inner" + name ].call( this );
                }

                return this.each(function() {
                    $( this ).css( type, reduce( this, size ) + "px" );
                });
            };

            $.fn[ "outer" + name] = function( size, margin ) {
                if ( typeof size !== "number" ) {
                    return orig[ "outer" + name ].call( this, size );
                }

                return this.each(function() {
                    $( this).css( type, reduce( this, size, true, margin ) + "px" );
                });
            };
        });
    }

    // support: jQuery <1.8
    if ( !$.fn.addBack ) {
        $.fn.addBack = function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter( selector )
            );
        };
    }

    // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
        $.fn.removeData = (function( removeData ) {
            return function( key ) {
                if ( arguments.length ) {
                    return removeData.call( this, $.camelCase( key ) );
                } else {
                    return removeData.call( this );
                }
            };
        })( $.fn.removeData );
    }

    // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

    $.fn.extend({
        focus: (function( orig ) {
            return function( delay, fn ) {
                return typeof delay === "number" ?
                    this.each(function() {
                        var elem = this;
                        setTimeout(function() {
                            $( elem ).focus();
                            if ( fn ) {
                                fn.call( elem );
                            }
                        }, delay );
                    }) :
                    orig.apply( this, arguments );
            };
        })( $.fn.focus ),

        disableSelection: (function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.bind( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                });
            };
        })(),

        enableSelection: function() {
            return this.unbind( ".ui-disableSelection" );
        },

        zIndex: function( zIndex ) {
            if ( zIndex !== undefined ) {
                return this.css( "zIndex", zIndex );
            }

            if ( this.length ) {
                var elem = $( this[ 0 ] ), position, value;
                while ( elem.length && elem[ 0 ] !== document ) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css( "position" );
                    if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt( elem.css( "zIndex" ), 10 );
                        if ( !isNaN( value ) && value !== 0 ) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        }
    });

    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    $.ui.plugin = {
        add: function( module, option, set ) {
            var i,
                proto = $.ui[ module ].prototype;
            for ( i in set ) {
                proto.plugins[ i ] = proto.plugins[ i ] || [];
                proto.plugins[ i ].push( [ option, set[ i ] ] );
            }
        },
        call: function( instance, name, args, allowDisconnected ) {
            var i,
                set = instance.plugins[ name ];

            if ( !set ) {
                return;
            }

            if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
                return;
            }

            for ( i = 0; i < set.length; i++ ) {
                if ( instance.options[ set[ i ][ 0 ] ] ) {
                    set[ i ][ 1 ].apply( instance.element, args );
                }
            }
        }
    };


    /*!
     * jQuery UI Widget 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/jQuery.widget/
     */


    var widget_uuid = 0,
        widget_slice = Array.prototype.slice;

    $.cleanData = (function( orig ) {
        return function( elems ) {
            var events, elem, i;
            for ( i = 0; (elem = elems[i]) != null; i++ ) {
                try {

                    // Only trigger remove when necessary to save time
                    events = $._data( elem, "events" );
                    if ( events && events.remove ) {
                        $( elem ).triggerHandler( "remove" );
                    }

                // http://bugs.jquery.com/ticket/8235
                } catch ( e ) {}
            }
            orig( elems );
        };
    })( $.cleanData );

    $.widget = function( name, base, prototype ) {
        var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
            namespace = name.split( "." )[ 0 ];

        name = name.split( "." )[ 1 ];
        fullName = namespace + "-" + name;

        if ( !prototype ) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
            return !!$.data( elem, fullName );
        };

        $[ namespace ] = $[ namespace ] || {};
        existingConstructor = $[ namespace ][ name ];
        constructor = $[ namespace ][ name ] = function( options, element ) {
            // allow instantiation without "new" keyword
            if ( !this._createWidget ) {
                return new constructor( options, element );
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if ( arguments.length ) {
                this._createWidget( options, element );
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend( constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend( {}, prototype ),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend( {}, basePrototype.options );
        $.each( prototype, function( prop, value ) {
            if ( !$.isFunction( value ) ) {
                proxiedPrototype[ prop ] = value;
                return;
            }
            proxiedPrototype[ prop ] = (function() {
                var _super = function() {
                        return base.prototype[ prop ].apply( this, arguments );
                    },
                    _superApply = function( args ) {
                        return base.prototype[ prop ].apply( this, args );
                    };
                return function() {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply( this, arguments );

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend( basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if ( existingConstructor ) {
            $.each( existingConstructor._childConstructors, function( i, child ) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push( constructor );
        }

        $.widget.bridge( name, constructor );

        return constructor;
    };

    $.widget.extend = function( target ) {
        var input = widget_slice.call( arguments, 1 ),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for ( ; inputIndex < inputLength; inputIndex++ ) {
            for ( key in input[ inputIndex ] ) {
                value = input[ inputIndex ][ key ];
                if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
                    // Clone objects
                    if ( $.isPlainObject( value ) ) {
                        target[ key ] = $.isPlainObject( target[ key ] ) ?
                            $.widget.extend( {}, target[ key ], value ) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend( {}, value );
                    // Copy everything else by reference
                    } else {
                        target[ key ] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function( name, object ) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[ name ] = function( options ) {
            var isMethodCall = typeof options === "string",
                args = widget_slice.call( arguments, 1 ),
                returnValue = this;

            // allow multiple hashes to be passed on init
            options = !isMethodCall && args.length ?
                $.widget.extend.apply( null, [ options ].concat(args) ) :
                options;

            if ( isMethodCall ) {
                this.each(function() {
                    var methodValue,
                        instance = $.data( this, fullName );
                    if ( options === "instance" ) {
                        returnValue = instance;
                        return false;
                    }
                    if ( !instance ) {
                        return $.error( "cannot call methods on " + name + " prior to initialization; " +
                            "attempted to call method '" + options + "'" );
                    }
                    if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
                        return $.error( "no such method '" + options + "' for " + name + " widget instance" );
                    }
                    methodValue = instance[ options ].apply( instance, args );
                    if ( methodValue !== instance && methodValue !== undefined ) {
                        returnValue = methodValue && methodValue.jquery ?
                            returnValue.pushStack( methodValue.get() ) :
                            methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function() {
                    var instance = $.data( this, fullName );
                    if ( instance ) {
                        instance.option( options || {} );
                        if ( instance._init ) {
                            instance._init();
                        }
                    } else {
                        $.data( this, fullName, new object( options, this ) );
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function( /* options, element */ ) {};
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function( options, element ) {
            element = $( element || this.defaultElement || this )[ 0 ];
            this.element = $( element );
            this.uuid = widget_uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if ( element !== this ) {
                $.data( element, this.widgetFullName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                });
                this.document = $( element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element );
                this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
            }

            this.options = $.widget.extend( {},
                this.options,
                this._getCreateOptions(),
                options );

            this._create();
            this._trigger( "create", null, this._getCreateEventData() );
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function() {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .unbind( this.eventNamespace )
                .removeData( this.widgetFullName )
                // support: jquery <1.6.3
                // http://bugs.jquery.com/ticket/9413
                .removeData( $.camelCase( this.widgetFullName ) );
            this.widget()
                .unbind( this.eventNamespace )
                .removeAttr( "aria-disabled" )
                .removeClass(
                    this.widgetFullName + "-disabled " +
                    "ui-state-disabled" );

            // clean up events and states
            this.bindings.unbind( this.eventNamespace );
            this.hoverable.removeClass( "ui-state-hover" );
            this.focusable.removeClass( "ui-state-focus" );
        },
        _destroy: $.noop,

        widget: function() {
            return this.element;
        },

        option: function( key, value ) {
            var options = key,
                parts,
                curOption,
                i;

            if ( arguments.length === 0 ) {
                // don't return a reference to the internal hash
                return $.widget.extend( {}, this.options );
            }

            if ( typeof key === "string" ) {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }

            this._setOptions( options );

            return this;
        },
        _setOptions: function( options ) {
            var key;

            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }

            return this;
        },
        _setOption: function( key, value ) {
            this.options[ key ] = value;

            if ( key === "disabled" ) {
                this.widget()
                    .toggleClass( this.widgetFullName + "-disabled", !!value );

                // If the widget is becoming disabled, then nothing is interactive
                if ( value ) {
                    this.hoverable.removeClass( "ui-state-hover" );
                    this.focusable.removeClass( "ui-state-focus" );
                }
            }

            return this;
        },

        enable: function() {
            return this._setOptions({ disabled: false });
        },
        disable: function() {
            return this._setOptions({ disabled: true });
        },

        _on: function( suppressDisabledCheck, element, handlers ) {
            var delegateElement,
                instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if ( typeof suppressDisabledCheck !== "boolean" ) {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if ( !handlers ) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $( element );
                this.bindings = this.bindings.add( element );
            }

            $.each( handlers, function( event, handler ) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if ( !suppressDisabledCheck &&
                            ( instance.options.disabled === true ||
                                $( this ).hasClass( "ui-state-disabled" ) ) ) {
                        return;
                    }
                    return ( typeof handler === "string" ? instance[ handler ] : handler )
                        .apply( instance, arguments );
                }

                // copy the guid so direct unbinding works
                if ( typeof handler !== "string" ) {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
                    eventName = match[1] + instance.eventNamespace,
                    selector = match[2];
                if ( selector ) {
                    delegateElement.delegate( selector, eventName, handlerProxy );
                } else {
                    element.bind( eventName, handlerProxy );
                }
            });
        },

        _off: function( element, eventName ) {
            eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
                this.eventNamespace;
            element.unbind( eventName ).undelegate( eventName );

            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $( this.bindings.not( element ).get() );
            this.focusable = $( this.focusable.not( element ).get() );
            this.hoverable = $( this.hoverable.not( element ).get() );
        },

        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },

        _hoverable: function( element ) {
            this.hoverable = this.hoverable.add( element );
            this._on( element, {
                mouseenter: function( event ) {
                    $( event.currentTarget ).addClass( "ui-state-hover" );
                },
                mouseleave: function( event ) {
                    $( event.currentTarget ).removeClass( "ui-state-hover" );
                }
            });
        },

        _focusable: function( element ) {
            this.focusable = this.focusable.add( element );
            this._on( element, {
                focusin: function( event ) {
                    $( event.currentTarget ).addClass( "ui-state-focus" );
                },
                focusout: function( event ) {
                    $( event.currentTarget ).removeClass( "ui-state-focus" );
                }
            });
        },

        _trigger: function( type, event, data ) {
            var prop, orig,
                callback = this.options[ type ];

            data = data || {};
            event = $.Event( event );
            event.type = ( type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type ).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[ 0 ];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if ( orig ) {
                for ( prop in orig ) {
                    if ( !( prop in event ) ) {
                        event[ prop ] = orig[ prop ];
                    }
                }
            }

            this.element.trigger( event, data );
            return !( $.isFunction( callback ) &&
                callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
                event.isDefaultPrevented() );
        }
    };

    $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
        $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
            if ( typeof options === "string" ) {
                options = { effect: options };
            }
            var hasOptions,
                effectName = !options ?
                    method :
                    options === true || typeof options === "number" ?
                        defaultEffect :
                        options.effect || defaultEffect;
            options = options || {};
            if ( typeof options === "number" ) {
                options = { duration: options };
            }
            hasOptions = !$.isEmptyObject( options );
            options.complete = callback;
            if ( options.delay ) {
                element.delay( options.delay );
            }
            if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
                element[ method ]( options );
            } else if ( effectName !== method && element[ effectName ] ) {
                element[ effectName ]( options.duration, options.easing, callback );
            } else {
                element.queue(function( next ) {
                    $( this )[ method ]();
                    if ( callback ) {
                        callback.call( element[ 0 ] );
                    }
                    next();
                });
            }
        };
    });

    var widget = $.widget;


    /*!
     * jQuery UI Mouse 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/mouse/
     */


    var mouseHandled = false;
    $( document ).mouseup( function() {
        mouseHandled = false;
    });

    var mouse = $.widget("ui.mouse", {
        version: "1.11.2",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;

            this.element
                .bind("mousedown." + this.widgetName, function(event) {
                    return that._mouseDown(event);
                })
                .bind("click." + this.widgetName, function(event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName);
            if ( this._mouseMoveDelegate ) {
                this.document
                    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function(event) {
            // don't let more than one widget handle mouseStart
            if ( mouseHandled ) {
                return;
            }

            this._mouseMoved = false;

            // we may have missed mouseup (out of window)
            (this._mouseStarted && this._mouseUp(event));

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = (event.which === 1),
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = (this._mouseStart(event) !== false);
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }

            // these delegates are required to keep context
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event);
            };

            this.document
                .bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                .bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function(event) {
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if ( this._mouseMoved ) {
                // IE mouseup check - mouseup happened when mouse was out of window
                if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
                    return this._mouseUp(event);

                // Iframe mouseup check - mouseup occurred in another document
                } else if ( !event.which ) {
                    return this._mouseUp( event );
                }
            }

            if ( event.which || event.button ) {
                this._mouseMoved = true;
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    (this._mouseStart(this._mouseDownEvent, event) !== false);
                (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
            }

            return !this._mouseStarted;
        },

        _mouseUp: function(event) {
            this.document
                .unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                .unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }

                this._mouseStop(event);
            }

            mouseHandled = false;
            return false;
        },

        _mouseDistanceMet: function(event) {
            return (Math.max(
                    Math.abs(this._mouseDownEvent.pageX - event.pageX),
                    Math.abs(this._mouseDownEvent.pageY - event.pageY)
                ) >= this.options.distance
            );
        },

        _mouseDelayMet: function(/* event */) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function(/* event */) {},
        _mouseDrag: function(/* event */) {},
        _mouseStop: function(/* event */) {},
        _mouseCapture: function(/* event */) { return true; }
    });


    /*!
     * jQuery UI Position 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/position/
     */

    (function() {

    $.ui = $.ui || {};

    var cachedScrollbarWidth, supportsOffsetFractions,
        max = Math.max,
        abs = Math.abs,
        round = Math.round,
        rhorizontal = /left|center|right/,
        rvertical = /top|center|bottom/,
        roffset = /[\+\-]\d+(\.[\d]+)?%?/,
        rposition = /^\w+/,
        rpercent = /%$/,
        _position = $.fn.position;

    function getOffsets( offsets, width, height ) {
        return [
            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
        ];
    }

    function parseCss( element, property ) {
        return parseInt( $.css( element, property ), 10 ) || 0;
    }

    function getDimensions( elem ) {
        var raw = elem[0];
        if ( raw.nodeType === 9 ) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: 0, left: 0 }
            };
        }
        if ( $.isWindow( raw ) ) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
            };
        }
        if ( raw.preventDefault ) {
            return {
                width: 0,
                height: 0,
                offset: { top: raw.pageY, left: raw.pageX }
            };
        }
        return {
            width: elem.outerWidth(),
            height: elem.outerHeight(),
            offset: elem.offset()
        };
    }

    $.position = {
        scrollbarWidth: function() {
            if ( cachedScrollbarWidth !== undefined ) {
                return cachedScrollbarWidth;
            }
            var w1, w2,
                div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
                innerDiv = div.children()[0];

            $( "body" ).append( div );
            w1 = innerDiv.offsetWidth;
            div.css( "overflow", "scroll" );

            w2 = innerDiv.offsetWidth;

            if ( w1 === w2 ) {
                w2 = div[0].clientWidth;
            }

            div.remove();

            return (cachedScrollbarWidth = w1 - w2);
        },
        getScrollInfo: function( within ) {
            var overflowX = within.isWindow || within.isDocument ? "" :
                    within.element.css( "overflow-x" ),
                overflowY = within.isWindow || within.isDocument ? "" :
                    within.element.css( "overflow-y" ),
                hasOverflowX = overflowX === "scroll" ||
                    ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
                hasOverflowY = overflowY === "scroll" ||
                    ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
            return {
                width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                height: hasOverflowX ? $.position.scrollbarWidth() : 0
            };
        },
        getWithinInfo: function( element ) {
            var withinElement = $( element || window ),
                isWindow = $.isWindow( withinElement[0] ),
                isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
            return {
                element: withinElement,
                isWindow: isWindow,
                isDocument: isDocument,
                offset: withinElement.offset() || { left: 0, top: 0 },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),

                // support: jQuery 1.6.x
                // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
                width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
                height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
            };
        }
    };

    $.fn.position = function( options ) {
        if ( !options || !options.of ) {
            return _position.apply( this, arguments );
        }

        // make a copy, we don't want to modify arguments
        options = $.extend( {}, options );

        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
            target = $( options.of ),
            within = $.position.getWithinInfo( options.within ),
            scrollInfo = $.position.getScrollInfo( within ),
            collision = ( options.collision || "flip" ).split( " " ),
            offsets = {};

        dimensions = getDimensions( target );
        if ( target[0].preventDefault ) {
            // force left top to allow flipping
            options.at = "left top";
        }
        targetWidth = dimensions.width;
        targetHeight = dimensions.height;
        targetOffset = dimensions.offset;
        // clone to reuse original targetOffset later
        basePosition = $.extend( {}, targetOffset );

        // force my and at to have valid horizontal and vertical positions
        // if a value is missing or invalid, it will be converted to center
        $.each( [ "my", "at" ], function() {
            var pos = ( options[ this ] || "" ).split( " " ),
                horizontalOffset,
                verticalOffset;

            if ( pos.length === 1) {
                pos = rhorizontal.test( pos[ 0 ] ) ?
                    pos.concat( [ "center" ] ) :
                    rvertical.test( pos[ 0 ] ) ?
                        [ "center" ].concat( pos ) :
                        [ "center", "center" ];
            }
            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

            // calculate offsets
            horizontalOffset = roffset.exec( pos[ 0 ] );
            verticalOffset = roffset.exec( pos[ 1 ] );
            offsets[ this ] = [
                horizontalOffset ? horizontalOffset[ 0 ] : 0,
                verticalOffset ? verticalOffset[ 0 ] : 0
            ];

            // reduce to just the positions without the offsets
            options[ this ] = [
                rposition.exec( pos[ 0 ] )[ 0 ],
                rposition.exec( pos[ 1 ] )[ 0 ]
            ];
        });

        // normalize collision option
        if ( collision.length === 1 ) {
            collision[ 1 ] = collision[ 0 ];
        }

        if ( options.at[ 0 ] === "right" ) {
            basePosition.left += targetWidth;
        } else if ( options.at[ 0 ] === "center" ) {
            basePosition.left += targetWidth / 2;
        }

        if ( options.at[ 1 ] === "bottom" ) {
            basePosition.top += targetHeight;
        } else if ( options.at[ 1 ] === "center" ) {
            basePosition.top += targetHeight / 2;
        }

        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
        basePosition.left += atOffset[ 0 ];
        basePosition.top += atOffset[ 1 ];

        return this.each(function() {
            var collisionPosition, using,
                elem = $( this ),
                elemWidth = elem.outerWidth(),
                elemHeight = elem.outerHeight(),
                marginLeft = parseCss( this, "marginLeft" ),
                marginTop = parseCss( this, "marginTop" ),
                collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
                collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
                position = $.extend( {}, basePosition ),
                myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

            if ( options.my[ 0 ] === "right" ) {
                position.left -= elemWidth;
            } else if ( options.my[ 0 ] === "center" ) {
                position.left -= elemWidth / 2;
            }

            if ( options.my[ 1 ] === "bottom" ) {
                position.top -= elemHeight;
            } else if ( options.my[ 1 ] === "center" ) {
                position.top -= elemHeight / 2;
            }

            position.left += myOffset[ 0 ];
            position.top += myOffset[ 1 ];

            // if the browser doesn't support fractions, then round for consistent results
            if ( !supportsOffsetFractions ) {
                position.left = round( position.left );
                position.top = round( position.top );
            }

            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };

            $.each( [ "left", "top" ], function( i, dir ) {
                if ( $.ui.position[ collision[ i ] ] ) {
                    $.ui.position[ collision[ i ] ][ dir ]( position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    });
                }
            });

            if ( options.using ) {
                // adds feedback as second argument to using callback, if present
                using = function( props ) {
                    var left = targetOffset.left - position.left,
                        right = left + targetWidth - elemWidth,
                        top = targetOffset.top - position.top,
                        bottom = top + targetHeight - elemHeight,
                        feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                        feedback.horizontal = "center";
                    }
                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                        feedback.vertical = "middle";
                    }
                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call( this, props, feedback );
                };
            }

            elem.offset( $.extend( position, { using: using } ) );
        });
    };

    $.ui.position = {
        fit: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                    outerWidth = within.width,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = withinOffset - collisionPosLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                    newOverRight;

                // element is wider than within
                if ( data.collisionWidth > outerWidth ) {
                    // element is initially over the left side of within
                    if ( overLeft > 0 && overRight <= 0 ) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                        position.left += overLeft - newOverRight;
                    // element is initially over right side of within
                    } else if ( overRight > 0 && overLeft <= 0 ) {
                        position.left = withinOffset;
                    // element is initially over both left and right sides of within
                    } else {
                        if ( overLeft > overRight ) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }
                // too far left -> align with left edge
                } else if ( overLeft > 0 ) {
                    position.left += overLeft;
                // too far right -> align with right edge
                } else if ( overRight > 0 ) {
                    position.left -= overRight;
                // adjust based on position and margin
                } else {
                    position.left = max( position.left - collisionPosLeft, position.left );
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                    outerHeight = data.within.height,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = withinOffset - collisionPosTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                    newOverBottom;

                // element is taller than within
                if ( data.collisionHeight > outerHeight ) {
                    // element is initially over the top of within
                    if ( overTop > 0 && overBottom <= 0 ) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                        position.top += overTop - newOverBottom;
                    // element is initially over bottom of within
                    } else if ( overBottom > 0 && overTop <= 0 ) {
                        position.top = withinOffset;
                    // element is initially over both top and bottom of within
                    } else {
                        if ( overTop > overBottom ) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }
                // too far up -> align with top
                } else if ( overTop > 0 ) {
                    position.top += overTop;
                // too far down -> align with bottom edge
                } else if ( overBottom > 0 ) {
                    position.top -= overBottom;
                // adjust based on position and margin
                } else {
                    position.top = max( position.top - collisionPosTop, position.top );
                }
            }
        },
        flip: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.left + within.scrollLeft,
                    outerWidth = within.width,
                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = collisionPosLeft - offsetLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                    myOffset = data.my[ 0 ] === "left" ?
                        -data.elemWidth :
                        data.my[ 0 ] === "right" ?
                            data.elemWidth :
                            0,
                    atOffset = data.at[ 0 ] === "left" ?
                        data.targetWidth :
                        data.at[ 0 ] === "right" ?
                            -data.targetWidth :
                            0,
                    offset = -2 * data.offset[ 0 ],
                    newOverRight,
                    newOverLeft;

                if ( overLeft < 0 ) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                        position.left += myOffset + atOffset + offset;
                    }
                } else if ( overRight > 0 ) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.top + within.scrollTop,
                    outerHeight = within.height,
                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = collisionPosTop - offsetTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                    top = data.my[ 1 ] === "top",
                    myOffset = top ?
                        -data.elemHeight :
                        data.my[ 1 ] === "bottom" ?
                            data.elemHeight :
                            0,
                    atOffset = data.at[ 1 ] === "top" ?
                        data.targetHeight :
                        data.at[ 1 ] === "bottom" ?
                            -data.targetHeight :
                            0,
                    offset = -2 * data.offset[ 1 ],
                    newOverTop,
                    newOverBottom;
                if ( overTop < 0 ) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                    if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
                        position.top += myOffset + atOffset + offset;
                    }
                } else if ( overBottom > 0 ) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                    if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function() {
                $.ui.position.flip.left.apply( this, arguments );
                $.ui.position.fit.left.apply( this, arguments );
            },
            top: function() {
                $.ui.position.flip.top.apply( this, arguments );
                $.ui.position.fit.top.apply( this, arguments );
            }
        }
    };

    // fraction support test
    (function() {
        var testElement, testElementParent, testElementStyle, offsetLeft, i,
            body = document.getElementsByTagName( "body" )[ 0 ],
            div = document.createElement( "div" );

        //Create a "fake body" for testing based on method used in jQuery.support
        testElement = document.createElement( body ? "div" : "body" );
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        };
        if ( body ) {
            $.extend( testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
        }
        for ( i in testElementStyle ) {
            testElement.style[ i ] = testElementStyle[ i ];
        }
        testElement.appendChild( div );
        testElementParent = body || document.documentElement;
        testElementParent.insertBefore( testElement, testElementParent.firstChild );

        div.style.cssText = "position: absolute; left: 10.7432222px;";

        offsetLeft = $( div ).offset().left;
        supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

        testElement.innerHTML = "";
        testElementParent.removeChild( testElement );
    })();

    })();

    var position = $.ui.position;


    /*!
     * jQuery UI Draggable 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/draggable/
     */


    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.11.2",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {

            if ( this.options.helper === "original" ) {
                this._setPositionRelative();
            }
            if (this.options.addClasses){
                this.element.addClass("ui-draggable");
            }
            if (this.options.disabled){
                this.element.addClass("ui-draggable-disabled");
            }
            this._setHandleClassName();

            this._mouseInit();
        },

        _setOption: function( key, value ) {
            this._super( key, value );
            if ( key === "handle" ) {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },

        _destroy: function() {
            if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
                this.destroyOnClear = true;
                return;
            }
            this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
            this._removeHandleClassName();
            this._mouseDestroy();
        },

        _mouseCapture: function(event) {
            var o = this.options;

            this._blurActiveElement( event );

            // among others, prevent a drag on a resizable-handle
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }

            this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

            return true;

        },

        _blockFrames: function( selector ) {
            this.iframeBlocks = this.document.find( selector ).map(function() {
                var iframe = $( this );

                return $( "<div>" )
                    .css( "position", "absolute" )
                    .appendTo( iframe.parent() )
                    .outerWidth( iframe.outerWidth() )
                    .outerHeight( iframe.outerHeight() )
                    .offset( iframe.offset() )[ 0 ];
            });
        },

        _unblockFrames: function() {
            if ( this.iframeBlocks ) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _blurActiveElement: function( event ) {
            var document = this.document[ 0 ];

            // Only need to blur if the event occurred on the draggable itself, see #10527
            if ( !this.handleElement.is( event.target ) ) {
                return;
            }

            // support: IE9
            // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
            try {

                // Support: IE9, IE10
                // If the <body> is blurred, IE will switch windows, see #9520
                if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

                    // Blur any element that currently has focus, see #4261
                    $( document.activeElement ).blur();
                }
            } catch ( error ) {}
        },

        _mouseStart: function(event) {

            var o = this.options;

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            this.helper.addClass("ui-draggable-dragging");

            //Cache the helper size
            this._cacheHelperProportions();

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Store the helper's css position
            this.cssPosition = this.helper.css( "position" );
            this.scrollParent = this.helper.scrollParent( true );
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter(function() {
                    return $( this ).css( "position" ) === "fixed";
                }).length > 0;

            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset();
            this._refreshOffsets( event );

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition( event, false );
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Set a containment if given in the options
            this._setContainment();

            //Trigger event + callbacks
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }

            //Recache the helper size
            this._cacheHelperProportions();

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            // Reset helper's right/bottom css if they're set and set explicit width/height instead
            // as this prevents resizing of elements with right/bottom set (see #7772)
            this._normalizeRightBottom();

            this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

            //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.dragStart(this, event);
            }

            return true;
        },

        _refreshOffsets: function( event ) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };

            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },

        _mouseDrag: function(event, noPropagation) {
            // reset any necessary cached properties (see #5009)
            if ( this.hasFixedAncestor ) {
                this.offset.parent = this._getParentOffset();
            }

            //Compute the helpers position
            this.position = this._generatePosition( event, true );
            this.positionAbs = this._convertPositionTo("absolute");

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp({});
                    return false;
                }
                this.position = ui.position;
            }

            this.helper[ 0 ].style.left = this.position.left + "px";
            this.helper[ 0 ].style.top = this.position.top + "px";

            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            return false;
        },

        _mouseStop: function(event) {

            //If we are using droppables, inform the manager about the drop
            var that = this,
                dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }

            if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                    if (that._trigger("stop", event) !== false) {
                        that._clear();
                    }
                });
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }

            return false;
        },

        _mouseUp: function( event ) {
            this._unblockFrames();

            //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.dragStop(this, event);
            }

            // Only need to focus if the event occurred on the draggable itself, see #10527
            if ( this.handleElement.is( event.target ) ) {
                // The interaction is over; whether or not the click resulted in a drag, focus the element
                this.element.focus();
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },

        cancel: function() {

            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp({});
            } else {
                this._clear();
            }

            return this;

        },

        _getHandle: function(event) {
            return this.options.handle ?
                !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
                true;
        },

        _setHandleClassName: function() {
            this.handleElement = this.options.handle ?
                this.element.find( this.options.handle ) : this.element;
            this.handleElement.addClass( "ui-draggable-handle" );
        },

        _removeHandleClassName: function() {
            this.handleElement.removeClass( "ui-draggable-handle" );
        },

        _createHelper: function(event) {

            var o = this.options,
                helperIsFunction = $.isFunction( o.helper ),
                helper = helperIsFunction ?
                    $( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
                    ( o.helper === "clone" ?
                        this.element.clone().removeAttr( "id" ) :
                        this.element );

            if (!helper.parents("body").length) {
                helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
            }

            // http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
                this._setPositionRelative();
            }

            if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                helper.css("position", "absolute");
            }

            return helper;

        },

        _setPositionRelative: function() {
            if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
                this.element[ 0 ].style.position = "relative";
            }
        },

        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _isRootNode: function( element ) {
            return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
        },

        _getParentOffset: function() {

            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
                document = this.document[ 0 ];

            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
                po = { top: 0, left: 0 };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function() {
            if ( this.cssPosition !== "relative" ) {
                return { top: 0, left: 0 };
            }

            var p = this.element.position(),
                scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

            return {
                top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
                left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
            };

        },

        _cacheMargins: function() {
            this.margins = {
                left: (parseInt(this.element.css("marginLeft"), 10) || 0),
                top: (parseInt(this.element.css("marginTop"), 10) || 0),
                right: (parseInt(this.element.css("marginRight"), 10) || 0),
                bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
            };
        },

        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function() {

            var isUserScrollable, c, ce,
                o = this.options,
                document = this.document[ 0 ];

            this.relativeContainer = null;

            if ( !o.containment ) {
                this.containment = null;
                return;
            }

            if ( o.containment === "window" ) {
                this.containment = [
                    $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                    $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                    $( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
                    $( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
                ];
                return;
            }

            if ( o.containment === "document") {
                this.containment = [
                    0,
                    0,
                    $( document ).width() - this.helperProportions.width - this.margins.left,
                    ( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
                ];
                return;
            }

            if ( o.containment.constructor === Array ) {
                this.containment = o.containment;
                return;
            }

            if ( o.containment === "parent" ) {
                o.containment = this.helper[ 0 ].parentNode;
            }

            c = $( o.containment );
            ce = c[ 0 ];

            if ( !ce ) {
                return;
            }

            isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

            this.containment = [
                ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
                ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
                ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
                    ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
                    ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
                    this.helperProportions.width -
                    this.margins.left -
                    this.margins.right,
                ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
                    ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
                    ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
                    this.helperProportions.height -
                    this.margins.top -
                    this.margins.bottom
            ];
            this.relativeContainer = c;
        },

        _convertPositionTo: function(d, pos) {

            if (!pos) {
                pos = this.position;
            }

            var mod = d === "absolute" ? 1 : -1,
                scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

            return {
                top: (
                    pos.top +                                                               // The absolute mouse position
                    this.offset.relative.top * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod -                                      // The offsetParent's offset without borders (offset + border)
                    ( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
                ),
                left: (
                    pos.left +                                                              // The absolute mouse position
                    this.offset.relative.left * mod +                                       // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod   -                                       // The offsetParent's offset without borders (offset + border)
                    ( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
                )
            };

        },

        _generatePosition: function( event, constrainPosition ) {

            var containment, co, top, left,
                o = this.options,
                scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
                pageX = event.pageX,
                pageY = event.pageY;

            // Cache the scroll
            if ( !scrollIsRootNode || !this.offset.scroll ) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft()
                };
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            // If we are not dragging yet, we won't check for options
            if ( constrainPosition ) {
                if ( this.containment ) {
                    if ( this.relativeContainer ){
                        co = this.relativeContainer.offset();
                        containment = [
                            this.containment[ 0 ] + co.left,
                            this.containment[ 1 ] + co.top,
                            this.containment[ 2 ] + co.left,
                            this.containment[ 3 ] + co.top
                        ];
                    } else {
                        containment = this.containment;
                    }

                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                }

                if ( o.axis === "y" ) {
                    pageX = this.originalPageX;
                }

                if ( o.axis === "x" ) {
                    pageY = this.originalPageY;
                }
            }

            return {
                top: (
                    pageY -                                                                 // The absolute mouse position
                    this.offset.click.top   -                                               // Click offset (relative to the element)
                    this.offset.relative.top -                                              // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top +                                                // The offsetParent's offset without borders (offset + border)
                    ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
                ),
                left: (
                    pageX -                                                                 // The absolute mouse position
                    this.offset.click.left -                                                // Click offset (relative to the element)
                    this.offset.relative.left -                                             // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left +                                               // The offsetParent's offset without borders (offset + border)
                    ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
                )
            };

        },

        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if ( this.destroyOnClear ) {
                this.destroy();
            }
        },

        _normalizeRightBottom: function() {
            if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
                this.helper.width( this.helper.width() );
                this.helper.css( "right", "auto" );
            }
            if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
                this.helper.height( this.helper.height() );
                this.helper.css( "bottom", "auto" );
            }
        },

        // From now on bulk stuff - mainly helpers

        _trigger: function( type, event, ui ) {
            ui = ui || this._uiHash();
            $.ui.plugin.call( this, type, [ event, ui, this ], true );

            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if ( /^(drag|start|stop)/.test( type ) ) {
                this.positionAbs = this._convertPositionTo( "absolute" );
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call( this, type, event, ui );
        },

        plugins: {},

        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }

    });

    $.ui.plugin.add( "draggable", "connectToSortable", {
        start: function( event, ui, draggable ) {
            var uiSortable = $.extend( {}, ui, {
                item: draggable.element
            });

            draggable.sortables = [];
            $( draggable.options.connectToSortable ).each(function() {
                var sortable = $( this ).sortable( "instance" );

                if ( sortable && !sortable.options.disabled ) {
                    draggable.sortables.push( sortable );

                    // refreshPositions is called at drag start to refresh the containerCache
                    // which is used in drag. This ensures it's initialized and synchronized
                    // with any changes that might have happened on the page since initialization.
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function( event, ui, draggable ) {
            var uiSortable = $.extend( {}, ui, {
                item: draggable.element
            });

            draggable.cancelHelperRemoval = false;

            $.each( draggable.sortables, function() {
                var sortable = this;

                if ( sortable.isOver ) {
                    sortable.isOver = 0;

                    // Allow this sortable to handle removing the helper
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;

                    // Use _storedCSS To restore properties in the sortable,
                    // as this also handles revert (#9675) since the draggable
                    // may have modified them in unexpected ways (#8809)
                    sortable._storedCSS = {
                        position: sortable.placeholder.css( "position" ),
                        top: sortable.placeholder.css( "top" ),
                        left: sortable.placeholder.css( "left" )
                    };

                    sortable._mouseStop(event);

                    // Once drag has ended, the sortable should return to using
                    // its original helper, not the shared helper from draggable
                    sortable.options.helper = sortable.options._helper;
                } else {
                    // Prevent this Sortable from removing the helper.
                    // However, don't set the draggable to remove the helper
                    // either as another connected Sortable may yet handle the removal.
                    sortable.cancelHelperRemoval = true;

                    sortable._trigger( "deactivate", event, uiSortable );
                }
            });
        },
        drag: function( event, ui, draggable ) {
            $.each( draggable.sortables, function() {
                var innermostIntersecting = false,
                    sortable = this;

                // Copy over variables that sortable's _intersectsWith uses
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;

                if ( sortable._intersectsWith( sortable.containerCache ) ) {
                    innermostIntersecting = true;

                    $.each( draggable.sortables, function() {
                        // Copy over variables that sortable's _intersectsWith uses
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;

                        if ( this !== sortable &&
                                this._intersectsWith( this.containerCache ) &&
                                $.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
                            innermostIntersecting = false;
                        }

                        return innermostIntersecting;
                    });
                }

                if ( innermostIntersecting ) {
                    // If it intersects, we use a little isOver variable and set it once,
                    // so that the move-in stuff gets fired only once.
                    if ( !sortable.isOver ) {
                        sortable.isOver = 1;

                        sortable.currentItem = ui.helper
                            .appendTo( sortable.element )
                            .data( "ui-sortable-item", true );

                        // Store helper option to later restore it
                        sortable.options._helper = sortable.options.helper;

                        sortable.options.helper = function() {
                            return ui.helper[ 0 ];
                        };

                        // Fire the start events of the sortable with our passed browser event,
                        // and our own helper (so it doesn't create a new one)
                        event.target = sortable.currentItem[ 0 ];
                        sortable._mouseCapture( event, true );
                        sortable._mouseStart( event, true, true );

                        // Because the browser event is way off the new appended portlet,
                        // modify necessary variables to reflect the changes
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left -
                            sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top -
                            sortable.offset.parent.top;

                        draggable._trigger( "toSortable", event );

                        // Inform draggable that the helper is in a valid drop zone,
                        // used solely in the revert option to handle "valid/invalid".
                        draggable.dropped = sortable.element;

                        // Need to refreshPositions of all sortables in the case that
                        // adding to one sortable changes the location of the other sortables (#9675)
                        $.each( draggable.sortables, function() {
                            this.refreshPositions();
                        });

                        // hack so receive/update callbacks work (mostly)
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }

                    if ( sortable.currentItem ) {
                        sortable._mouseDrag( event );
                        // Copy the sortable's position because the draggable's can potentially reflect
                        // a relative position, while sortable is always absolute, which the dragged
                        // element has now become. (#8809)
                        ui.position = sortable.position;
                    }
                } else {
                    // If it doesn't intersect with the sortable, and it intersected before,
                    // we fake the drag stop of the sortable, but make sure it doesn't remove
                    // the helper by using cancelHelperRemoval.
                    if ( sortable.isOver ) {

                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;

                        // Calling sortable's mouseStop would trigger a revert,
                        // so revert must be temporarily false until after mouseStop is called.
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;

                        sortable._trigger( "out", event, sortable._uiHash( sortable ) );
                        sortable._mouseStop( event, true );

                        // restore sortable behaviors that were modfied
                        // when the draggable entered the sortable area (#9481)
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;

                        if ( sortable.placeholder ) {
                            sortable.placeholder.remove();
                        }

                        // Recalculate the draggable's offset considering the sortable
                        // may have modified them in unexpected ways (#8809)
                        draggable._refreshOffsets( event );
                        ui.position = draggable._generatePosition( event, true );

                        draggable._trigger( "fromSortable", event );

                        // Inform draggable that the helper is no longer in a valid drop zone
                        draggable.dropped = false;

                        // Need to refreshPositions of all sortables just in case removing
                        // from one sortable changes the location of other sortables (#9675)
                        $.each( draggable.sortables, function() {
                            this.refreshPositions();
                        });
                    }
                }
            });
        }
    });

    $.ui.plugin.add("draggable", "cursor", {
        start: function( event, ui, instance ) {
            var t = $( "body" ),
                o = instance.options;

            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function( event, ui, instance ) {
            var o = instance.options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });

    $.ui.plugin.add("draggable", "opacity", {
        start: function( event, ui, instance ) {
            var t = $( ui.helper ),
                o = instance.options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function( event, ui, instance ) {
            var o = instance.options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });

    $.ui.plugin.add("draggable", "scroll", {
        start: function( event, ui, i ) {
            if ( !i.scrollParentNotHidden ) {
                i.scrollParentNotHidden = i.helper.scrollParent( false );
            }

            if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function( event, ui, i  ) {

            var o = i.options,
                scrolled = false,
                scrollParent = i.scrollParentNotHidden[ 0 ],
                document = i.document[ 0 ];

            if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
                if ( !o.axis || o.axis !== "x" ) {
                    if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                    } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    }
                }

                if ( !o.axis || o.axis !== "y" ) {
                    if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                    } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }

            } else {

                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }

            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }

        }
    });

    $.ui.plugin.add("draggable", "snap", {
        start: function( event, ui, i ) {

            var o = i.options;

            i.snapElements = [];

            $(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
                var $t = $(this),
                    $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(), height: $t.outerHeight(),
                        top: $o.top, left: $o.left
                    });
                }
            });

        },
        drag: function( event, ui, inst ) {

            var ts, bs, ls, rs, l, r, t, b, i, first,
                o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

            for (i = inst.snapElements.length - 1; i >= 0; i--){

                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;

                if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
                    if (inst.snapElements[i].snapping) {
                        (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }

                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
                    }
                }

                first = (ts || bs || ls || rs);

                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
                    }
                }

                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                }
                inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

            }

        }
    });

    $.ui.plugin.add("draggable", "stack", {
        start: function( event, ui, instance ) {
            var min,
                o = instance.options,
                group = $.makeArray($(o.stack)).sort(function(a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
                });

            if (!group.length) { return; }

            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function(i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", (min + group.length));
        }
    });

    $.ui.plugin.add("draggable", "zIndex", {
        start: function( event, ui, instance ) {
            var t = $( ui.helper ),
                o = instance.options;

            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function( event, ui, instance ) {
            var o = instance.options;

            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });

    var draggable = $.ui.draggable;


    /*!
     * jQuery UI Resizable 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/resizable/
     */


    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.11.2",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            // See #7960
            zIndex: 90,

            // callbacks
            resize: null,
            start: null,
            stop: null
        },

        _num: function( value ) {
            return parseInt( value, 10 ) || 0;
        },

        _isNumber: function( value ) {
            return !isNaN( parseInt( value, 10 ) );
        },

        _hasScroll: function( el, a ) {

            if ( $( el ).css( "overflow" ) === "hidden") {
                return false;
            }

            var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
                has = false;

            if ( el[ scroll ] > 0 ) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[ scroll ] = 1;
            has = ( el[ scroll ] > 0 );
            el[ scroll ] = 0;
            return has;
        },

        _create: function() {

            var n, i, handle, axis, hname,
                that = this,
                o = this.options;
            this.element.addClass("ui-resizable");

            $.extend(this, {
                _aspectRatio: !!(o.aspectRatio),
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });

            // Wrap the element if it cannot hold child nodes
            if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

                this.element.wrap(
                    $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    })
                );

                this.element = this.element.parent().data(
                    "ui-resizable", this.element.resizable( "instance" )
                );

                this.elementIsWrapper = true;

                this.element.css({
                    marginLeft: this.originalElement.css("marginLeft"),
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom")
                });
                this.originalElement.css({
                    marginLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                });
                // support: Safari
                // Prevent Safari textarea resize
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");

                this._proportionallyResizeElements.push( this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }) );

                // support: IE9
                // avoid IE jump (hard set the margin)
                this.originalElement.css({ margin: this.originalElement.css("margin") });

                this._proportionallyResize();
            }

            this.handles = o.handles ||
                ( !$(".ui-resizable-handle", this.element).length ?
                    "e,s,se" : {
                        n: ".ui-resizable-n",
                        e: ".ui-resizable-e",
                        s: ".ui-resizable-s",
                        w: ".ui-resizable-w",
                        se: ".ui-resizable-se",
                        sw: ".ui-resizable-sw",
                        ne: ".ui-resizable-ne",
                        nw: ".ui-resizable-nw"
                    } );

            if (this.handles.constructor === String) {

                if ( this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }

                n = this.handles.split(",");
                this.handles = {};

                for (i = 0; i < n.length; i++) {

                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

                    axis.css({ zIndex: o.zIndex });

                    // TODO : What's going on here?
                    if ("se" === handle) {
                        axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                    }

                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }

            }

            this._renderAxis = function(target) {

                var i, axis, padPos, padWrapper;

                target = target || this.element;

                for (i in this.handles) {

                    if (this.handles[i].constructor === String) {
                        this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
                    }

                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

                        axis = $(this.handles[i], this.element);

                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

                        padPos = [ "padding",
                            /ne|nw|n/.test(i) ? "Top" :
                            /se|sw|s/.test(i) ? "Bottom" :
                            /^e$/.test(i) ? "Right" : "Left" ].join("");

                        target.css(padPos, padWrapper);

                        this._proportionallyResize();

                    }

                    // TODO: What's that good for? There's not anything to be executed left
                    if (!$(this.handles[i]).length) {

                    }
                }
            };

            // TODO: make renderAxis a prototype function
            this._renderAxis(this.element);

            this._handles = $(".ui-resizable-handle", this.element)
                .disableSelection();

            this._handles.mouseover(function() {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });

            if (o.autoHide) {
                this._handles.hide();
                $(this.element)
                    .addClass("ui-resizable-autohide")
                    .mouseenter(function() {
                        if (o.disabled) {
                            return;
                        }
                        $(this).removeClass("ui-resizable-autohide");
                        that._handles.show();
                    })
                    .mouseleave(function() {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            $(this).addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
            }

            this._mouseInit();

        },

        _destroy: function() {

            this._mouseDestroy();

            var wrapper,
                _destroy = function(exp) {
                    $(exp)
                        .removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
                        .removeData("resizable")
                        .removeData("ui-resizable")
                        .unbind(".resizable")
                        .find(".ui-resizable-handle")
                            .remove();
                };

            // TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter( wrapper );
                wrapper.remove();
            }

            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);

            return this;
        },

        _mouseCapture: function(event) {
            var i, handle,
                capture = false;

            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }

            return !this.options.disabled && capture;
        },

        _mouseStart: function(event) {

            var curleft, curtop, cursor,
                o = this.options,
                el = this.element;

            this.resizing = true;

            this._renderProxy();

            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));

            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }

            this.offset = this.helper.offset();
            this.position = { left: curleft, top: curtop };

            this.size = this._helper ? {
                    width: this.helper.width(),
                    height: this.helper.height()
                } : {
                    width: el.width(),
                    height: el.height()
                };

            this.originalSize = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                };

            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };

            this.originalPosition = { left: curleft, top: curtop };
            this.originalMousePosition = { left: event.pageX, top: event.pageY };

            this.aspectRatio = (typeof o.aspectRatio === "number") ?
                o.aspectRatio :
                ((this.originalSize.width / this.originalSize.height) || 1);

            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

            el.addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },

        _mouseDrag: function(event) {

            var data, props,
                smp = this.originalMousePosition,
                a = this.axis,
                dx = (event.pageX - smp.left) || 0,
                dy = (event.pageY - smp.top) || 0,
                trigger = this._change[a];

            this._updatePrevProperties();

            if (!trigger) {
                return false;
            }

            data = trigger.apply(this, [ event, dx, dy ]);

            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }

            data = this._respectSize(data, event);

            this._updateCache(data);

            this._propagate("resize", event);

            props = this._applyChanges();

            if ( !this._helper && this._proportionallyResizeElements.length ) {
                this._proportionallyResize();
            }

            if ( !$.isEmptyObject( props ) ) {
                this._updatePrevProperties();
                this._trigger( "resize", event, this.ui() );
                this._applyChanges();
            }

            return false;
        },

        _mouseStop: function(event) {

            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top,
                o = this.options, that = this;

            if (this._helper) {

                pr = this._proportionallyResizeElements;
                ista = pr.length && (/textarea/i).test(pr[0].nodeName);
                soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;

                s = {
                    width: (that.helper.width()  - soffsetw),
                    height: (that.helper.height() - soffseth)
                };
                left = (parseInt(that.element.css("left"), 10) +
                    (that.position.left - that.originalPosition.left)) || null;
                top = (parseInt(that.element.css("top"), 10) +
                    (that.position.top - that.originalPosition.top)) || null;

                if (!o.animate) {
                    this.element.css($.extend(s, { top: top, left: left }));
                }

                that.helper.height(that.size.height);
                that.helper.width(that.size.width);

                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }

            $("body").css("cursor", "auto");

            this.element.removeClass("ui-resizable-resizing");

            this._propagate("stop", event);

            if (this._helper) {
                this.helper.remove();
            }

            return false;

        },

        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },

        _applyChanges: function() {
            var props = {};

            if ( this.position.top !== this.prevPosition.top ) {
                props.top = this.position.top + "px";
            }
            if ( this.position.left !== this.prevPosition.left ) {
                props.left = this.position.left + "px";
            }
            if ( this.size.width !== this.prevSize.width ) {
                props.width = this.size.width + "px";
            }
            if ( this.size.height !== this.prevSize.height ) {
                props.height = this.size.height + "px";
            }

            this.helper.css( props );

            return props;
        },

        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                o = this.options;

            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };

            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;

                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },

        _updateCache: function(data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (this._isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (this._isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (this._isNumber(data.width)) {
                this.size.width = data.width;
            }
        },

        _updateRatio: function( data ) {

            var cpos = this.position,
                csize = this.size,
                a = this.axis;

            if (this._isNumber(data.height)) {
                data.width = (data.height * this.aspectRatio);
            } else if (this._isNumber(data.width)) {
                data.height = (data.width / this.aspectRatio);
            }

            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }

            return data;
        },

        _respectSize: function( data ) {

            var o = this._vBoundaries,
                a = this.axis,
                ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
                ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
                isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
                isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.position.top + this.size.height,
                cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }

            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }

            // Fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }

            return data;
        },

        _getPaddingPlusBorderDimensions: function( element ) {
            var i = 0,
                widths = [],
                borders = [
                    element.css( "borderTopWidth" ),
                    element.css( "borderRightWidth" ),
                    element.css( "borderBottomWidth" ),
                    element.css( "borderLeftWidth" )
                ],
                paddings = [
                    element.css( "paddingTop" ),
                    element.css( "paddingRight" ),
                    element.css( "paddingBottom" ),
                    element.css( "paddingLeft" )
                ];

            for ( ; i < 4; i++ ) {
                widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
                widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
            }

            return {
                height: widths[ 0 ] + widths[ 2 ],
                width: widths[ 1 ] + widths[ 3 ]
            };
        },

        _proportionallyResize: function() {

            if (!this._proportionallyResizeElements.length) {
                return;
            }

            var prel,
                i = 0,
                element = this.helper || this.element;

            for ( ; i < this._proportionallyResizeElements.length; i++) {

                prel = this._proportionallyResizeElements[i];

                // TODO: Seems like a bug to cache this.outerDimensions
                // considering that we are in a loop.
                if (!this.outerDimensions) {
                    this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
                }

                prel.css({
                    height: (element.height() - this.outerDimensions.height) || 0,
                    width: (element.width() - this.outerDimensions.width) || 0
                });

            }

        },

        _renderProxy: function() {

            var el = this.element, o = this.options;
            this.elementOffset = el.offset();

            if (this._helper) {

                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

                this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() - 1,
                    height: this.element.outerHeight() - 1,
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex //TODO: Don't modify option
                });

                this.helper
                    .appendTo("body")
                    .disableSelection();

            } else {
                this.helper = this.element;
            }

        },

        _change: {
            e: function(event, dx) {
                return { width: this.originalSize.width + dx };
            },
            w: function(event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { left: sp.left + dx, width: cs.width - dx };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { top: sp.top + dy, height: cs.height - dy };
            },
            s: function(event, dx, dy) {
                return { height: this.originalSize.height + dy };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments),
                    this._change.e.apply(this, [ event, dx, dy ]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments),
                    this._change.w.apply(this, [ event, dx, dy ]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments),
                    this._change.e.apply(this, [ event, dx, dy ]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments),
                    this._change.w.apply(this, [ event, dx, dy ]));
            }
        },

        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [ event, this.ui() ]);
            (n !== "resize" && this._trigger(n, event, this.ui()));
        },

        plugins: {},

        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }

    });

    /*
     * Resizable Extensions
     */

    $.ui.plugin.add("resizable", "animate", {

        stop: function( event ) {
            var that = $(this).resizable( "instance" ),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && (/textarea/i).test(pr[0].nodeName),
                soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
                left = (parseInt(that.element.css("left"), 10) +
                    (that.position.left - that.originalPosition.left)) || null,
                top = (parseInt(that.element.css("top"), 10) +
                    (that.position.top - that.originalPosition.top)) || null;

            that.element.animate(
                $.extend(style, top && left ? { top: top, left: left } : {}), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function() {

                        var data = {
                            width: parseInt(that.element.css("width"), 10),
                            height: parseInt(that.element.css("height"), 10),
                            top: parseInt(that.element.css("top"), 10),
                            left: parseInt(that.element.css("left"), 10)
                        };

                        if (pr && pr.length) {
                            $(pr[0]).css({ width: data.width, height: data.height });
                        }

                        // propagating resize, and updating values for each animation step
                        that._updateCache(data);
                        that._propagate("resize", event);

                    }
                }
            );
        }

    });

    $.ui.plugin.add( "resizable", "containment", {

        start: function() {
            var element, p, co, ch, cw, width, height,
                that = $( this ).resizable( "instance" ),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

            if ( !ce ) {
                return;
            }

            that.containerElement = $( ce );

            if ( /document/.test( oc ) || oc === document ) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };

                that.parentData = {
                    element: $( document ),
                    left: 0,
                    top: 0,
                    width: $( document ).width(),
                    height: $( document ).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $( ce );
                p = [];
                $([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
                    p[ i ] = that._num( element.css( "padding" + name ) );
                });

                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: ( element.innerHeight() - p[ 3 ] ),
                    width: ( element.innerWidth() - p[ 1 ] )
                };

                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
                height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },

        resize: function( event ) {
            var woset, hoset, isParent, isOffsetRelative,
                that = $( this ).resizable( "instance" ),
                o = that.options,
                co = that.containerOffset,
                cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = {
                    top: 0,
                    left: 0
                },
                ce = that.containerElement,
                continueResize = true;

            if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
                cop = co;
            }

            if ( cp.left < ( that._helper ? co.left : 0 ) ) {
                that.size.width = that.size.width +
                    ( that._helper ?
                        ( that.position.left - co.left ) :
                        ( that.position.left - cop.left ) );

                if ( pRatio ) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }

            if ( cp.top < ( that._helper ? co.top : 0 ) ) {
                that.size.height = that.size.height +
                    ( that._helper ?
                        ( that.position.top - co.top ) :
                        that.position.top );

                if ( pRatio ) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }

            isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
            isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

            if ( isParent && isOffsetRelative ) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }

            woset = Math.abs( that.sizeDiff.width +
                (that._helper ?
                    that.offset.left - cop.left :
                    (that.offset.left - co.left)) );

            hoset = Math.abs( that.sizeDiff.height +
                (that._helper ?
                    that.offset.top - cop.top :
                    (that.offset.top - co.top)) );

            if ( woset + that.size.width >= that.parentData.width ) {
                that.size.width = that.parentData.width - woset;
                if ( pRatio ) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }

            if ( hoset + that.size.height >= that.parentData.height ) {
                that.size.height = that.parentData.height - hoset;
                if ( pRatio ) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }

            if ( !continueResize ){
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },

        stop: function() {
            var that = $( this ).resizable( "instance" ),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $( that.helper ),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;

            if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
                $( this ).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }

            if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
                $( this ).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
        }
    });

    $.ui.plugin.add("resizable", "alsoResize", {

        start: function() {
            var that = $(this).resizable( "instance" ),
                o = that.options,
                _store = function(exp) {
                    $(exp).each(function() {
                        var el = $(this);
                        el.data("ui-resizable-alsoresize", {
                            width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
                            left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
                        });
                    });
                };

            if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
                if (o.alsoResize.length) {
                    o.alsoResize = o.alsoResize[0];
                    _store(o.alsoResize);
                } else {
                    $.each(o.alsoResize, function(exp) {
                        _store(exp);
                    });
                }
            } else {
                _store(o.alsoResize);
            }
        },

        resize: function(event, ui) {
            var that = $(this).resizable( "instance" ),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: (that.size.height - os.height) || 0,
                    width: (that.size.width - os.width) || 0,
                    top: (that.position.top - op.top) || 0,
                    left: (that.position.left - op.left) || 0
                },

                _alsoResize = function(exp, c) {
                    $(exp).each(function() {
                        var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
                            css = c && c.length ?
                                c :
                                el.parents(ui.originalElement[0]).length ?
                                    [ "width", "height" ] :
                                    [ "width", "height", "top", "left" ];

                        $.each(css, function(i, prop) {
                            var sum = (start[prop] || 0) + (delta[prop] || 0);
                            if (sum && sum >= 0) {
                                style[prop] = sum || null;
                            }
                        });

                        el.css(style);
                    });
                };

            if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
                $.each(o.alsoResize, function(exp, c) {
                    _alsoResize(exp, c);
                });
            } else {
                _alsoResize(o.alsoResize);
            }
        },

        stop: function() {
            $(this).removeData("resizable-alsoresize");
        }
    });

    $.ui.plugin.add("resizable", "ghost", {

        start: function() {

            var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;

            that.ghost = that.originalElement.clone();
            that.ghost
                .css({
                    opacity: 0.25,
                    display: "block",
                    position: "relative",
                    height: cs.height,
                    width: cs.width,
                    margin: 0,
                    left: 0,
                    top: 0
                })
                .addClass("ui-resizable-ghost")
                .addClass(typeof o.ghost === "string" ? o.ghost : "");

            that.ghost.appendTo(that.helper);

        },

        resize: function() {
            var that = $(this).resizable( "instance" );
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                });
            }
        },

        stop: function() {
            var that = $(this).resizable( "instance" );
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }

    });

    $.ui.plugin.add("resizable", "grid", {

        resize: function() {
            var outerDimensions,
                that = $(this).resizable( "instance" ),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
                gridX = (grid[0] || 1),
                gridY = (grid[1] || 1),
                ox = Math.round((cs.width - os.width) / gridX) * gridX,
                oy = Math.round((cs.height - os.height) / gridY) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
                isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
                isMinWidth = o.minWidth && (o.minWidth > newWidth),
                isMinHeight = o.minHeight && (o.minHeight > newHeight);

            o.grid = grid;

            if (isMinWidth) {
                newWidth += gridX;
            }
            if (isMinHeight) {
                newHeight += gridY;
            }
            if (isMaxWidth) {
                newWidth -= gridX;
            }
            if (isMaxHeight) {
                newHeight -= gridY;
            }

            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                    outerDimensions = that._getPaddingPlusBorderDimensions( this );
                }

                if ( newHeight - gridY > 0 ) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if ( newWidth - gridX > 0 ) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridY - outerDimensions.height;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        }

    });

    var resizable = $.ui.resizable;


    /*!
     * jQuery UI Slider 1.11.2
     * http://jqueryui.com
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/slider/
     */


    var slider = $.widget( "ui.slider", $.ui.mouse, {
        version: "1.11.2",
        widgetEventPrefix: "slide",

        options: {
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,

            // callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },

        // number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,

        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();

            this.element
                .addClass( "ui-slider" +
                    " ui-slider-" + this.orientation +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all");

            this._refresh();
            this._setOption( "disabled", this.options.disabled );

            this._animateOff = false;
        },

        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function() {
            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
                handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
                handles = [];

            handleCount = ( options.values && options.values.length ) || 1;

            if ( existingHandles.length > handleCount ) {
                existingHandles.slice( handleCount ).remove();
                existingHandles = existingHandles.slice( 0, handleCount );
            }

            for ( i = existingHandles.length; i < handleCount; i++ ) {
                handles.push( handle );
            }

            this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

            this.handle = this.handles.eq( 0 );

            this.handles.each(function( i ) {
                $( this ).data( "ui-slider-handle-index", i );
            });
        },

        _createRange: function() {
            var options = this.options,
                classes = "";

            if ( options.range ) {
                if ( options.range === true ) {
                    if ( !options.values ) {
                        options.values = [ this._valueMin(), this._valueMin() ];
                    } else if ( options.values.length && options.values.length !== 2 ) {
                        options.values = [ options.values[0], options.values[0] ];
                    } else if ( $.isArray( options.values ) ) {
                        options.values = options.values.slice(0);
                    }
                }

                if ( !this.range || !this.range.length ) {
                    this.range = $( "<div></div>" )
                        .appendTo( this.element );

                    classes = "ui-slider-range" +
                    // note: this isn't the most fittingly semantic framework class for this element,
                    // but worked best visually with a variety of themes
                    " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
                        // Handle range switching from true to min/max
                        .css({
                            "left": "",
                            "bottom": ""
                        });
                }

                this.range.addClass( classes +
                    ( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
            } else {
                if ( this.range ) {
                    this.range.remove();
                }
                this.range = null;
            }
        },

        _setupEvents: function() {
            this._off( this.handles );
            this._on( this.handles, this._handleEvents );
            this._hoverable( this.handles );
            this._focusable( this.handles );
        },

        _destroy: function() {
            this.handles.remove();
            if ( this.range ) {
                this.range.remove();
            }

            this.element
                .removeClass( "ui-slider" +
                    " ui-slider-horizontal" +
                    " ui-slider-vertical" +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all" );

            this._mouseDestroy();
        },

        _mouseCapture: function( event ) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;

            if ( o.disabled ) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = { x: event.pageX, y: event.pageY };
            normValue = this._normValueFromMouse( position );
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function( i ) {
                var thisDistance = Math.abs( normValue - that.values(i) );
                if (( distance > thisDistance ) ||
                    ( distance === thisDistance &&
                        (i === that._lastChangedValue || that.values(i) === o.min ))) {
                    distance = thisDistance;
                    closestHandle = $( this );
                    index = i;
                }
            });

            allowed = this._start( event, index );
            if ( allowed === false ) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            closestHandle
                .addClass( "ui-state-active" )
                .focus();

            offset = closestHandle.offset();
            mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
            this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
                top: event.pageY - offset.top -
                    ( closestHandle.height() / 2 ) -
                    ( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
                    ( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
                    ( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
            };

            if ( !this.handles.hasClass( "ui-state-hover" ) ) {
                this._slide( event, index, normValue );
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function() {
            return true;
        },

        _mouseDrag: function( event ) {
            var position = { x: event.pageX, y: event.pageY },
                normValue = this._normValueFromMouse( position );

            this._slide( event, this._handleIndex, normValue );

            return false;
        },

        _mouseStop: function( event ) {
            this.handles.removeClass( "ui-state-active" );
            this._mouseSliding = false;

            this._stop( event, this._handleIndex );
            this._change( event, this._handleIndex );

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function() {
            this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
        },

        _normValueFromMouse: function( position ) {
            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;

            if ( this.orientation === "horizontal" ) {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
            }

            percentMouse = ( pixelMouse / pixelTotal );
            if ( percentMouse > 1 ) {
                percentMouse = 1;
            }
            if ( percentMouse < 0 ) {
                percentMouse = 0;
            }
            if ( this.orientation === "vertical" ) {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue( valueMouse );
        },

        _start: function( event, index ) {
            var uiHash = {
                handle: this.handles[ index ],
                value: this.value()
            };
            if ( this.options.values && this.options.values.length ) {
                uiHash.value = this.values( index );
                uiHash.values = this.values();
            }
            return this._trigger( "start", event, uiHash );
        },

        _slide: function( event, index, newVal ) {
            var otherVal,
                newValues,
                allowed;

            if ( this.options.values && this.options.values.length ) {
                otherVal = this.values( index ? 0 : 1 );

                if ( ( this.options.values.length === 2 && this.options.range === true ) &&
                        ( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
                    ) {
                    newVal = otherVal;
                }

                if ( newVal !== this.values( index ) ) {
                    newValues = this.values();
                    newValues[ index ] = newVal;
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger( "slide", event, {
                        handle: this.handles[ index ],
                        value: newVal,
                        values: newValues
                    } );
                    otherVal = this.values( index ? 0 : 1 );
                    if ( allowed !== false ) {
                        this.values( index, newVal );
                    }
                }
            } else {
                if ( newVal !== this.value() ) {
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger( "slide", event, {
                        handle: this.handles[ index ],
                        value: newVal
                    } );
                    if ( allowed !== false ) {
                        this.value( newVal );
                    }
                }
            }
        },

        _stop: function( event, index ) {
            var uiHash = {
                handle: this.handles[ index ],
                value: this.value()
            };
            if ( this.options.values && this.options.values.length ) {
                uiHash.value = this.values( index );
                uiHash.values = this.values();
            }

            this._trigger( "stop", event, uiHash );
        },

        _change: function( event, index ) {
            if ( !this._keySliding && !this._mouseSliding ) {
                var uiHash = {
                    handle: this.handles[ index ],
                    value: this.value()
                };
                if ( this.options.values && this.options.values.length ) {
                    uiHash.value = this.values( index );
                    uiHash.values = this.values();
                }

                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;

                this._trigger( "change", event, uiHash );
            }
        },

        value: function( newValue ) {
            if ( arguments.length ) {
                this.options.value = this._trimAlignValue( newValue );
                this._refreshValue();
                this._change( null, 0 );
                return;
            }

            return this._value();
        },

        values: function( index, newValue ) {
            var vals,
                newValues,
                i;

            if ( arguments.length > 1 ) {
                this.options.values[ index ] = this._trimAlignValue( newValue );
                this._refreshValue();
                this._change( null, index );
                return;
            }

            if ( arguments.length ) {
                if ( $.isArray( arguments[ 0 ] ) ) {
                    vals = this.options.values;
                    newValues = arguments[ 0 ];
                    for ( i = 0; i < vals.length; i += 1 ) {
                        vals[ i ] = this._trimAlignValue( newValues[ i ] );
                        this._change( null, i );
                    }
                    this._refreshValue();
                } else {
                    if ( this.options.values && this.options.values.length ) {
                        return this._values( index );
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function( key, value ) {
            var i,
                valsLength = 0;

            if ( key === "range" && this.options.range === true ) {
                if ( value === "min" ) {
                    this.options.value = this._values( 0 );
                    this.options.values = null;
                } else if ( value === "max" ) {
                    this.options.value = this._values( this.options.values.length - 1 );
                    this.options.values = null;
                }
            }

            if ( $.isArray( this.options.values ) ) {
                valsLength = this.options.values.length;
            }

            if ( key === "disabled" ) {
                this.element.toggleClass( "ui-state-disabled", !!value );
            }

            this._super( key, value );

            switch ( key ) {
                case "orientation":
                    this._detectOrientation();
                    this.element
                        .removeClass( "ui-slider-horizontal ui-slider-vertical" )
                        .addClass( "ui-slider-" + this.orientation );
                    this._refreshValue();

                    // Reset positioning from previous orientation
                    this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change( null, 0 );
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for ( i = 0; i < valsLength; i += 1 ) {
                        this._change( null, i );
                    }
                    this._animateOff = false;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = true;
                    this._calculateNewMax();
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue( val );

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function( index ) {
            var val,
                vals,
                i;

            if ( arguments.length ) {
                val = this.options.values[ index ];
                val = this._trimAlignValue( val );

                return val;
            } else if ( this.options.values && this.options.values.length ) {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for ( i = 0; i < vals.length; i += 1) {
                    vals[ i ] = this._trimAlignValue( vals[ i ] );
                }

                return vals;
            } else {
                return [];
            }
        },

        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function( val ) {
            if ( val <= this._valueMin() ) {
                return this._valueMin();
            }
            if ( val >= this._valueMax() ) {
                return this._valueMax();
            }
            var step = ( this.options.step > 0 ) ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if ( Math.abs(valModStep) * 2 >= step ) {
                alignValue += ( valModStep > 0 ) ? step : ( -step );
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat( alignValue.toFixed(5) );
        },

        _calculateNewMax: function() {
            var remainder = ( this.options.max - this._valueMin() ) % this.options.step;
            this.max = this.options.max - remainder;
        },

        _valueMin: function() {
            return this.options.min;
        },

        _valueMax: function() {
            return this.max;
        },

        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = ( !this._animateOff ) ? o.animate : false,
                _set = {};

            if ( this.options.values && this.options.values.length ) {
                this.handles.each(function( i ) {
                    valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
                    _set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                    $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                    if ( that.options.range === true ) {
                        if ( that.orientation === "horizontal" ) {
                            if ( i === 0 ) {
                                that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
                            }
                            if ( i === 1 ) {
                                that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                            }
                        } else {
                            if ( i === 0 ) {
                                that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
                            }
                            if ( i === 1 ) {
                                that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = ( valueMax !== valueMin ) ?
                        ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
                        0;
                _set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

                if ( oRange === "min" && this.orientation === "horizontal" ) {
                    this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
                }
                if ( oRange === "max" && this.orientation === "horizontal" ) {
                    this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
                }
                if ( oRange === "min" && this.orientation === "vertical" ) {
                    this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
                }
                if ( oRange === "max" && this.orientation === "vertical" ) {
                    this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
                }
            }
        },

        _handleEvents: {
            keydown: function( event ) {
                var allowed, curVal, newVal, step,
                    index = $( event.target ).data( "ui-slider-handle-index" );

                switch ( event.keyCode ) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if ( !this._keySliding ) {
                            this._keySliding = true;
                            $( event.target ).addClass( "ui-state-active" );
                            allowed = this._start( event, index );
                            if ( allowed === false ) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if ( this.options.values && this.options.values.length ) {
                    curVal = newVal = this.values( index );
                } else {
                    curVal = newVal = this.value();
                }

                switch ( event.keyCode ) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(
                            curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
                        );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(
                            curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if ( curVal === this._valueMax() ) {
                            return;
                        }
                        newVal = this._trimAlignValue( curVal + step );
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if ( curVal === this._valueMin() ) {
                            return;
                        }
                        newVal = this._trimAlignValue( curVal - step );
                        break;
                }

                this._slide( event, index, newVal );
            },
            keyup: function( event ) {
                var index = $( event.target ).data( "ui-slider-handle-index" );

                if ( this._keySliding ) {
                    this._keySliding = false;
                    this._stop( event, index );
                    this._change( event, index );
                    $( event.target ).removeClass( "ui-state-active" );
                }
            }
        }
    });



    }));
/*-------------------------------  Castom Scroll Bar  -------------------------------*/

    /*
    == malihu jquery custom scrollbar plugin == 
    Version: 3.0.6 
    Plugin URI: http://manos.malihu.gr/jquery-custom-content-scroller 
    Author: malihu
    Author URI: http://manos.malihu.gr
    License: MIT License (MIT)
    */

    /*
    Copyright 2010 Manos Malihutsakis (email: manos@malihu.gr)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */

    /*
    The code below is fairly long, fully commented and should be normally used in development. 
    For production, use either the minified jquery.mCustomScrollbar.min.js script or 
    the production-ready jquery.mCustomScrollbar.concat.min.js which contains the plugin 
    and dependencies (minified). 
    */

(function ($, window, document) {
    (function(init){
        var _rjs=typeof define==="function" && define.amd, /* RequireJS */
            _dlp=("https:"==document.location.protocol) ? "https:" : "http:", /* location protocol */
            _url="cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.12/jquery.mousewheel.min.js";
        if(!_rjs){
            /* load jquery-mousewheel plugin (via CDN) if it's not present or not loaded via RequireJS 
            (works when mCustomScrollbar fn is called on window load) */
            $.event.special.mousewheel || $("head").append(decodeURI("%3Cscript src="+_dlp+"//"+_url+"%3E%3C/script%3E"));
        }
        init();
    }(function(){
        
        /* 
        ----------------------------------------
        PLUGIN NAMESPACE, PREFIX, DEFAULT SELECTOR(S) 
        ----------------------------------------
        */
        
        var pluginNS="mCustomScrollbar",
            pluginPfx="mCS",
            defaultSelector=".mCustomScrollbar",
        
        
            
        
        
        /* 
        ----------------------------------------
        DEFAULT OPTIONS 
        ----------------------------------------
        */
        
            defaults={
                /*
                set element/content width/height programmatically 
                values: boolean, pixels, percentage 
                    option                      default
                    -------------------------------------
                    setWidth                    false
                    setHeight                   false
                */
                /*
                set the initial css top property of content  
                values: string (e.g. "-100px", "10%" etc.)
                */
                setTop:0,
                /*
                set the initial css left property of content  
                values: string (e.g. "-100px", "10%" etc.)
                */
                setLeft:0,
                /* 
                scrollbar axis (vertical and/or horizontal scrollbars) 
                values (string): "y", "x", "yx"
                */
                axis:"y",
                /*
                position of scrollbar relative to content  
                values (string): "inside", "outside" ("outside" requires elements with position:relative)
                */
                scrollbarPosition:"inside",
                /*
                scrolling inertia
                values: integer (milliseconds)
                */
                scrollInertia:950,
                /* 
                auto-adjust scrollbar dragger length
                values: boolean
                */
                autoDraggerLength:true,
                /*
                auto-hide scrollbar when idle 
                values: boolean
                    option                      default
                    -------------------------------------
                    autoHideScrollbar           false
                */
                /*
                auto-expands scrollbar on mouse-over and dragging
                values: boolean
                    option                      default
                    -------------------------------------
                    autoExpandScrollbar         false
                */
                /*
                always show scrollbar, even when there's nothing to scroll 
                values: integer (0=disable, 1=always show dragger rail, 2=always show dragger rail, dragger and buttons), boolean
                */
                alwaysShowScrollbar:0,
                /*
                scrolling always snaps to a multiple of this number in pixels
                values: integer
                    option                      default
                    -------------------------------------
                    snapAmount                  null
                */
                /*
                when snapping, snap with this number in pixels as an offset 
                values: integer
                */
                snapOffset:0,
                /* 
                mouse-wheel scrolling
                */
                mouseWheel:{
                    /* 
                    enable mouse-wheel scrolling
                    values: boolean
                    */
                    enable:true,
                    /* 
                    scrolling amount in pixels
                    values: "auto", integer 
                    */
                    scrollAmount:"auto",
                    /* 
                    mouse-wheel scrolling axis 
                    the default scrolling direction when both vertical and horizontal scrollbars are present 
                    values (string): "y", "x" 
                    */
                    axis:"y",
                    /* 
                    prevent the default behaviour which automatically scrolls the parent element(s) when end of scrolling is reached 
                    values: boolean
                        option                      default
                        -------------------------------------
                        preventDefault              null
                    */
                    /*
                    the reported mouse-wheel delta value. The number of lines (translated to pixels) one wheel notch scrolls.  
                    values: "auto", integer 
                    "auto" uses the default OS/browser value 
                    */
                    deltaFactor:"auto",
                    /*
                    normalize mouse-wheel delta to -1 or 1 (disables mouse-wheel acceleration) 
                    values: boolean
                        option                      default
                        -------------------------------------
                        normalizeDelta              null
                    */
                    /*
                    invert mouse-wheel scrolling direction 
                    values: boolean
                        option                      default
                        -------------------------------------
                        invert                      null
                    */
                    /*
                    the tags that disable mouse-wheel when cursor is over them
                    */
                    disableOver:["select","option","keygen","datalist","textarea"]
                },
                /* 
                scrollbar buttons
                */
                scrollButtons:{ 
                    /*
                    enable scrollbar buttons
                    values: boolean
                        option                      default
                        -------------------------------------
                        enable                      null
                    */
                    /*
                    scrollbar buttons scrolling type 
                    values (string): "stepless", "stepped"
                    */
                    scrollType:"stepless",
                    /*
                    scrolling amount in pixels
                    values: "auto", integer 
                    */
                    scrollAmount:"auto"
                    /*
                    tabindex of the scrollbar buttons
                    values: false, integer
                        option                      default
                        -------------------------------------
                        tabindex                    null
                    */
                },
                /* 
                keyboard scrolling
                */
                keyboard:{ 
                    /*
                    enable scrolling via keyboard
                    values: boolean
                    */
                    enable:true,
                    /*
                    keyboard scrolling type 
                    values (string): "stepless", "stepped"
                    */
                    scrollType:"stepless",
                    /*
                    scrolling amount in pixels
                    values: "auto", integer 
                    */
                    scrollAmount:"auto"
                },
                /*
                enable content touch-swipe scrolling 
                values: boolean, integer, string (number)
                integer values define the axis-specific minimum amount required for scrolling momentum
                */
                contentTouchScroll:25,
                /*
                advanced option parameters
                */
                advanced:{
                    /*
                    auto-expand content horizontally (for "x" or "yx" axis) 
                    values: boolean
                        option                      default
                        -------------------------------------
                        autoExpandHorizontalScroll  null
                    */
                    /*
                    auto-scroll to elements with focus
                    */
                    autoScrollOnFocus:"input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
                    /*
                    auto-update scrollbars on content, element or viewport resize 
                    should be true for fluid layouts/elements, adding/removing content dynamically, hiding/showing elements, content with images etc. 
                    values: boolean
                    */
                    updateOnContentResize:true,
                    /*
                    auto-update scrollbars each time each image inside the element is fully loaded 
                    values: boolean
                    */
                    updateOnImageLoad:true
                    /*
                    auto-update scrollbars based on the amount and size changes of specific selectors 
                    useful when you need to update the scrollbar(s) automatically, each time a type of element is added, removed or changes its size 
                    values: boolean, string (e.g. "ul li" will auto-update scrollbars each time list-items inside the element are changed) 
                    a value of true (boolean) will auto-update scrollbars each time any element is changed
                        option                      default
                        -------------------------------------
                        updateOnSelectorChange      null
                    */
                    /*
                    extra selectors that'll release scrollbar dragging upon mouseup, pointerup, touchend etc. (e.g. "selector-1, selector-2")
                        option                      default
                        -------------------------------------
                        releaseDraggableSelectors   null
                    */
                },
                /* 
                scrollbar theme 
                values: string (see CSS/plugin URI for a list of ready-to-use themes)
                */
                theme:"light",
                /*
                user defined callback functions
                */
                callbacks:{
                    /*
                    Available callbacks: 
                        callback                    default
                        -------------------------------------
                        onInit                      null
                        onScrollStart               null
                        onScroll                    null
                        onTotalScroll               null
                        onTotalScrollBack           null
                        whileScrolling              null
                        onTotalScrollOffset         0
                        onTotalScrollBackOffset     0
                        alwaysTriggerOffsets        true
                        onOverflowY                 null
                        onOverflowX                 null
                        onOverflowYNone             null
                        onOverflowXNone             null
                        onImageLoad                 null
                        onSelectorChange            null
                        onUpdate                    null
                    */
                    onTotalScrollOffset:0,
                    onTotalScrollBackOffset:0,
                    alwaysTriggerOffsets:true
                }
                /*
                add scrollbar(s) on all elements matching the current selector, now and in the future 
                values: boolean, string 
                string values: "on" (enable), "once" (disable after first invocation), "off" (disable)
                liveSelector values: string (selector)
                    option                      default
                    -------------------------------------
                    live                        false
                    liveSelector                null
                */
            },
        
        
        
        
        
        /* 
        ----------------------------------------
        VARS, CONSTANTS 
        ----------------------------------------
        */
        
            totalInstances=0, /* plugin instances amount */
            liveTimers={}, /* live option timers */
            oldIE=(window.attachEvent && !window.addEventListener) ? 1 : 0, /* detect IE < 9 */
            touchActive=false, /* global touch state (for touch and pointer events) */
            /* general plugin classes */
            classes=[
                "mCSB_dragger_onDrag","mCSB_scrollTools_onDrag","mCS_img_loaded","mCS_disabled","mCS_destroyed","mCS_no_scrollbar",
                "mCS-autoHide","mCS-dir-rtl","mCS_no_scrollbar_y","mCS_no_scrollbar_x","mCS_y_hidden","mCS_x_hidden","mCSB_draggerContainer",
                "mCSB_buttonUp","mCSB_buttonDown","mCSB_buttonLeft","mCSB_buttonRight"
            ],
            
        
        
        
        
        /* 
        ----------------------------------------
        METHODS 
        ----------------------------------------
        */
        
            methods={
                
                /* 
                plugin initialization method 
                creates the scrollbar(s), plugin data object and options
                ----------------------------------------
                */
                
                init:function(options){
                    
                    var options=$.extend(true,{},defaults,options),
                        selector=_selector.call(this); /* validate selector */
                    
                    /* 
                    if live option is enabled, monitor for elements matching the current selector and 
                    apply scrollbar(s) when found (now and in the future) 
                    */
                    if(options.live){
                        var liveSelector=options.liveSelector || this.selector || defaultSelector, /* live selector(s) */
                            $liveSelector=$(liveSelector); /* live selector(s) as jquery object */
                        if(options.live==="off"){
                            /* 
                            disable live if requested 
                            usage: $(selector).mCustomScrollbar({live:"off"}); 
                            */
                            removeLiveTimers(liveSelector);
                            return;
                        }
                        liveTimers[liveSelector]=setTimeout(function(){
                            /* call mCustomScrollbar fn on live selector(s) every half-second */
                            $liveSelector.mCustomScrollbar(options);
                            if(options.live==="once" && $liveSelector.length){
                                /* disable live after first invocation */
                                removeLiveTimers(liveSelector);
                            }
                        },500);
                    }else{
                        removeLiveTimers(liveSelector);
                    }
                    
                    /* options backward compatibility (for versions < 3.0.0) and normalization */
                    options.setWidth=(options.set_width) ? options.set_width : options.setWidth;
                    options.setHeight=(options.set_height) ? options.set_height : options.setHeight;
                    options.axis=(options.horizontalScroll) ? "x" : _findAxis(options.axis);
                    options.scrollInertia=options.scrollInertia>0 && options.scrollInertia<17 ? 17 : options.scrollInertia;
                    if(typeof options.mouseWheel!=="object" &&  options.mouseWheel==true){ /* old school mouseWheel option (non-object) */
                        options.mouseWheel={enable:true,scrollAmount:"auto",axis:"y",preventDefault:false,deltaFactor:"auto",normalizeDelta:false,invert:false}
                    }
                    options.mouseWheel.scrollAmount=!options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
                    options.mouseWheel.normalizeDelta=!options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
                    options.scrollButtons.scrollType=_findScrollButtonsType(options.scrollButtons.scrollType); 
                    
                    _theme(options); /* theme-specific options */
                    
                    /* plugin constructor */
                    return $(selector).each(function(){
                        
                        var $this=$(this);
                        
                        if(!$this.data(pluginPfx)){ /* prevent multiple instantiations */
                        
                            /* store options and create objects in jquery data */
                            $this.data(pluginPfx,{
                                idx:++totalInstances, /* instance index */
                                opt:options, /* options */
                                scrollRatio:{y:null,x:null}, /* scrollbar to content ratio */
                                overflowed:null, /* overflowed axis */
                                contentReset:{y:null,x:null}, /* object to check when content resets */
                                bindEvents:false, /* object to check if events are bound */
                                tweenRunning:false, /* object to check if tween is running */
                                sequential:{}, /* sequential scrolling object */
                                langDir:$this.css("direction"), /* detect/store direction (ltr or rtl) */
                                cbOffsets:null, /* object to check whether callback offsets always trigger */
                                /* 
                                object to check how scrolling events where last triggered 
                                "internal" (default - triggered by this script), "external" (triggered by other scripts, e.g. via scrollTo method) 
                                usage: object.data("mCS").trigger
                                */
                                trigger:null
                            });
                            
                            var d=$this.data(pluginPfx),o=d.opt,
                                /* HTML data attributes */
                                htmlDataAxis=$this.data("mcs-axis"),htmlDataSbPos=$this.data("mcs-scrollbar-position"),htmlDataTheme=$this.data("mcs-theme");
                             
                            if(htmlDataAxis){o.axis=htmlDataAxis;} /* usage example: data-mcs-axis="y" */
                            if(htmlDataSbPos){o.scrollbarPosition=htmlDataSbPos;} /* usage example: data-mcs-scrollbar-position="outside" */
                            if(htmlDataTheme){ /* usage example: data-mcs-theme="minimal" */
                                o.theme=htmlDataTheme;
                                _theme(o); /* theme-specific options */
                            }
                            
                            _pluginMarkup.call(this); /* add plugin markup */
                            
                            $("#mCSB_"+d.idx+"_container img:not(."+classes[2]+")").addClass(classes[2]); /* flag loaded images */
                            
                            methods.update.call(null,$this); /* call the update method */
                        
                        }
                        
                    });
                    
                },
                /* ---------------------------------------- */
                
                
                
                /* 
                plugin update method 
                updates content and scrollbar(s) values, events and status 
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("update");
                */
                
                update:function(el,cb){
                    
                    var selector=el || _selector.call(this); /* validate selector */
                    
                    return $(selector).each(function(){
                        
                        var $this=$(this);
                        
                        if($this.data(pluginPfx)){ /* check if plugin has initialized */
                            
                            var d=$this.data(pluginPfx),o=d.opt,
                                mCSB_container=$("#mCSB_"+d.idx+"_container"),
                                mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
                            
                            if(!mCSB_container.length){return;}
                            
                            if(d.tweenRunning){_stop($this);} /* stop any running tweens while updating */
                            
                            /* if element was disabled or destroyed, remove class(es) */
                            if($this.hasClass(classes[3])){$this.removeClass(classes[3]);}
                            if($this.hasClass(classes[4])){$this.removeClass(classes[4]);}
                            
                            _maxHeight.call(this); /* detect/set css max-height value */
                            
                            _expandContentHorizontally.call(this); /* expand content horizontally */
                            
                            if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
                                mCSB_container.css("width",_contentWidth(mCSB_container.children()));
                            }
                            
                            d.overflowed=_overflowed.call(this); /* determine if scrolling is required */
                            
                            _scrollbarVisibility.call(this); /* show/hide scrollbar(s) */
                            
                            /* auto-adjust scrollbar dragger length analogous to content */
                            if(o.autoDraggerLength){_setDraggerLength.call(this);}
                            
                            _scrollRatio.call(this); /* calculate and store scrollbar to content ratio */
                            
                            _bindEvents.call(this); /* bind scrollbar events */
                            
                            /* reset scrolling position and/or events */
                            var to=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)];
                            if(o.axis!=="x"){ /* y/yx axis */
                                if(!d.overflowed[0]){ /* y scrolling is not required */
                                    _resetContentPosition.call(this); /* reset content position */
                                    if(o.axis==="y"){
                                        _unbindEvents.call(this);
                                    }else if(o.axis==="yx" && d.overflowed[1]){
                                        _scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
                                    }
                                }else if(mCSB_dragger[0].height()>mCSB_dragger[0].parent().height()){
                                    _resetContentPosition.call(this); /* reset content position */
                                }else{ /* y scrolling is required */
                                    _scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
                                    d.contentReset.y=null;
                                }
                            }
                            if(o.axis!=="y"){ /* x/yx axis */
                                if(!d.overflowed[1]){ /* x scrolling is not required */
                                    _resetContentPosition.call(this); /* reset content position */
                                    if(o.axis==="x"){
                                        _unbindEvents.call(this);
                                    }else if(o.axis==="yx" && d.overflowed[0]){
                                        _scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
                                    }
                                }else if(mCSB_dragger[1].width()>mCSB_dragger[1].parent().width()){
                                    _resetContentPosition.call(this); /* reset content position */
                                }else{ /* x scrolling is required */
                                    _scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
                                    d.contentReset.x=null;
                                }
                            }
                            
                            /* callbacks: onImageLoad, onSelectorChange, onUpdate */
                            if(cb && d){
                                if(cb===2 && o.callbacks.onImageLoad && typeof o.callbacks.onImageLoad==="function"){
                                    o.callbacks.onImageLoad.call(this);
                                }else if(cb===3 && o.callbacks.onSelectorChange && typeof o.callbacks.onSelectorChange==="function"){
                                    o.callbacks.onSelectorChange.call(this);
                                }else if(o.callbacks.onUpdate && typeof o.callbacks.onUpdate==="function"){
                                    o.callbacks.onUpdate.call(this);
                                }
                            }
                            
                            _autoUpdate.call(this); /* initialize automatic updating (for dynamic content, fluid layouts etc.) */
                            
                        }
                        
                    });
                    
                },
                /* ---------------------------------------- */
                
                
                
                /* 
                plugin scrollTo method 
                triggers a scrolling event to a specific value
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("scrollTo",value,options);
                */
            
                scrollTo:function(val,options){
                    
                    /* prevent silly things like $(selector).mCustomScrollbar("scrollTo",undefined); */
                    if(typeof val=="undefined" || val==null){return;}
                    
                    var selector=_selector.call(this); /* validate selector */
                    
                    return $(selector).each(function(){
                        
                        var $this=$(this);
                        
                        if($this.data(pluginPfx)){ /* check if plugin has initialized */
                        
                            var d=$this.data(pluginPfx),o=d.opt,
                                /* method default options */
                                methodDefaults={
                                    trigger:"external", /* method is by default triggered externally (e.g. from other scripts) */
                                    scrollInertia:o.scrollInertia, /* scrolling inertia (animation duration) */
                                    scrollEasing:"mcsEaseInOut", /* animation easing */
                                    moveDragger:false, /* move dragger instead of content */
                                    timeout:60, /* scroll-to delay */
                                    callbacks:true, /* enable/disable callbacks */
                                    onStart:true,
                                    onUpdate:true,
                                    onComplete:true
                                },
                                methodOptions=$.extend(true,{},methodDefaults,options),
                                to=_arr.call(this,val),dur=methodOptions.scrollInertia>0 && methodOptions.scrollInertia<17 ? 17 : methodOptions.scrollInertia;
                            
                            /* translate yx values to actual scroll-to positions */
                            to[0]=_to.call(this,to[0],"y");
                            to[1]=_to.call(this,to[1],"x");
                            
                            /* 
                            check if scroll-to value moves the dragger instead of content. 
                            Only pixel values apply on dragger (e.g. 100, "100px", "-=100" etc.) 
                            */
                            if(methodOptions.moveDragger){
                                to[0]*=d.scrollRatio.y;
                                to[1]*=d.scrollRatio.x;
                            }
                            
                            methodOptions.dur=dur;
                            
                            setTimeout(function(){ 
                                /* do the scrolling */
                                if(to[0]!==null && typeof to[0]!=="undefined" && o.axis!=="x" && d.overflowed[0]){ /* scroll y */
                                    methodOptions.dir="y";
                                    methodOptions.overwrite="all";
                                    _scrollTo($this,to[0].toString(),methodOptions);
                                }
                                if(to[1]!==null && typeof to[1]!=="undefined" && o.axis!=="y" && d.overflowed[1]){ /* scroll x */
                                    methodOptions.dir="x";
                                    methodOptions.overwrite="none";
                                    _scrollTo($this,to[1].toString(),methodOptions);
                                }
                            },methodOptions.timeout);
                            
                        }
                        
                    });
                    
                },
                /* ---------------------------------------- */
                
                
                
                /*
                plugin stop method 
                stops scrolling animation
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("stop");
                */
                stop:function(){
                    
                    var selector=_selector.call(this); /* validate selector */
                    
                    return $(selector).each(function(){
                        
                        var $this=$(this);
                        
                        if($this.data(pluginPfx)){ /* check if plugin has initialized */
                                            
                            _stop($this);
                        
                        }
                        
                    });
                    
                },
                /* ---------------------------------------- */
                
                
                
                /*
                plugin disable method 
                temporarily disables the scrollbar(s) 
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("disable",reset); 
                reset (boolean): resets content position to 0 
                */
                disable:function(r){
                    
                    var selector=_selector.call(this); /* validate selector */
                    
                    return $(selector).each(function(){
                        
                        var $this=$(this);
                        
                        if($this.data(pluginPfx)){ /* check if plugin has initialized */
                            
                            var d=$this.data(pluginPfx);
                            
                            _autoUpdate.call(this,"remove"); /* remove automatic updating */
                            
                            _unbindEvents.call(this); /* unbind events */
                            
                            if(r){_resetContentPosition.call(this);} /* reset content position */
                            
                            _scrollbarVisibility.call(this,true); /* show/hide scrollbar(s) */
                            
                            $this.addClass(classes[3]); /* add disable class */
                        
                        }
                        
                    });
                    
                },
                /* ---------------------------------------- */
                
                
                
                /*
                plugin destroy method 
                completely removes the scrollbar(s) and returns the element to its original state
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("destroy"); 
                */
                destroy:function(){
                    
                    var selector=_selector.call(this); /* validate selector */
                    
                    return $(selector).each(function(){
                        
                        var $this=$(this);
                        
                        if($this.data(pluginPfx)){ /* check if plugin has initialized */
                        
                            var d=$this.data(pluginPfx),o=d.opt,
                                mCustomScrollBox=$("#mCSB_"+d.idx),
                                mCSB_container=$("#mCSB_"+d.idx+"_container"),
                                scrollbar=$(".mCSB_"+d.idx+"_scrollbar");
                        
                            if(o.live){removeLiveTimers(o.liveSelector || $(selector).selector);} /* remove live timers */
                            
                            _autoUpdate.call(this,"remove"); /* remove automatic updating */
                            
                            _unbindEvents.call(this); /* unbind events */
                            
                            _resetContentPosition.call(this); /* reset content position */
                            
                            $this.removeData(pluginPfx); /* remove plugin data object */
                            
                            _delete(this,"mcs"); /* delete callbacks object */
                            
                            /* remove plugin markup */
                            scrollbar.remove(); /* remove scrollbar(s) first (those can be either inside or outside plugin's inner wrapper) */
                            mCSB_container.find("img."+classes[2]).removeClass(classes[2]); /* remove loaded images flag */
                            mCustomScrollBox.replaceWith(mCSB_container.contents()); /* replace plugin's inner wrapper with the original content */
                            /* remove plugin classes from the element and add destroy class */
                            $this.removeClass(pluginNS+" _"+pluginPfx+"_"+d.idx+" "+classes[6]+" "+classes[7]+" "+classes[5]+" "+classes[3]).addClass(classes[4]);
                        
                        }
                        
                    });
                    
                }
                /* ---------------------------------------- */
                
            },
        
        
        
        
            
        /* 
        ----------------------------------------
        FUNCTIONS
        ----------------------------------------
        */
        
        /* validates selector (if selector is invalid or undefined uses the default one) */
            _selector=function(){
                return (typeof $(this)!=="object" || $(this).length<1) ? defaultSelector : this;
            },
            /* -------------------- */
            
            /* changes options according to theme */
            _theme=function(obj){
                var fixedSizeScrollbarThemes=["rounded","rounded-dark","rounded-dots","rounded-dots-dark"],
                    nonExpandedScrollbarThemes=["rounded-dots","rounded-dots-dark","3d","3d-dark","3d-thick","3d-thick-dark","inset","inset-dark","inset-2","inset-2-dark","inset-3","inset-3-dark"],
                    disabledScrollButtonsThemes=["minimal","minimal-dark"],
                    enabledAutoHideScrollbarThemes=["minimal","minimal-dark"],
                    scrollbarPositionOutsideThemes=["minimal","minimal-dark"];
                obj.autoDraggerLength=$.inArray(obj.theme,fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
                obj.autoExpandScrollbar=$.inArray(obj.theme,nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
                obj.scrollButtons.enable=$.inArray(obj.theme,disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
                obj.autoHideScrollbar=$.inArray(obj.theme,enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
                obj.scrollbarPosition=$.inArray(obj.theme,scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
            },
            /* -------------------- */
            
            
            /* live option timers removal */
            removeLiveTimers=function(selector){
                if(liveTimers[selector]){
                    clearTimeout(liveTimers[selector]);
                    _delete(liveTimers,selector);
                }
            },
            /* -------------------- */
            
            
            /* normalizes axis option to valid values: "y", "x", "yx" */
            _findAxis=function(val){
                return (val==="yx" || val==="xy" || val==="auto") ? "yx" : (val==="x" || val==="horizontal") ? "x" : "y";
            },
            /* -------------------- */
            
            
            /* normalizes scrollButtons.scrollType option to valid values: "stepless", "stepped" */
            _findScrollButtonsType=function(val){
                return (val==="stepped" || val==="pixels" || val==="step" || val==="click") ? "stepped" : "stepless";
            },
            /* -------------------- */
            
            
            /* generates plugin markup */
            _pluginMarkup=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    expandClass=o.autoExpandScrollbar ? " "+classes[1]+"_expand" : "",
                    scrollbar=["<div id='mCSB_"+d.idx+"_scrollbar_vertical' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_vertical"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_vertical' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>","<div id='mCSB_"+d.idx+"_scrollbar_horizontal' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_horizontal"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_horizontal' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
                    wrapperClass=o.axis==="yx" ? "mCSB_vertical_horizontal" : o.axis==="x" ? "mCSB_horizontal" : "mCSB_vertical",
                    scrollbars=o.axis==="yx" ? scrollbar[0]+scrollbar[1] : o.axis==="x" ? scrollbar[1] : scrollbar[0],
                    contentWrapper=o.axis==="yx" ? "<div id='mCSB_"+d.idx+"_container_wrapper' class='mCSB_container_wrapper' />" : "",
                    autoHideClass=o.autoHideScrollbar ? " "+classes[6] : "",
                    scrollbarDirClass=(o.axis!=="x" && d.langDir==="rtl") ? " "+classes[7] : "";
                if(o.setWidth){$this.css("width",o.setWidth);} /* set element width */
                if(o.setHeight){$this.css("height",o.setHeight);} /* set element height */
                o.setLeft=(o.axis!=="y" && d.langDir==="rtl") ? "989999px" : o.setLeft; /* adjust left position for rtl direction */
                $this.addClass(pluginNS+" _"+pluginPfx+"_"+d.idx+autoHideClass+scrollbarDirClass).wrapInner("<div id='mCSB_"+d.idx+"' class='mCustomScrollBox mCS-"+o.theme+" "+wrapperClass+"'><div id='mCSB_"+d.idx+"_container' class='mCSB_container' style='position:relative; top:"+o.setTop+"; left:"+o.setLeft+";' dir="+d.langDir+" /></div>");
                var mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
                    mCSB_container.css("width",_contentWidth(mCSB_container.children()));
                }
                if(o.scrollbarPosition==="outside"){
                    if($this.css("position")==="static"){ /* requires elements with non-static position */
                        $this.css("position","relative");
                    }
                    $this.css("overflow","visible");
                    mCustomScrollBox.addClass("mCSB_outside").after(scrollbars);
                }else{
                    mCustomScrollBox.addClass("mCSB_inside").append(scrollbars);
                    mCSB_container.wrap(contentWrapper);
                }
                _scrollButtons.call(this); /* add scrollbar buttons */
                /* minimum dragger length */
                var mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
                mCSB_dragger[0].css("min-height",mCSB_dragger[0].height());
                mCSB_dragger[1].css("min-width",mCSB_dragger[1].width());
            },
            /* -------------------- */
            
            
            /* calculates content width */
            _contentWidth=function(el){
                return Math.max.apply(Math,el.map(function(){return $(this).outerWidth(true);}).get());
            },
            /* -------------------- */
            
            
            /* expands content horizontally */
            _expandContentHorizontally=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(o.advanced.autoExpandHorizontalScroll && o.axis!=="y"){
                    /* 
                    wrap content with an infinite width div and set its position to absolute and width to auto. 
                    Setting width to auto before calculating the actual width is important! 
                    We must let the browser set the width as browser zoom values are impossible to calculate.
                    */
                    mCSB_container.css({"position":"absolute","width":"auto"})
                        .wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
                        .css({ /* set actual width, original position and un-wrap */
                            /* 
                            get the exact width (with decimals) and then round-up. 
                            Using jquery outerWidth() will round the width value which will mess up with inner elements that have non-integer width
                            */
                            "width":(Math.ceil(mCSB_container[0].getBoundingClientRect().right+0.4)-Math.floor(mCSB_container[0].getBoundingClientRect().left)),
                            "position":"relative"
                        }).unwrap();
                }
            },
            /* -------------------- */
            
            
            /* adds scrollbar buttons */
            _scrollButtons=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_scrollTools=$(".mCSB_"+d.idx+"_scrollbar:first"),
                    tabindex=!_isNumeric(o.scrollButtons.tabindex) ? "" : "tabindex='"+o.scrollButtons.tabindex+"'",
                    btnHTML=[
                        "<a href='#' class='"+classes[13]+"' oncontextmenu='return false;' "+tabindex+" />",
                        "<a href='#' class='"+classes[14]+"' oncontextmenu='return false;' "+tabindex+" />",
                        "<a href='#' class='"+classes[15]+"' oncontextmenu='return false;' "+tabindex+" />",
                        "<a href='#' class='"+classes[16]+"' oncontextmenu='return false;' "+tabindex+" />"
                    ],
                    btn=[(o.axis==="x" ? btnHTML[2] : btnHTML[0]),(o.axis==="x" ? btnHTML[3] : btnHTML[1]),btnHTML[2],btnHTML[3]];
                if(o.scrollButtons.enable){
                    mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
                }
            },
            /* -------------------- */
            
            
            /* detects/sets css max-height value */
            _maxHeight=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mh=$this.css("max-height") || "none",pct=mh.indexOf("%")!==-1,
                    bs=$this.css("box-sizing");
                if(mh!=="none"){
                    var val=pct ? $this.parent().height()*parseInt(mh)/100 : parseInt(mh);
                    /* if element's css box-sizing is "border-box", subtract any paddings and/or borders from max-height value */
                    if(bs==="border-box"){val-=(($this.innerHeight()-$this.height())+($this.outerHeight()-$this.innerHeight()));}
                    mCustomScrollBox.css("max-height",Math.round(val));
                }
            },
            /* -------------------- */
            
            
            /* auto-adjusts scrollbar dragger length */
            _setDraggerLength=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    ratio=[mCustomScrollBox.height()/mCSB_container.outerHeight(false),mCustomScrollBox.width()/mCSB_container.outerWidth(false)],
                    l=[
                        parseInt(mCSB_dragger[0].css("min-height")),Math.round(ratio[0]*mCSB_dragger[0].parent().height()),
                        parseInt(mCSB_dragger[1].css("min-width")),Math.round(ratio[1]*mCSB_dragger[1].parent().width())
                    ],
                    h=oldIE && (l[1]<l[0]) ? l[0] : l[1],w=oldIE && (l[3]<l[2]) ? l[2] : l[3];
                mCSB_dragger[0].css({
                    "height":h,"max-height":(mCSB_dragger[0].parent().height()-10)
                }).find(".mCSB_dragger_bar").css({"line-height":l[0]+"px"});
                mCSB_dragger[1].css({
                    "width":w,"max-width":(mCSB_dragger[1].parent().width()-10)
                });
            },
            /* -------------------- */
            
            
            /* calculates scrollbar to content ratio */
            _scrollRatio=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    scrollAmount=[mCSB_container.outerHeight(false)-mCustomScrollBox.height(),mCSB_container.outerWidth(false)-mCustomScrollBox.width()],
                    ratio=[
                        scrollAmount[0]/(mCSB_dragger[0].parent().height()-mCSB_dragger[0].height()),
                        scrollAmount[1]/(mCSB_dragger[1].parent().width()-mCSB_dragger[1].width())
                    ];
                d.scrollRatio={y:ratio[0],x:ratio[1]};
            },
            /* -------------------- */
            
            
            /* toggles scrolling classes */
            _onDragClasses=function(el,action,xpnd){
                var expandClass=xpnd ? classes[0]+"_expanded" : "",
                    scrollbar=el.closest(".mCSB_scrollTools");
                if(action==="active"){
                    el.toggleClass(classes[0]+" "+expandClass); scrollbar.toggleClass(classes[1]); 
                    el[0]._draggable=el[0]._draggable ? 0 : 1;
                }else{
                    if(!el[0]._draggable){
                        if(action==="hide"){
                            el.removeClass(classes[0]); scrollbar.removeClass(classes[1]);
                        }else{
                            el.addClass(classes[0]); scrollbar.addClass(classes[1]);
                        }
                    }
                }
            },
            /* -------------------- */
            
            
            /* checks if content overflows its container to determine if scrolling is required */
            _overflowed=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    contentHeight=d.overflowed==null ? mCSB_container.height() : mCSB_container.outerHeight(false),
                    contentWidth=d.overflowed==null ? mCSB_container.width() : mCSB_container.outerWidth(false);
                return [contentHeight>mCustomScrollBox.height(),contentWidth>mCustomScrollBox.width()];
            },
            /* -------------------- */
            
            
            /* resets content position to 0 */
            _resetContentPosition=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
                _stop($this); /* stop any current scrolling before resetting */
                if((o.axis!=="x" && !d.overflowed[0]) || (o.axis==="y" && d.overflowed[0])){ /* reset y */
                    mCSB_dragger[0].add(mCSB_container).css("top",0);
                    _scrollTo($this,"_resetY");
                }
                if((o.axis!=="y" && !d.overflowed[1]) || (o.axis==="x" && d.overflowed[1])){ /* reset x */
                    var cx=dx=0;
                    if(d.langDir==="rtl"){ /* adjust left position for rtl direction */
                        cx=mCustomScrollBox.width()-mCSB_container.outerWidth(false);
                        dx=Math.abs(cx/d.scrollRatio.x);
                    }
                    mCSB_container.css("left",cx);
                    mCSB_dragger[1].css("left",dx);
                    _scrollTo($this,"_resetX");
                }
            },
            /* -------------------- */
            
            
            /* binds scrollbar events */
            _bindEvents=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt;
                if(!d.bindEvents){ /* check if events are already bound */
                    _draggable.call(this);
                    if(o.contentTouchScroll){_contentDraggable.call(this);}
                    _selectable.call(this);
                    if(o.mouseWheel.enable){ /* bind mousewheel fn when plugin is available */
                        function _mwt(){
                            mousewheelTimeout=setTimeout(function(){
                                if(!$.event.special.mousewheel){
                                    _mwt();
                                }else{
                                    clearTimeout(mousewheelTimeout);
                                    _mousewheel.call($this[0]);
                                }
                            },100);
                        }
                        var mousewheelTimeout;
                        _mwt();
                    }
                    _draggerRail.call(this);
                    _wrapperScroll.call(this);
                    if(o.advanced.autoScrollOnFocus){_focus.call(this);}
                    if(o.scrollButtons.enable){_buttons.call(this);}
                    if(o.keyboard.enable){_keyboard.call(this);}
                    d.bindEvents=true;
                }
            },
            /* -------------------- */
            
            
            /* unbinds scrollbar events */
            _unbindEvents=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    sb=".mCSB_"+d.idx+"_scrollbar",
                    sel=$("#mCSB_"+d.idx+",#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,"+sb+" ."+classes[12]+",#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal,"+sb+">a"),
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(o.advanced.releaseDraggableSelectors){sel.add($(o.advanced.releaseDraggableSelectors));}
                if(d.bindEvents){ /* check if events are bound */
                    /* unbind namespaced events from document/selectors */
                    $(document).unbind("."+namespace);
                    sel.each(function(){
                        $(this).unbind("."+namespace);
                    });
                    /* clear and delete timeouts/objects */
                    clearTimeout($this[0]._focusTimeout); _delete($this[0],"_focusTimeout");
                    clearTimeout(d.sequential.step); _delete(d.sequential,"step");
                    clearTimeout(mCSB_container[0].onCompleteTimeout); _delete(mCSB_container[0],"onCompleteTimeout");
                    d.bindEvents=false;
                }
            },
            /* -------------------- */
            
            
            /* toggles scrollbar visibility */
            _scrollbarVisibility=function(disabled){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    contentWrapper=$("#mCSB_"+d.idx+"_container_wrapper"),
                    content=contentWrapper.length ? contentWrapper : $("#mCSB_"+d.idx+"_container"),
                    scrollbar=[$("#mCSB_"+d.idx+"_scrollbar_vertical"),$("#mCSB_"+d.idx+"_scrollbar_horizontal")],
                    mCSB_dragger=[scrollbar[0].find(".mCSB_dragger"),scrollbar[1].find(".mCSB_dragger")];
                if(o.axis!=="x"){
                    if(d.overflowed[0] && !disabled){
                        scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display","block");
                        content.removeClass(classes[8]+" "+classes[10]);
                    }else{
                        if(o.alwaysShowScrollbar){
                            if(o.alwaysShowScrollbar!==2){mCSB_dragger[0].add(scrollbar[0].children("a")).css("display","none");}
                            content.removeClass(classes[10]);
                        }else{
                            scrollbar[0].css("display","none");
                            content.addClass(classes[10]);
                        }
                        content.addClass(classes[8]);
                    }
                }
                if(o.axis!=="y"){
                    if(d.overflowed[1] && !disabled){
                        scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display","block");
                        content.removeClass(classes[9]+" "+classes[11]);
                    }else{
                        if(o.alwaysShowScrollbar){
                            if(o.alwaysShowScrollbar!==2){mCSB_dragger[1].add(scrollbar[1].children("a")).css("display","none");}
                            content.removeClass(classes[11]);
                        }else{
                            scrollbar[1].css("display","none");
                            content.addClass(classes[11]);
                        }
                        content.addClass(classes[9]);
                    }
                }
                if(!d.overflowed[0] && !d.overflowed[1]){
                    $this.addClass(classes[5]);
                }else{
                    $this.removeClass(classes[5]);
                }
            },
            /* -------------------- */
            
            
            /* returns input coordinates of pointer, touch and mouse events (relative to document) */
            _coordinates=function(e){
                var t=e.type;
                switch(t){
                    case "pointerdown": case "MSPointerDown": case "pointermove": case "MSPointerMove": case "pointerup": case "MSPointerUp":
                        return [e.originalEvent.pageY,e.originalEvent.pageX,false];
                        break;
                    case "touchstart": case "touchmove": case "touchend":
                        var touch=e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
                            touches=e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
                        return [touch.pageY,touch.pageX,touches>1];
                        break;
                    default:
                        return [e.pageY,e.pageX,false];
                }
            },
            /* -------------------- */
            
            
            /* 
            SCROLLBAR DRAG EVENTS
            scrolls content via scrollbar dragging 
            */
            _draggable=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    draggerId=["mCSB_"+d.idx+"_dragger_vertical","mCSB_"+d.idx+"_dragger_horizontal"],
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=$("#"+draggerId[0]+",#"+draggerId[1]),
                    draggable,dragY,dragX,
                    rds=o.advanced.releaseDraggableSelectors ? mCSB_dragger.add($(o.advanced.releaseDraggableSelectors)) : mCSB_dragger;
                mCSB_dragger.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
                    touchActive=true;
                    if(oldIE){document.onselectstart=function(){return false;}} /* disable text selection for IE < 9 */
                    _iframe(false); /* enable scrollbar dragging over iframes by disabling their events */
                    _stop($this);
                    draggable=$(this);
                    var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
                        h=draggable.height()+offset.top,w=draggable.width()+offset.left;
                    if(y<h && y>0 && x<w && x>0){
                        dragY=y; 
                        dragX=x;
                    }
                    _onDragClasses(draggable,"active",o.autoExpandScrollbar); 
                }).bind("touchmove."+namespace,function(e){
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
                    _drag(dragY,dragX,y,x);
                });
                $(document).bind("mousemove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace,function(e){
                    if(draggable){
                        var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
                        if(dragY===y){return;} /* has it really moved? */
                        _drag(dragY,dragX,y,x);
                    }
                }).add(rds).bind("mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
                    if(draggable){
                        _onDragClasses(draggable,"active",o.autoExpandScrollbar); 
                        draggable=null;
                    }
                    touchActive=false;
                    if(oldIE){document.onselectstart=null;} /* enable text selection for IE < 9 */
                    _iframe(true); /* enable iframes events */
                });
                function _iframe(evt){
                    var el=mCSB_container.find("iframe");
                    if(!el.length){return;} /* check if content contains iframes */
                    var val=!evt ? "none" : "auto";
                    el.css("pointer-events",val); /* for IE11, iframe's display property should not be "block" */
                }
                function _drag(dragY,dragX,y,x){
                    mCSB_container[0].idleTimer=o.scrollInertia<233 ? 250 : 0;
                    if(draggable.attr("id")===draggerId[1]){
                        var dir="x",to=((draggable[0].offsetLeft-dragX)+x)*d.scrollRatio.x;
                    }else{
                        var dir="y",to=((draggable[0].offsetTop-dragY)+y)*d.scrollRatio.y;
                    }
                    _scrollTo($this,to.toString(),{dir:dir,drag:true});
                }
            },
            /* -------------------- */
            
            
            /* 
            TOUCH SWIPE EVENTS
            scrolls content via touch swipe 
            Emulates the native touch-swipe scrolling with momentum found in iOS, Android and WP devices 
            */
            _contentDraggable=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    dragY,dragX,touchStartY,touchStartX,touchMoveY=[],touchMoveX=[],startTime,runningTime,endTime,distance,speed,amount,
                    durA=0,durB,overwrite=o.axis==="yx" ? "none" : "all",touchIntent=[];
                mCSB_container.bind("touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
                    var offset=mCSB_container.offset();
                    dragY=_coordinates(e)[0]-offset.top;
                    dragX=_coordinates(e)[1]-offset.left;
                    touchIntent=[_coordinates(e)[0],_coordinates(e)[1]];
                }).bind("touchmove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace,function(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
                    e.stopImmediatePropagation();
                    runningTime=_getTime();
                    var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
                        easing="mcsLinearOut";
                    touchMoveY.push(y);
                    touchMoveX.push(x);
                    touchIntent[2]=Math.abs(_coordinates(e)[0]-touchIntent[0]); touchIntent[3]=Math.abs(_coordinates(e)[1]-touchIntent[1]);
                    if(d.overflowed[0]){
                        var limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
                            prevent=((dragY-y)>0 && (y-dragY)>-(limit*d.scrollRatio.y) && (touchIntent[3]*2<touchIntent[2] || o.axis==="yx"));
                    }
                    if(d.overflowed[1]){
                        var limitX=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
                            preventX=((dragX-x)>0 && (x-dragX)>-(limitX*d.scrollRatio.x) && (touchIntent[2]*2<touchIntent[3] || o.axis==="yx"));
                    }
                    if(prevent || preventX){e.preventDefault();} /* prevent native document scrolling */
                    amount=o.axis==="yx" ? [(dragY-y),(dragX-x)] : o.axis==="x" ? [null,(dragX-x)] : [(dragY-y),null];
                    mCSB_container[0].idleTimer=250;
                    if(d.overflowed[0]){_drag(amount[0],durA,easing,"y","all",true);}
                    if(d.overflowed[1]){_drag(amount[1],durA,easing,"x",overwrite,true);}
                });
                mCustomScrollBox.bind("touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
                    e.stopImmediatePropagation();
                    _stop($this);
                    startTime=_getTime();
                    var offset=mCustomScrollBox.offset();
                    touchStartY=_coordinates(e)[0]-offset.top;
                    touchStartX=_coordinates(e)[1]-offset.left;
                    touchMoveY=[]; touchMoveX=[];
                }).bind("touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
                    e.stopImmediatePropagation();
                    endTime=_getTime();
                    var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
                    if((endTime-runningTime)>30){return;}
                    speed=1000/(endTime-startTime);
                    var easing="mcsEaseOut",slow=speed<2.5,
                        diff=slow ? [touchMoveY[touchMoveY.length-2],touchMoveX[touchMoveX.length-2]] : [0,0];
                    distance=slow ? [(y-diff[0]),(x-diff[1])] : [y-touchStartY,x-touchStartX];
                    var absDistance=[Math.abs(distance[0]),Math.abs(distance[1])];
                    speed=slow ? [Math.abs(distance[0]/4),Math.abs(distance[1]/4)] : [speed,speed];
                    var a=[
                        Math.abs(mCSB_container[0].offsetTop)-(distance[0]*_m((absDistance[0]/speed[0]),speed[0])),
                        Math.abs(mCSB_container[0].offsetLeft)-(distance[1]*_m((absDistance[1]/speed[1]),speed[1]))
                    ];
                    amount=o.axis==="yx" ? [a[0],a[1]] : o.axis==="x" ? [null,a[1]] : [a[0],null];
                    durB=[(absDistance[0]*4)+o.scrollInertia,(absDistance[1]*4)+o.scrollInertia];
                    var md=parseInt(o.contentTouchScroll) || 0; /* absolute minimum distance required */
                    amount[0]=absDistance[0]>md ? amount[0] : 0;
                    amount[1]=absDistance[1]>md ? amount[1] : 0;
                    if(d.overflowed[0]){_drag(amount[0],durB[0],easing,"y",overwrite,false);}
                    if(d.overflowed[1]){_drag(amount[1],durB[1],easing,"x",overwrite,false);}
                });
                function _m(ds,s){
                    var r=[s*1.5,s*2,s/1.5,s/2];
                    if(ds>90){
                        return s>4 ? r[0] : r[3];
                    }else if(ds>60){
                        return s>3 ? r[3] : r[2];
                    }else if(ds>30){
                        return s>8 ? r[1] : s>6 ? r[0] : s>4 ? s : r[2];
                    }else{
                        return s>8 ? s : r[3];
                    }
                }
                function _drag(amount,dur,easing,dir,overwrite,drag){
                    if(!amount){return;}
                    _scrollTo($this,amount.toString(),{dur:dur,scrollEasing:easing,dir:dir,overwrite:overwrite,drag:drag});
                }
            },
            /* -------------------- */
            
            
            /* 
            SELECT TEXT EVENTS 
            scrolls content when text is selected 
            */
            _selectable=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
                    namespace=pluginPfx+"_"+d.idx,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    action;
                mCSB_container.bind("mousedown."+namespace,function(e){
                    if(!action){action=1; touchActive=true;}
                }).add(document).bind("mousemove."+namespace,function(e){
                    if(action && _sel()){
                        var offset=mCSB_container.offset(),
                            y=_coordinates(e)[0]-offset.top+mCSB_container[0].offsetTop,x=_coordinates(e)[1]-offset.left+mCSB_container[0].offsetLeft;
                        if(y>0 && y<wrapper.height() && x>0 && x<wrapper.width()){
                            if(seq.step){_seq("off",null,"stepped");}
                        }else{
                            if(o.axis!=="x" && d.overflowed[0]){
                                if(y<0){
                                    _seq("on",38);
                                }else if(y>wrapper.height()){
                                    _seq("on",40);
                                }
                            }
                            if(o.axis!=="y" && d.overflowed[1]){
                                if(x<0){
                                    _seq("on",37);
                                }else if(x>wrapper.width()){
                                    _seq("on",39);
                                }
                            }
                        }
                    }
                }).bind("mouseup."+namespace,function(e){
                    if(action){action=0; _seq("off",null);}
                    touchActive=false;
                });
                function _sel(){
                    return  window.getSelection ? window.getSelection().toString() : 
                            document.selection && document.selection.type!="Control" ? document.selection.createRange().text : 0;
                }
                function _seq(a,c,s){
                    seq.type=s && action ? "stepped" : "stepless";
                    seq.scrollAmount=10;
                    _sequentialScroll($this,a,c,"mcsLinearOut",s ? 60 : null);
                }
            },
            /* -------------------- */
            
            
            /* 
            MOUSE WHEEL EVENT
            scrolls content via mouse-wheel 
            via mouse-wheel plugin (https://github.com/brandonaaron/jquery-mousewheel)
            */
            _mousewheel=function(){
                var $this=$(this),d=$this.data(pluginPfx);
                if(d){ /* Check if the scrollbar is ready to use mousewheel events (issue: #185) */
                    var o=d.opt,
                        namespace=pluginPfx+"_"+d.idx,
                        mCustomScrollBox=$("#mCSB_"+d.idx),
                        mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                        iframe=$("#mCSB_"+d.idx+"_container").find("iframe"),
                        el=mCustomScrollBox /* mousewheel element selector */;
                    /* check for cross domain iframes and bind mousewheel event on them in addition to default mousewheel element selector */
                    if(iframe.length){
                        iframe.each(function(){
                            var iFobj=this;
                            if(_canAccessIFrame(iFobj)){ /* check if iframe can be accessed */
                                el=el.add($(iFobj).contents().find("body"));
                            }
                        });
                    }
                    el.bind("mousewheel."+namespace,function(e,delta){
                        _stop($this);
                        if(_disableMousewheel($this,e.target)){return;} /* disables mouse-wheel when hovering specific elements */
                        var deltaFactor=o.mouseWheel.deltaFactor!=="auto" ? parseInt(o.mouseWheel.deltaFactor) : (oldIE && e.deltaFactor<100) ? 100 : e.deltaFactor || 100;
                        if(o.axis==="x" || o.mouseWheel.axis==="x"){
                            var dir="x",
                                px=[Math.round(deltaFactor*d.scrollRatio.x),parseInt(o.mouseWheel.scrollAmount)],
                                amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.width() ? mCustomScrollBox.width()*0.9 : px[0],
                                contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetLeft),
                                draggerPos=mCSB_dragger[1][0].offsetLeft,
                                limit=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
                                dlt=e.deltaX || e.deltaY || delta;
                        }else{
                            var dir="y",
                                px=[Math.round(deltaFactor*d.scrollRatio.y),parseInt(o.mouseWheel.scrollAmount)],
                                amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.height() ? mCustomScrollBox.height()*0.9 : px[0],
                                contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetTop),
                                draggerPos=mCSB_dragger[0][0].offsetTop,
                                limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
                                dlt=e.deltaY || delta;
                        }
                        if((dir==="y" && !d.overflowed[0]) || (dir==="x" && !d.overflowed[1])){return;}
                        if(o.mouseWheel.invert){dlt=-dlt;}
                        if(o.mouseWheel.normalizeDelta){dlt=dlt<0 ? -1 : 1;}
                        if((dlt>0 && draggerPos!==0) || (dlt<0 && draggerPos!==limit) || o.mouseWheel.preventDefault){
                            e.stopImmediatePropagation();
                            e.preventDefault();
                        }
                        _scrollTo($this,(contentPos-(dlt*amount)).toString(),{dir:dir});
                    });
                }
                /* check if iframe can be accessed */
                function _canAccessIFrame(iframe){
                    var html=null;
                    try{
                        var doc=iframe.contentDocument || iframe.contentWindow.document;
                        html=doc.body.innerHTML;
                    }catch(err){/* do nothing */}
                    return(html!==null);
                }
            },
            /* -------------------- */
            
            
            /* disables mouse-wheel when hovering specific elements like select, datalist etc. */
            _disableMousewheel=function(el,target){
                var tag=target.nodeName.toLowerCase(),
                    tags=el.data(pluginPfx).opt.mouseWheel.disableOver,
                    /* elements that require focus */
                    focusTags=["select","textarea"];
                return $.inArray(tag,tags) > -1 && !($.inArray(tag,focusTags) > -1 && !$(target).is(":focus"));
            },
            /* -------------------- */
            
            
            /* 
            DRAGGER RAIL CLICK EVENT
            scrolls content via dragger rail 
            */
            _draggerRail=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    namespace=pluginPfx+"_"+d.idx,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    mCSB_draggerContainer=$(".mCSB_"+d.idx+"_scrollbar ."+classes[12]);
                mCSB_draggerContainer.bind("touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
                    touchActive=true;
                }).bind("touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
                    touchActive=false;
                }).bind("click."+namespace,function(e){
                    if($(e.target).hasClass(classes[12]) || $(e.target).hasClass("mCSB_draggerRail")){
                        _stop($this);
                        var el=$(this),mCSB_dragger=el.find(".mCSB_dragger");
                        if(el.parent(".mCSB_scrollTools_horizontal").length>0){
                            if(!d.overflowed[1]){return;}
                            var dir="x",
                                clickDir=e.pageX>mCSB_dragger.offset().left ? -1 : 1,
                                to=Math.abs(mCSB_container[0].offsetLeft)-(clickDir*(wrapper.width()*0.9));
                        }else{
                            if(!d.overflowed[0]){return;}
                            var dir="y",
                                clickDir=e.pageY>mCSB_dragger.offset().top ? -1 : 1,
                                to=Math.abs(mCSB_container[0].offsetTop)-(clickDir*(wrapper.height()*0.9));
                        }
                        _scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
                    }
                });
            },
            /* -------------------- */
            
            
            /* 
            FOCUS EVENT
            scrolls content via element focus (e.g. clicking an input, pressing TAB key etc.)
            */
            _focus=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent();
                mCSB_container.bind("focusin."+namespace,function(e){
                    var el=$(document.activeElement),
                        nested=mCSB_container.find(".mCustomScrollBox").length,
                        dur=0;
                    if(!el.is(o.advanced.autoScrollOnFocus)){return;}
                    _stop($this);
                    clearTimeout($this[0]._focusTimeout);
                    $this[0]._focusTimer=nested ? (dur+17)*nested : 0;
                    $this[0]._focusTimeout=setTimeout(function(){
                        var to=[_childPos(el)[0],_childPos(el)[1]],
                            contentPos=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft],
                            isVisible=[
                                (contentPos[0]+to[0]>=0 && contentPos[0]+to[0]<wrapper.height()-el.outerHeight(false)),
                                (contentPos[1]+to[1]>=0 && contentPos[0]+to[1]<wrapper.width()-el.outerWidth(false))
                            ],
                            overwrite=(o.axis==="yx" && !isVisible[0] && !isVisible[1]) ? "none" : "all";
                        if(o.axis!=="x" && !isVisible[0]){
                            _scrollTo($this,to[0].toString(),{dir:"y",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
                        }
                        if(o.axis!=="y" && !isVisible[1]){
                            _scrollTo($this,to[1].toString(),{dir:"x",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
                        }
                    },$this[0]._focusTimer);
                });
            },
            /* -------------------- */
            
            
            /* sets content wrapper scrollTop/scrollLeft always to 0 */
            _wrapperScroll=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    namespace=pluginPfx+"_"+d.idx,
                    wrapper=$("#mCSB_"+d.idx+"_container").parent();
                wrapper.bind("scroll."+namespace,function(e){
                    if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){
                        $(".mCSB_"+d.idx+"_scrollbar").css("visibility","hidden"); /* hide scrollbar(s) */
                    }
                });
            },
            /* -------------------- */
            
            
            /* 
            BUTTONS EVENTS
            scrolls content via up, down, left and right buttons 
            */
            _buttons=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
                    namespace=pluginPfx+"_"+d.idx,
                    sel=".mCSB_"+d.idx+"_scrollbar",
                    btn=$(sel+">a");
                btn.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace+" mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace+" mouseout."+namespace+" pointerout."+namespace+" MSPointerOut."+namespace+" click."+namespace,function(e){
                    e.preventDefault();
                    if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
                    var btnClass=$(this).attr("class");
                    seq.type=o.scrollButtons.scrollType;
                    switch(e.type){
                        case "mousedown": case "touchstart": case "pointerdown": case "MSPointerDown":
                            if(seq.type==="stepped"){return;}
                            touchActive=true;
                            d.tweenRunning=false;
                            _seq("on",btnClass);
                            break;
                        case "mouseup": case "touchend": case "pointerup": case "MSPointerUp":
                        case "mouseout": case "pointerout": case "MSPointerOut":
                            if(seq.type==="stepped"){return;}
                            touchActive=false;
                            if(seq.dir){_seq("off",btnClass);}
                            break;
                        case "click":
                            if(seq.type!=="stepped" || d.tweenRunning){return;}
                            _seq("on",btnClass);
                            break;
                    }
                    function _seq(a,c){
                        seq.scrollAmount=o.snapAmount || o.scrollButtons.scrollAmount;
                        _sequentialScroll($this,a,c);
                    }
                });
            },
            /* -------------------- */
            
            
            /* 
            KEYBOARD EVENTS
            scrolls content via keyboard 
            Keys: up arrow, down arrow, left arrow, right arrow, PgUp, PgDn, Home, End
            */
            _keyboard=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
                    namespace=pluginPfx+"_"+d.idx,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    editables="input,textarea,select,datalist,keygen,[contenteditable='true']";
                mCustomScrollBox.attr("tabindex","0").bind("blur."+namespace+" keydown."+namespace+" keyup."+namespace,function(e){
                    switch(e.type){
                        case "blur":
                            if(d.tweenRunning && seq.dir){_seq("off",null);}
                            break;
                        case "keydown": case "keyup":
                            var code=e.keyCode ? e.keyCode : e.which,action="on";
                            if((o.axis!=="x" && (code===38 || code===40)) || (o.axis!=="y" && (code===37 || code===39))){
                                /* up (38), down (40), left (37), right (39) arrows */
                                if(((code===38 || code===40) && !d.overflowed[0]) || ((code===37 || code===39) && !d.overflowed[1])){return;}
                                if(e.type==="keyup"){action="off";}
                                if(!$(document.activeElement).is(editables)){
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                    _seq(action,code);
                                }
                            }else if(code===33 || code===34){
                                /* PgUp (33), PgDn (34) */
                                if(d.overflowed[0] || d.overflowed[1]){
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                }
                                if(e.type==="keyup"){
                                    _stop($this);
                                    var keyboardDir=code===34 ? -1 : 1;
                                    if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
                                        var dir="x",to=Math.abs(mCSB_container[0].offsetLeft)-(keyboardDir*(wrapper.width()*0.9));
                                    }else{
                                        var dir="y",to=Math.abs(mCSB_container[0].offsetTop)-(keyboardDir*(wrapper.height()*0.9));
                                    }
                                    _scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
                                }
                            }else if(code===35 || code===36){
                                /* End (35), Home (36) */
                                if(!$(document.activeElement).is(editables)){
                                    if(d.overflowed[0] || d.overflowed[1]){
                                        e.preventDefault();
                                        e.stopImmediatePropagation();
                                    }
                                    if(e.type==="keyup"){
                                        if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
                                            var dir="x",to=code===35 ? Math.abs(wrapper.width()-mCSB_container.outerWidth(false)) : 0;
                                        }else{
                                            var dir="y",to=code===35 ? Math.abs(wrapper.height()-mCSB_container.outerHeight(false)) : 0;
                                        }
                                        _scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
                                    }
                                }
                            }
                            break;
                    }
                    function _seq(a,c){
                        seq.type=o.keyboard.scrollType;
                        seq.scrollAmount=o.snapAmount || o.keyboard.scrollAmount;
                        if(seq.type==="stepped" && d.tweenRunning){return;}
                        _sequentialScroll($this,a,c);
                    }
                });
            },
            /* -------------------- */
            
            
            /* scrolls content sequentially (used when scrolling via buttons, keyboard arrows etc.) */
            _sequentialScroll=function(el,action,trigger,e,s){
                var d=el.data(pluginPfx),o=d.opt,seq=d.sequential,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    once=seq.type==="stepped" ? true : false;
                switch(action){
                    case "on":
                        seq.dir=[
                            (trigger===classes[16] || trigger===classes[15] || trigger===39 || trigger===37 ? "x" : "y"),
                            (trigger===classes[13] || trigger===classes[15] || trigger===38 || trigger===37 ? -1 : 1)
                        ];
                        _stop(el);
                        if(_isNumeric(trigger) && seq.type==="stepped"){return;}
                        _on(once);
                        break;
                    case "off":
                        _off();
                        if(once || (d.tweenRunning && seq.dir)){
                            _on(true);
                        }
                        break;
                }
                /* starts sequence */
                function _on(once){
                    var c=seq.type!=="stepped", /* continuous scrolling */
                        t=s ? s : !once ? 1000/60 : c ? o.scrollInertia/1.5 : o.scrollInertia, /* timer */
                        m=!once ? 2.5 : c ? 7.5 : 40, /* multiplier */
                        contentPos=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)],
                        ratio=[d.scrollRatio.y>10 ? 10 : d.scrollRatio.y,d.scrollRatio.x>10 ? 10 : d.scrollRatio.x],
                        amount=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*(ratio[1]*m)) : contentPos[0]+(seq.dir[1]*(ratio[0]*m)),
                        px=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*parseInt(seq.scrollAmount)) : contentPos[0]+(seq.dir[1]*parseInt(seq.scrollAmount)),
                        to=seq.scrollAmount!=="auto" ? px : amount,
                        easing=e ? e : !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
                        onComplete=!once ? false : true;
                    if(once && t<17){
                        to=seq.dir[0]==="x" ? contentPos[1] : contentPos[0];
                    }
                    _scrollTo(el,to.toString(),{dir:seq.dir[0],scrollEasing:easing,dur:t,onComplete:onComplete});
                    if(once){
                        seq.dir=false;
                        return;
                    }
                    clearTimeout(seq.step);
                    seq.step=setTimeout(function(){
                        _on();
                    },t);
                }
                /* stops sequence */
                function _off(){
                    clearTimeout(seq.step);
                    _delete(seq,"step");
                    _stop(el);
                }
            },
            /* -------------------- */
            
            
            /* returns a yx array from value */
            _arr=function(val){
                var o=$(this).data(pluginPfx).opt,vals=[];
                if(typeof val==="function"){val=val();} /* check if the value is a single anonymous function */
                /* check if value is object or array, its length and create an array with yx values */
                if(!(val instanceof Array)){ /* object value (e.g. {y:"100",x:"100"}, 100 etc.) */
                    vals[0]=val.y ? val.y : val.x || o.axis==="x" ? null : val;
                    vals[1]=val.x ? val.x : val.y || o.axis==="y" ? null : val;
                }else{ /* array value (e.g. [100,100]) */
                    vals=val.length>1 ? [val[0],val[1]] : o.axis==="x" ? [null,val[0]] : [val[0],null];
                }
                /* check if array values are anonymous functions */
                if(typeof vals[0]==="function"){vals[0]=vals[0]();}
                if(typeof vals[1]==="function"){vals[1]=vals[1]();}
                return vals;
            },
            /* -------------------- */
            
            
            /* translates values (e.g. "top", 100, "100px", "#id") to actual scroll-to positions */
            _to=function(val,dir){
                if(val==null || typeof val=="undefined"){return;}
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    t=typeof val;
                if(!dir){dir=o.axis==="x" ? "x" : "y";}
                var contentLength=dir==="x" ? mCSB_container.outerWidth(false) : mCSB_container.outerHeight(false),
                    contentPos=dir==="x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
                    cssProp=dir==="x" ? "left" : "top";
                switch(t){
                    case "function": /* this currently is not used. Consider removing it */
                        return val();
                        break;
                    case "object": /* js/jquery object */
                        var obj=val.jquery ? val : $(val);
                        if(!obj.length){return;}
                        return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
                        break;
                    case "string": case "number":
                        if(_isNumeric(val)){ /* numeric value */
                            return Math.abs(val);
                        }else if(val.indexOf("%")!==-1){ /* percentage value */
                            return Math.abs(contentLength*parseInt(val)/100);
                        }else if(val.indexOf("-=")!==-1){ /* decrease value */
                            return Math.abs(contentPos-parseInt(val.split("-=")[1]));
                        }else if(val.indexOf("+=")!==-1){ /* inrease value */
                            var p=(contentPos+parseInt(val.split("+=")[1]));
                            return p>=0 ? 0 : Math.abs(p);
                        }else if(val.indexOf("px")!==-1 && _isNumeric(val.split("px")[0])){ /* pixels string value (e.g. "100px") */
                            return Math.abs(val.split("px")[0]);
                        }else{
                            if(val==="top" || val==="left"){ /* special strings */
                                return 0;
                            }else if(val==="bottom"){
                                return Math.abs(wrapper.height()-mCSB_container.outerHeight(false));
                            }else if(val==="right"){
                                return Math.abs(wrapper.width()-mCSB_container.outerWidth(false));
                            }else if(val==="first" || val==="last"){
                                var obj=mCSB_container.find(":"+val);
                                return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
                            }else{
                                if($(val).length){ /* jquery selector */
                                    return dir==="x" ? _childPos($(val))[1] : _childPos($(val))[0];
                                }else{ /* other values (e.g. "100em") */
                                    mCSB_container.css(cssProp,val);
                                    methods.update.call(null,$this[0]);
                                    return;
                                }
                            }
                        }
                        break;
                }
            },
            /* -------------------- */
            
            
            /* calls the update method automatically */
            _autoUpdate=function(rem){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(rem){
                    /* 
                    removes autoUpdate timer 
                    usage: _autoUpdate.call(this,"remove");
                    */
                    clearTimeout(mCSB_container[0].autoUpdate);
                    _delete(mCSB_container[0],"autoUpdate");
                    return;
                }
                var wrapper=mCSB_container.parent(),
                    scrollbar=[$("#mCSB_"+d.idx+"_scrollbar_vertical"),$("#mCSB_"+d.idx+"_scrollbar_horizontal")],
                    scrollbarSize=function(){return [
                        scrollbar[0].is(":visible") ? scrollbar[0].outerHeight(true) : 0, /* returns y-scrollbar height */
                        scrollbar[1].is(":visible") ? scrollbar[1].outerWidth(true) : 0 /* returns x-scrollbar width */
                    ]},
                    oldSelSize=sizesSum(),newSelSize,
                    os=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false),wrapper.height(),wrapper.width(),scrollbarSize()[0],scrollbarSize()[1]],ns,
                    oldImgsLen=imgSum(),newImgsLen;
                upd();
                function upd(){
                    clearTimeout(mCSB_container[0].autoUpdate);
                    mCSB_container[0].autoUpdate=setTimeout(function(){
                        /* update on specific selector(s) length and size change */
                        if(o.advanced.updateOnSelectorChange){
                            newSelSize=sizesSum();
                            if(newSelSize!==oldSelSize){
                                doUpd(3);
                                oldSelSize=newSelSize;
                                return;
                            }
                        }
                        /* update on main element and scrollbar size changes */
                        if(o.advanced.updateOnContentResize){
                            ns=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false),wrapper.height(),wrapper.width(),scrollbarSize()[0],scrollbarSize()[1]];
                            if(ns[0]!==os[0] || ns[1]!==os[1] || ns[2]!==os[2] || ns[3]!==os[3] || ns[4]!==os[4] || ns[5]!==os[5]){
                                doUpd(ns[0]!==os[0] || ns[1]!==os[1]);
                                os=ns;
                            }
                        }
                        /* update on image load */
                        if(o.advanced.updateOnImageLoad){
                            newImgsLen=imgSum();
                            if(newImgsLen!==oldImgsLen){
                                mCSB_container.find("img").each(function(){
                                    imgLoader(this);
                                });
                                oldImgsLen=newImgsLen;
                            }
                        }
                        if(o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad){upd();}
                    },60);
                }
                /* returns images amount */
                function imgSum(){
                    var total=0;
                    if(o.advanced.updateOnImageLoad){total=mCSB_container.find("img").length;}
                    return total;
                }
                /* a tiny image loader */
                function imgLoader(el){
                    if($(el).hasClass(classes[2])){doUpd(); return;}
                    var img=new Image();
                    function createDelegate(contextObject,delegateMethod){
                        return function(){return delegateMethod.apply(contextObject,arguments);}
                    }
                    function imgOnLoad(){
                        this.onload=null;
                        $(el).addClass(classes[2]);
                        doUpd(2);
                    }
                    img.onload=createDelegate(img,imgOnLoad);
                    img.src=el.src;
                }
                /* returns the total height and width sum of all elements matching the selector */
                function sizesSum(){
                    if(o.advanced.updateOnSelectorChange===true){o.advanced.updateOnSelectorChange="*";}
                    var total=0,sel=mCSB_container.find(o.advanced.updateOnSelectorChange);
                    if(o.advanced.updateOnSelectorChange && sel.length>0){sel.each(function(){total+=$(this).height()+$(this).width();});}
                    return total;
                }
                /* calls the update method */
                function doUpd(cb){
                    clearTimeout(mCSB_container[0].autoUpdate); 
                    methods.update.call(null,$this[0],cb);
                }
            },
            /* -------------------- */
            
            
            /* snaps scrolling to a multiple of a pixels number */
            _snapAmount=function(to,amount,offset){
                return (Math.round(to/amount)*amount-offset); 
            },
            /* -------------------- */
            
            
            /* stops content and scrollbar animations */
            _stop=function(el){
                var d=el.data(pluginPfx),
                    sel=$("#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal");
                sel.each(function(){
                    _stopTween.call(this);
                });
            },
            /* -------------------- */
            
            
            /* 
            ANIMATES CONTENT 
            This is where the actual scrolling happens
            */
            _scrollTo=function(el,to,options){
                var d=el.data(pluginPfx),o=d.opt,
                    defaults={
                        trigger:"internal",
                        dir:"y",
                        scrollEasing:"mcsEaseOut",
                        drag:false,
                        dur:o.scrollInertia,
                        overwrite:"all",
                        callbacks:true,
                        onStart:true,
                        onUpdate:true,
                        onComplete:true
                    },
                    options=$.extend(defaults,options),
                    dur=[options.dur,(options.drag ? 0 : options.dur)],
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    totalScrollOffsets=o.callbacks.onTotalScrollOffset ? _arr.call(el,o.callbacks.onTotalScrollOffset) : [0,0],
                    totalScrollBackOffsets=o.callbacks.onTotalScrollBackOffset ? _arr.call(el,o.callbacks.onTotalScrollBackOffset) : [0,0];
                d.trigger=options.trigger;
                if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){ /* always reset scrollTop/Left */
                    $(".mCSB_"+d.idx+"_scrollbar").css("visibility","visible");
                    wrapper.scrollTop(0).scrollLeft(0);
                }
                if(to==="_resetY" && !d.contentReset.y){
                    /* callbacks: onOverflowYNone */
                    if(_cb("onOverflowYNone")){o.callbacks.onOverflowYNone.call(el[0]);}
                    d.contentReset.y=1;
                }
                if(to==="_resetX" && !d.contentReset.x){
                    /* callbacks: onOverflowXNone */
                    if(_cb("onOverflowXNone")){o.callbacks.onOverflowXNone.call(el[0]);}
                    d.contentReset.x=1;
                }
                if(to==="_resetY" || to==="_resetX"){return;}
                if((d.contentReset.y || !el[0].mcs) && d.overflowed[0]){
                    /* callbacks: onOverflowY */
                    if(_cb("onOverflowY")){o.callbacks.onOverflowY.call(el[0]);}
                    d.contentReset.x=null;
                }
                if((d.contentReset.x || !el[0].mcs) && d.overflowed[1]){
                    /* callbacks: onOverflowX */
                    if(_cb("onOverflowX")){o.callbacks.onOverflowX.call(el[0]);}
                    d.contentReset.x=null;
                }
                if(o.snapAmount){to=_snapAmount(to,o.snapAmount,o.snapOffset);} /* scrolling snapping */
                switch(options.dir){
                    case "x":
                        var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_horizontal"),
                            property="left",
                            contentPos=mCSB_container[0].offsetLeft,
                            limit=[
                                mCustomScrollBox.width()-mCSB_container.outerWidth(false),
                                mCSB_dragger.parent().width()-mCSB_dragger.width()
                            ],
                            scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.x)],
                            tso=totalScrollOffsets[1],
                            tsbo=totalScrollBackOffsets[1],
                            totalScrollOffset=tso>0 ? tso/d.scrollRatio.x : 0,
                            totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.x : 0;
                        break;
                    case "y":
                        var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_vertical"),
                            property="top",
                            contentPos=mCSB_container[0].offsetTop,
                            limit=[
                                mCustomScrollBox.height()-mCSB_container.outerHeight(false),
                                mCSB_dragger.parent().height()-mCSB_dragger.height()
                            ],
                            scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.y)],
                            tso=totalScrollOffsets[0],
                            tsbo=totalScrollBackOffsets[0],
                            totalScrollOffset=tso>0 ? tso/d.scrollRatio.y : 0,
                            totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.y : 0;
                        break;
                }
                if(scrollTo[1]<0 || (scrollTo[0]===0 && scrollTo[1]===0)){
                    scrollTo=[0,0];
                }else if(scrollTo[1]>=limit[1]){
                    scrollTo=[limit[0],limit[1]];
                }else{
                    scrollTo[0]=-scrollTo[0];
                }
                if(!el[0].mcs){
                    _mcs();  /* init mcs object (once) to make it available before callbacks */
                    if(_cb("onInit")){o.callbacks.onInit.call(el[0]);} /* callbacks: onInit */
                }
                clearTimeout(mCSB_container[0].onCompleteTimeout);
                if(!d.tweenRunning && ((contentPos===0 && scrollTo[0]>=0) || (contentPos===limit[0] && scrollTo[0]<=limit[0]))){return;}
                _tweenTo(mCSB_dragger[0],property,Math.round(scrollTo[1]),dur[1],options.scrollEasing);
                _tweenTo(mCSB_container[0],property,Math.round(scrollTo[0]),dur[0],options.scrollEasing,options.overwrite,{
                    onStart:function(){
                        if(options.callbacks && options.onStart && !d.tweenRunning){
                            /* callbacks: onScrollStart */
                            if(_cb("onScrollStart")){_mcs(); o.callbacks.onScrollStart.call(el[0]);}
                            d.tweenRunning=true;
                            _onDragClasses(mCSB_dragger);
                            d.cbOffsets=_cbOffsets();
                        }
                    },onUpdate:function(){
                        if(options.callbacks && options.onUpdate){
                            /* callbacks: whileScrolling */
                            if(_cb("whileScrolling")){_mcs(); o.callbacks.whileScrolling.call(el[0]);}
                        }
                    },onComplete:function(){
                        if(options.callbacks && options.onComplete){
                            if(o.axis==="yx"){clearTimeout(mCSB_container[0].onCompleteTimeout);}
                            var t=mCSB_container[0].idleTimer || 0;
                            mCSB_container[0].onCompleteTimeout=setTimeout(function(){
                                /* callbacks: onScroll, onTotalScroll, onTotalScrollBack */
                                if(_cb("onScroll")){_mcs(); o.callbacks.onScroll.call(el[0]);}
                                if(_cb("onTotalScroll") && scrollTo[1]>=limit[1]-totalScrollOffset && d.cbOffsets[0]){_mcs(); o.callbacks.onTotalScroll.call(el[0]);}
                                if(_cb("onTotalScrollBack") && scrollTo[1]<=totalScrollBackOffset && d.cbOffsets[1]){_mcs(); o.callbacks.onTotalScrollBack.call(el[0]);}
                                d.tweenRunning=false;
                                mCSB_container[0].idleTimer=0;
                                _onDragClasses(mCSB_dragger,"hide");
                            },t);
                        }
                    }
                });
                /* checks if callback function exists */
                function _cb(cb){
                    return d && o.callbacks[cb] && typeof o.callbacks[cb]==="function";
                }
                /* checks whether callback offsets always trigger */
                function _cbOffsets(){
                    return [o.callbacks.alwaysTriggerOffsets || contentPos>=limit[0]+tso,o.callbacks.alwaysTriggerOffsets || contentPos<=-tsbo];
                }
                /* 
                populates object with useful values for the user 
                values: 
                    content: this.mcs.content
                    content top position: this.mcs.top 
                    content left position: this.mcs.left 
                    dragger top position: this.mcs.draggerTop 
                    dragger left position: this.mcs.draggerLeft 
                    scrolling y percentage: this.mcs.topPct 
                    scrolling x percentage: this.mcs.leftPct 
                    scrolling direction: this.mcs.direction
                */
                function _mcs(){
                    var cp=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft], /* content position */
                        dp=[mCSB_dragger[0].offsetTop,mCSB_dragger[0].offsetLeft], /* dragger position */
                        cl=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false)], /* content length */
                        pl=[mCustomScrollBox.height(),mCustomScrollBox.width()]; /* content parent length */
                    el[0].mcs={
                        content:mCSB_container, /* original content wrapper as jquery object */
                        top:cp[0],left:cp[1],draggerTop:dp[0],draggerLeft:dp[1],
                        topPct:Math.round((100*Math.abs(cp[0]))/(Math.abs(cl[0])-pl[0])),leftPct:Math.round((100*Math.abs(cp[1]))/(Math.abs(cl[1])-pl[1])),
                        direction:options.dir
                    };
                    /* 
                    this refers to the original element containing the scrollbar(s)
                    usage: this.mcs.top, this.mcs.leftPct etc. 
                    */
                }
            },
            /* -------------------- */
            
            
            /* 
            CUSTOM JAVASCRIPT ANIMATION TWEEN 
            Lighter and faster than jquery animate() and css transitions 
            Animates top/left properties and includes easings 
            */
            _tweenTo=function(el,prop,to,duration,easing,overwrite,callbacks){
                if(!el._mTween){el._mTween={top:{},left:{}};}
                var callbacks=callbacks || {},
                    onStart=callbacks.onStart || function(){},onUpdate=callbacks.onUpdate || function(){},onComplete=callbacks.onComplete || function(){},
                    startTime=_getTime(),_delay,progress=0,from=el.offsetTop,elStyle=el.style,_request,tobj=el._mTween[prop];
                if(prop==="left"){from=el.offsetLeft;}
                var diff=to-from;
                tobj.stop=0;
                if(overwrite!=="none"){_cancelTween();}
                _startTween();
                function _step(){
                    if(tobj.stop){return;}
                    if(!progress){onStart.call();}
                    progress=_getTime()-startTime;
                    _tween();
                    if(progress>=tobj.time){
                        tobj.time=(progress>tobj.time) ? progress+_delay-(progress-tobj.time) : progress+_delay-1;
                        if(tobj.time<progress+1){tobj.time=progress+1;}
                    }
                    if(tobj.time<duration){tobj.id=_request(_step);}else{onComplete.call();}
                }
                function _tween(){
                    if(duration>0){
                        tobj.currVal=_ease(tobj.time,from,diff,duration,easing);
                        elStyle[prop]=Math.round(tobj.currVal)+"px";
                    }else{
                        elStyle[prop]=to+"px";
                    }
                    onUpdate.call();
                }
                function _startTween(){
                    _delay=1000/60;
                    tobj.time=progress+_delay;
                    _request=(!window.requestAnimationFrame) ? function(f){_tween(); return setTimeout(f,0.01);} : window.requestAnimationFrame;
                    tobj.id=_request(_step);
                }
                function _cancelTween(){
                    if(tobj.id==null){return;}
                    if(!window.requestAnimationFrame){clearTimeout(tobj.id);
                    }else{window.cancelAnimationFrame(tobj.id);}
                    tobj.id=null;
                }
                function _ease(t,b,c,d,type){
                    switch(type){
                        case "linear": case "mcsLinear":
                            return c*t/d + b;
                            break;
                        case "mcsLinearOut":
                            t/=d; t--; return c * Math.sqrt(1 - t*t) + b;
                            break;
                        case "easeInOutSmooth":
                            t/=d/2;
                            if(t<1) return c/2*t*t + b;
                            t--;
                            return -c/2 * (t*(t-2) - 1) + b;
                            break;
                        case "easeInOutStrong":
                            t/=d/2;
                            if(t<1) return c/2 * Math.pow( 2, 10 * (t - 1) ) + b;
                            t--;
                            return c/2 * ( -Math.pow( 2, -10 * t) + 2 ) + b;
                            break;
                        case "easeInOut": case "mcsEaseInOut":
                            t/=d/2;
                            if(t<1) return c/2*t*t*t + b;
                            t-=2;
                            return c/2*(t*t*t + 2) + b;
                            break;
                        case "easeOutSmooth":
                            t/=d; t--;
                            return -c * (t*t*t*t - 1) + b;
                            break;
                        case "easeOutStrong":
                            return c * ( -Math.pow( 2, -10 * t/d ) + 1 ) + b;
                            break;
                        case "easeOut": case "mcsEaseOut": default:
                            var ts=(t/=d)*t,tc=ts*t;
                            return b+c*(0.499999999999997*tc*ts + -2.5*ts*ts + 5.5*tc + -6.5*ts + 4*t);
                    }
                }
            },
            /* -------------------- */
            
            
            /* returns current time */
            _getTime=function(){
                if(window.performance && window.performance.now){
                    return window.performance.now();
                }else{
                    if(window.performance && window.performance.webkitNow){
                        return window.performance.webkitNow();
                    }else{
                        if(Date.now){return Date.now();}else{return new Date().getTime();}
                    }
                }
            },
            /* -------------------- */
            
            
            /* stops a tween */
            _stopTween=function(){
                var el=this;
                if(!el._mTween){el._mTween={top:{},left:{}};}
                var props=["top","left"];
                for(var i=0; i<props.length; i++){
                    var prop=props[i];
                    if(el._mTween[prop].id){
                        if(!window.requestAnimationFrame){clearTimeout(el._mTween[prop].id);
                        }else{window.cancelAnimationFrame(el._mTween[prop].id);}
                        el._mTween[prop].id=null;
                        el._mTween[prop].stop=1;
                    }
                }
            },
            /* -------------------- */
            
            
            /* deletes a property (avoiding the exception thrown by IE) */
            _delete=function(c,m){
                try{delete c[m];}catch(e){c[m]=null;}
            },
            /* -------------------- */
            
            
            /* detects left mouse button */
            _mouseBtnLeft=function(e){
                return !(e.which && e.which!==1);
            },
            /* -------------------- */
            
            
            /* detects if pointer type event is touch */
            _pointerTouch=function(e){
                var t=e.originalEvent.pointerType;
                return !(t && t!=="touch" && t!==2);
            },
            /* -------------------- */
            
            
            /* checks if value is numeric */
            _isNumeric=function(val){
                return !isNaN(parseFloat(val)) && isFinite(val);
            },
            /* -------------------- */
            
            
            /* returns element position according to content */
            _childPos=function(el){
                var p=el.parents(".mCSB_container");
                return [el.offset().top-p.offset().top,el.offset().left-p.offset().left];
            };
            /* -------------------- */
            
        
        
        
        
        /* 
        ----------------------------------------
        PLUGIN SETUP 
        ----------------------------------------
        */
        
        /* plugin constructor functions */
        $.fn[pluginNS]=function(method){ /* usage: $(selector).mCustomScrollbar(); */
            if(methods[method]){
                return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
            }else if(typeof method==="object" || !method){
                return methods.init.apply(this,arguments);
            }else{
                $.error("Method "+method+" does not exist");
            }
        };
        $[pluginNS]=function(method){ /* usage: $.mCustomScrollbar(); */
            if(methods[method]){
                return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
            }else if(typeof method==="object" || !method){
                return methods.init.apply(this,arguments);
            }else{
                $.error("Method "+method+" does not exist");
            }
        };
        
        /* 
        allow setting plugin default options. 
        usage: $.mCustomScrollbar.defaults.scrollInertia=500; 
        to apply any changed default options on default selectors (below), use inside document ready fn 
        e.g.: $(document).ready(function(){ $.mCustomScrollbar.defaults.scrollInertia=500; });
        */
        $[pluginNS].defaults=defaults;
        
        /* 
        add window object (window.mCustomScrollbar) 
        usage: if(window.mCustomScrollbar){console.log("custom scrollbar plugin loaded");}
        */
        window[pluginNS]=true;
        
        $(window).load(function(){
            
            $(defaultSelector)[pluginNS](); /* add scrollbars automatically on default selector */
            
            /* extend jQuery expressions */
            $.extend($.expr[":"],{
                /* checks if element is within scrollable viewport */
                mcsInView:$.expr[":"].mcsInView || function(el){
                    var $el=$(el),content=$el.parents(".mCSB_container"),wrapper,cPos;
                    if(!content.length){return;}
                    wrapper=content.parent();
                    cPos=[content[0].offsetTop,content[0].offsetLeft];
                    return  cPos[0]+_childPos($el)[0]>=0 && cPos[0]+_childPos($el)[0]<wrapper.height()-$el.outerHeight(false) && 
                            cPos[1]+_childPos($el)[1]>=0 && cPos[1]+_childPos($el)[1]<wrapper.width()-$el.outerWidth(false);
                },
                /* checks if element is overflowed having visible scrollbar(s) */
                mcsOverflow:$.expr[":"].mcsOverflow || function(el){
                    var d=$(el).data(pluginPfx);
                    if(!d){return;}
                    return d.overflowed[0] || d.overflowed[1];
                }
            });
        
        });

    }))}(jQuery,window,document));
/*-------------------------------  SELECT2  -------------------------------*/

    /*
    Copyright 2012 Igor Vaynberg

    Version: 3.5.2 Timestamp: Sat Nov  1 14:43:36 EDT 2014

    This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
    General Public License version 2 (the "GPL License"). You may choose either license to govern your
    use of this software only upon the condition that you accept all of the terms of either the Apache
    License or the GPL License.

    You may obtain a copy of the Apache License and the GPL License at:

        http://www.apache.org/licenses/LICENSE-2.0
        http://www.gnu.org/licenses/gpl-2.0.html

    Unless required by applicable law or agreed to in writing, software distributed under the
    Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
    CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
    the specific language governing permissions and limitations under the Apache License and the GPL License.
    */
    (function ($) {
        if(typeof $.fn.each2 == "undefined") {
            $.extend($.fn, {
                /*
                * 4-10 times faster .each replacement
                * use it carefully, as it overrides jQuery context of element on each iteration
                */
                each2 : function (c) {
                    var j = $([0]), i = -1, l = this.length;
                    while (
                        ++i < l
                        && (j.context = j[0] = this[i])
                        && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                    );
                    return this;
                }
            });
        }
    })(jQuery);

    (function ($, undefined) {
        "use strict";
        /*global document, window, jQuery, console */

        if (window.Select2 !== undefined) {
            return;
        }

        var AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
            lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

        KEY = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            isArrow: function (k) {
                k = k.which ? k.which : k;
                switch (k) {
                case KEY.LEFT:
                case KEY.RIGHT:
                case KEY.UP:
                case KEY.DOWN:
                    return true;
                }
                return false;
            },
            isControl: function (e) {
                var k = e.which;
                switch (k) {
                case KEY.SHIFT:
                case KEY.CTRL:
                case KEY.ALT:
                    return true;
                }

                if (e.metaKey) return true;

                return false;
            },
            isFunctionKey: function (k) {
                k = k.which ? k.which : k;
                return k >= 112 && k <= 123;
            }
        },
        MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

        DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z","\u0386":"\u0391","\u0388":"\u0395","\u0389":"\u0397","\u038A":"\u0399","\u03AA":"\u0399","\u038C":"\u039F","\u038E":"\u03A5","\u03AB":"\u03A5","\u038F":"\u03A9","\u03AC":"\u03B1","\u03AD":"\u03B5","\u03AE":"\u03B7","\u03AF":"\u03B9","\u03CA":"\u03B9","\u0390":"\u03B9","\u03CC":"\u03BF","\u03CD":"\u03C5","\u03CB":"\u03C5","\u03B0":"\u03C5","\u03C9":"\u03C9","\u03C2":"\u03C3"};

        $document = $(document);

        nextUid=(function() { var counter=1; return function() { return counter++; }; }());


        function reinsertElement(element) {
            var placeholder = $(document.createTextNode(''));

            element.before(placeholder);
            placeholder.before(element);
            placeholder.remove();
        }

        function stripDiacritics(str) {
            // Used 'uni range + named function' from http://jsperf.com/diacritics/18
            function match(a) {
                return DIACRITICS[a] || a;
            }

            return str.replace(/[^\u0000-\u007E]/g, match);
        }

        function indexOf(value, array) {
            var i = 0, l = array.length;
            for (; i < l; i = i + 1) {
                if (equal(value, array[i])) return i;
            }
            return -1;
        }

        function measureScrollbar () {
            var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
            $template.appendTo(document.body);

            var dim = {
                width: $template.width() - $template[0].clientWidth,
                height: $template.height() - $template[0].clientHeight
            };
            $template.remove();

            return dim;
        }

        /**
         * Compares equality of a and b
         * @param a
         * @param b
         */
        function equal(a, b) {
            if (a === b) return true;
            if (a === undefined || b === undefined) return false;
            if (a === null || b === null) return false;
            // Check whether 'a' or 'b' is a string (primitive or object).
            // The concatenation of an empty string (+'') converts its argument to a string's primitive.
            if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
            if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
            return false;
        }

        /**
         * Splits the string into an array of values, transforming each value. An empty array is returned for nulls or empty
         * strings
         * @param string
         * @param separator
         */
        function splitVal(string, separator, transform) {
            var val, i, l;
            if (string === null || string.length < 1) return [];
            val = string.split(separator);
            for (i = 0, l = val.length; i < l; i = i + 1) val[i] = transform(val[i]);
            return val;
        }

        function getSideBorderPadding(element) {
            return element.outerWidth(false) - element.width();
        }

        function installKeyUpChangeEvent(element) {
            var key="keyup-change-value";
            element.on("keydown", function () {
                if ($.data(element, key) === undefined) {
                    $.data(element, key, element.val());
                }
            });
            element.on("keyup", function () {
                var val= $.data(element, key);
                if (val !== undefined && element.val() !== val) {
                    $.removeData(element, key);
                    element.trigger("keyup-change");
                }
            });
        }


        /**
         * filters mouse events so an event is fired only if the mouse moved.
         *
         * filters out mouse events that occur when mouse is stationary but
         * the elements under the pointer are scrolled.
         */
        function installFilteredMouseMove(element) {
            element.on("mousemove", function (e) {
                var lastpos = lastMousePosition;
                if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                    $(e.target).trigger("mousemove-filtered", e);
                }
            });
        }

        /**
         * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
         * within the last quietMillis milliseconds.
         *
         * @param quietMillis number of milliseconds to wait before invoking fn
         * @param fn function to be debounced
         * @param ctx object to be used as this reference within fn
         * @return debounced version of fn
         */
        function debounce(quietMillis, fn, ctx) {
            ctx = ctx || undefined;
            var timeout;
            return function () {
                var args = arguments;
                window.clearTimeout(timeout);
                timeout = window.setTimeout(function() {
                    fn.apply(ctx, args);
                }, quietMillis);
            };
        }

        function installDebouncedScroll(threshold, element) {
            var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
            element.on("scroll", function (e) {
                if (indexOf(e.target, element.get()) >= 0) notify(e);
            });
        }

        function focus($el) {
            if ($el[0] === document.activeElement) return;

            /* set the focus in a 0 timeout - that way the focus is set after the processing
                of the current event has finished - which seems like the only reliable way
                to set focus */
            window.setTimeout(function() {
                var el=$el[0], pos=$el.val().length, range;

                $el.focus();

                /* make sure el received focus so we do not error out when trying to manipulate the caret.
                    sometimes modals or others listeners may steal it after its set */
                var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
                if (isVisible && el === document.activeElement) {

                    /* after the focus is set move the caret to the end, necessary when we val()
                        just before setting focus */
                    if(el.setSelectionRange)
                    {
                        el.setSelectionRange(pos, pos);
                    }
                    else if (el.createTextRange) {
                        range = el.createTextRange();
                        range.collapse(false);
                        range.select();
                    }
                }
            }, 0);
        }

        function getCursorInfo(el) {
            el = $(el)[0];
            var offset = 0;
            var length = 0;
            if ('selectionStart' in el) {
                offset = el.selectionStart;
                length = el.selectionEnd - offset;
            } else if ('selection' in document) {
                el.focus();
                var sel = document.selection.createRange();
                length = document.selection.createRange().text.length;
                sel.moveStart('character', -el.value.length);
                offset = sel.text.length - length;
            }
            return { offset: offset, length: length };
        }

        function killEvent(event) {
            event.preventDefault();
            event.stopPropagation();
        }
        function killEventImmediately(event) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }

        function measureTextWidth(e) {
            if (!sizer){
                var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
                sizer = $(document.createElement("div")).css({
                    position: "absolute",
                    left: "-10000px",
                    top: "-10000px",
                    display: "none",
                    fontSize: style.fontSize,
                    fontFamily: style.fontFamily,
                    fontStyle: style.fontStyle,
                    fontWeight: style.fontWeight,
                    letterSpacing: style.letterSpacing,
                    textTransform: style.textTransform,
                    whiteSpace: "nowrap"
                });
                sizer.attr("class","select2-sizer");
                $(document.body).append(sizer);
            }
            sizer.text(e.val());
            return sizer.width();
        }

        function syncCssClasses(dest, src, adapter) {
            var classes, replacements = [], adapted;

            classes = $.trim(dest.attr("class"));

            if (classes) {
                classes = '' + classes; // for IE which returns object

                $(classes.split(/\s+/)).each2(function() {
                    if (this.indexOf("select2-") === 0) {
                        replacements.push(this);
                    }
                });
            }

            classes = $.trim(src.attr("class"));

            if (classes) {
                classes = '' + classes; // for IE which returns object

                $(classes.split(/\s+/)).each2(function() {
                    if (this.indexOf("select2-") !== 0) {
                        adapted = adapter(this);

                        if (adapted) {
                            replacements.push(adapted);
                        }
                    }
                });
            }

            dest.attr("class", replacements.join(" "));
        }


        function markMatch(text, term, markup, escapeMarkup) {
            var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
                tl=term.length;

            if (match<0) {
                markup.push(escapeMarkup(text));
                return;
            }

            markup.push(escapeMarkup(text.substring(0, match)));
            markup.push("<span class='select2-match'>");
            markup.push(escapeMarkup(text.substring(match, match + tl)));
            markup.push("</span>");
            markup.push(escapeMarkup(text.substring(match + tl, text.length)));
        }

        function defaultEscapeMarkup(markup) {
            var replace_map = {
                '\\': '&#92;',
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#47;'
            };

            return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
                return replace_map[match];
            });
        }

        /**
         * Produces an ajax-based query function
         *
         * @param options object containing configuration parameters
         * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
         * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
         * @param options.url url for the data
         * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
         * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
         * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
         * @param options.results a function(remoteData, pageNumber, query) that converts data returned form the remote request to the format expected by Select2.
         *      The expected format is an object containing the following keys:
         *      results array of objects that will be used as choices
         *      more (optional) boolean indicating whether there are more results available
         *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
         */
        function ajax(options) {
            var timeout, // current scheduled but not yet executed request
                handler = null,
                quietMillis = options.quietMillis || 100,
                ajaxUrl = options.url,
                self = this;

            return function (query) {
                window.clearTimeout(timeout);
                timeout = window.setTimeout(function () {
                    var data = options.data, // ajax data function
                        url = ajaxUrl, // ajax url string or function
                        transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                        // deprecated - to be removed in 4.0  - use params instead
                        deprecated = {
                            type: options.type || 'GET', // set type of request (GET or POST)
                            cache: options.cache || false,
                            jsonpCallback: options.jsonpCallback||undefined,
                            dataType: options.dataType||"json"
                        },
                        params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                    data = data ? data.call(self, query.term, query.page, query.context) : null;
                    url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                    if (handler && typeof handler.abort === "function") { handler.abort(); }

                    if (options.params) {
                        if ($.isFunction(options.params)) {
                            $.extend(params, options.params.call(self));
                        } else {
                            $.extend(params, options.params);
                        }
                    }

                    $.extend(params, {
                        url: url,
                        dataType: options.dataType,
                        data: data,
                        success: function (data) {
                            // TODO - replace query.page with query so users have access to term, page, etc.
                            // added query as third paramter to keep backwards compatibility
                            var results = options.results(data, query.page, query);
                            query.callback(results);
                        },
                        error: function(jqXHR, textStatus, errorThrown){
                            var results = {
                                hasError: true,
                                jqXHR: jqXHR,
                                textStatus: textStatus,
                                errorThrown: errorThrown
                            };

                            query.callback(results);
                        }
                    });
                    handler = transport.call(self, params);
                }, quietMillis);
            };
        }

        /**
         * Produces a query function that works with a local array
         *
         * @param options object containing configuration parameters. The options parameter can either be an array or an
         * object.
         *
         * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
         *
         * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
         * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
         * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
         * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
         * the text.
         */
        function local(options) {
            var data = options, // data elements
                dataText,
                tmp,
                text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

             if ($.isArray(data)) {
                tmp = data;
                data = { results: tmp };
            }

             if ($.isFunction(data) === false) {
                tmp = data;
                data = function() { return tmp; };
            }

            var dataItem = data();
            if (dataItem.text) {
                text = dataItem.text;
                // if text is not a function we assume it to be a key name
                if (!$.isFunction(text)) {
                    dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                    text = function (item) { return item[dataText]; };
                }
            }

            return function (query) {
                var t = query.term, filtered = { results: [] }, process;
                if (t === "") {
                    query.callback(data());
                    return;
                }

                process = function(datum, collection) {
                    var group, attr;
                    datum = datum[0];
                    if (datum.children) {
                        group = {};
                        for (attr in datum) {
                            if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                        }
                        group.children=[];
                        $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                        if (group.children.length || query.matcher(t, text(group), datum)) {
                            collection.push(group);
                        }
                    } else {
                        if (query.matcher(t, text(datum), datum)) {
                            collection.push(datum);
                        }
                    }
                };

                $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
                query.callback(filtered);
            };
        }

        // TODO javadoc
        function tags(data) {
            var isFunc = $.isFunction(data);
            return function (query) {
                var t = query.term, filtered = {results: []};
                var result = isFunc ? data(query) : data;
                if ($.isArray(result)) {
                    $(result).each(function () {
                        var isObject = this.text !== undefined,
                            text = isObject ? this.text : this;
                        if (t === "" || query.matcher(t, text)) {
                            filtered.results.push(isObject ? this : {id: this, text: this});
                        }
                    });
                    query.callback(filtered);
                }
            };
        }

        /**
         * Checks if the formatter function should be used.
         *
         * Throws an error if it is not a function. Returns true if it should be used,
         * false if no formatting should be performed.
         *
         * @param formatter
         */
        function checkFormatter(formatter, formatterName) {
            if ($.isFunction(formatter)) return true;
            if (!formatter) return false;
            if (typeof(formatter) === 'string') return true;
            throw new Error(formatterName +" must be a string, function, or falsy value");
        }

      /**
       * Returns a given value
       * If given a function, returns its output
       *
       * @param val string|function
       * @param context value of "this" to be passed to function
       * @returns {*}
       */
        function evaluate(val, context) {
            if ($.isFunction(val)) {
                var args = Array.prototype.slice.call(arguments, 2);
                return val.apply(context, args);
            }
            return val;
        }

        function countResults(results) {
            var count = 0;
            $.each(results, function(i, item) {
                if (item.children) {
                    count += countResults(item.children);
                } else {
                    count++;
                }
            });
            return count;
        }

        /**
         * Default tokenizer. This function uses breaks the input on substring match of any string from the
         * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
         * two options have to be defined in order for the tokenizer to work.
         *
         * @param input text user has typed so far or pasted into the search field
         * @param selection currently selected choices
         * @param selectCallback function(choice) callback tho add the choice to selection
         * @param opts select2's opts
         * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
         */
        function defaultTokenizer(input, selection, selectCallback, opts) {
            var original = input, // store the original so we can compare and know if we need to tell the search to update its text
                dupe = false, // check for whether a token we extracted represents a duplicate selected choice
                token, // token
                index, // position at which the separator was found
                i, l, // looping variables
                separator; // the matched separator

            if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

            while (true) {
                index = -1;

                for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                    separator = opts.tokenSeparators[i];
                    index = input.indexOf(separator);
                    if (index >= 0) break;
                }

                if (index < 0) break; // did not find any token separator in the input string, bail

                token = input.substring(0, index);
                input = input.substring(index + separator.length);

                if (token.length > 0) {
                    token = opts.createSearchChoice.call(this, token, selection);
                    if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                        dupe = false;
                        for (i = 0, l = selection.length; i < l; i++) {
                            if (equal(opts.id(token), opts.id(selection[i]))) {
                                dupe = true; break;
                            }
                        }

                        if (!dupe) selectCallback(token);
                    }
                }
            }

            if (original!==input) return input;
        }

        function cleanupJQueryElements() {
            var self = this;

            $.each(arguments, function (i, element) {
                self[element].remove();
                self[element] = null;
            });
        }

        /**
         * Creates a new class
         *
         * @param superClass
         * @param methods
         */
        function clazz(SuperClass, methods) {
            var constructor = function () {};
            constructor.prototype = new SuperClass;
            constructor.prototype.constructor = constructor;
            constructor.prototype.parent = SuperClass.prototype;
            constructor.prototype = $.extend(constructor.prototype, methods);
            return constructor;
        }

        AbstractSelect2 = clazz(Object, {

            // abstract
            bind: function (func) {
                var self = this;
                return function () {
                    func.apply(self, arguments);
                };
            },

            // abstract
            init: function (opts) {
                var results, search, resultsSelector = ".select2-results";

                // prepare options
                this.opts = opts = this.prepareOpts(opts);

                this.id=opts.id;

                // destroy if called on an existing component
                if (opts.element.data("select2") !== undefined &&
                    opts.element.data("select2") !== null) {
                    opts.element.data("select2").destroy();
                }

                this.container = this.createContainer();

                this.liveRegion = $('.select2-hidden-accessible');
                if (this.liveRegion.length == 0) {
                    this.liveRegion = $("<span>", {
                            role: "status",
                            "aria-live": "polite"
                        })
                        .addClass("select2-hidden-accessible")
                        .appendTo(document.body);
                }

                this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
                this.containerEventName= this.containerId
                    .replace(/([.])/g, '_')
                    .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
                this.container.attr("id", this.containerId);

                this.container.attr("title", opts.element.attr("title"));

                this.body = $(document.body);

                syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

                this.container.attr("style", opts.element.attr("style"));
                this.container.css(evaluate(opts.containerCss, this.opts.element));
                this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));

                this.elementTabIndex = this.opts.element.attr("tabindex");

                // swap container for the element
                this.opts.element
                    .data("select2", this)
                    .attr("tabindex", "-1")
                    .before(this.container)
                    .on("click.select2", killEvent); // do not leak click events

                this.container.data("select2", this);

                this.dropdown = this.container.find(".select2-drop");

                syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

                this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
                this.dropdown.data("select2", this);
                this.dropdown.on("click", killEvent);

                this.results = results = this.container.find(resultsSelector);
                this.search = search = this.container.find("input.select2-input");

                this.queryCount = 0;
                this.resultsPage = 0;
                this.context = null;

                // initialize the container
                this.initContainer();

                this.container.on("click", killEvent);

                installFilteredMouseMove(this.results);

                this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
                this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                    this._touchEvent = true;
                    this.highlightUnderEvent(event);
                }));
                this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
                this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

                // Waiting for a click event on touch devices to select option and hide dropdown
                // otherwise click will be triggered on an underlying element
                this.dropdown.on('click', this.bind(function (event) {
                    if (this._touchEvent) {
                        this._touchEvent = false;
                        this.selectHighlighted();
                    }
                }));

                installDebouncedScroll(80, this.results);
                this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

                // do not propagate change event from the search field out of the component
                $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
                $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

                // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
                if ($.fn.mousewheel) {
                    results.mousewheel(function (e, delta, deltaX, deltaY) {
                        var top = results.scrollTop();
                        if (deltaY > 0 && top - deltaY <= 0) {
                            results.scrollTop(0);
                            killEvent(e);
                        } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                            results.scrollTop(results.get(0).scrollHeight - results.height());
                            killEvent(e);
                        }
                    });
                }

                installKeyUpChangeEvent(search);
                search.on("keyup-change input paste", this.bind(this.updateResults));
                search.on("focus", function () { search.addClass("select2-focused"); });
                search.on("blur", function () { search.removeClass("select2-focused");});

                this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                    if ($(e.target).closest(".select2-result-selectable").length > 0) {
                        this.highlightUnderEvent(e);
                        this.selectHighlighted(e);
                    }
                }));

                // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
                // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
                // dom it will trigger the popup close, which is not what we want
                // focusin can cause focus wars between modals and select2 since the dropdown is outside the modal.
                this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

                this.nextSearchTerm = undefined;

                if ($.isFunction(this.opts.initSelection)) {
                    // initialize selection based on the current value of the source element
                    this.initSelection();

                    // if the user has provided a function that can set selection based on the value of the source element
                    // we monitor the change event on the element and trigger it, allowing for two way synchronization
                    this.monitorSource();
                }

                if (opts.maximumInputLength !== null) {
                    this.search.attr("maxlength", opts.maximumInputLength);
                }

                var disabled = opts.element.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = opts.element.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                // Calculate size of scrollbar
                scrollBarDimensions = scrollBarDimensions || measureScrollbar();

                this.autofocus = opts.element.prop("autofocus");
                opts.element.prop("autofocus", false);
                if (this.autofocus) this.focus();

                this.search.attr("placeholder", opts.searchInputPlaceholder);
            },

            // abstract
            destroy: function () {
                var element=this.opts.element, select2 = element.data("select2"), self = this;

                this.close();

                if (element.length && element[0].detachEvent && self._sync) {
                    element.each(function () {
                        if (self._sync) {
                            this.detachEvent("onpropertychange", self._sync);
                        }
                    });
                }
                if (this.propertyObserver) {
                    this.propertyObserver.disconnect();
                    this.propertyObserver = null;
                }
                this._sync = null;

                if (select2 !== undefined) {
                    select2.container.remove();
                    select2.liveRegion.remove();
                    select2.dropdown.remove();
                    element
                        .show()
                        .removeData("select2")
                        .off(".select2")
                        .prop("autofocus", this.autofocus || false);
                    if (this.elementTabIndex) {
                        element.attr({tabindex: this.elementTabIndex});
                    } else {
                        element.removeAttr("tabindex");
                    }
                    element.show();
                }

                cleanupJQueryElements.call(this,
                    "container",
                    "liveRegion",
                    "dropdown",
                    "results",
                    "search"
                );
            },

            // abstract
            optionToData: function(element) {
                if (element.is("option")) {
                    return {
                        id:element.prop("value"),
                        text:element.text(),
                        element: element.get(),
                        css: element.attr("class"),
                        disabled: element.prop("disabled"),
                        locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                    };
                } else if (element.is("optgroup")) {
                    return {
                        text:element.attr("label"),
                        children:[],
                        element: element.get(),
                        css: element.attr("class")
                    };
                }
            },

            // abstract
            prepareOpts: function (opts) {
                var element, select, idKey, ajaxUrl, self = this;

                element = opts.element;

                if (element.get(0).tagName.toLowerCase() === "select") {
                    this.select = select = opts.element;
                }

                if (select) {
                    // these options are not allowed when attached to a select because they are picked up off the element itself
                    $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                        if (this in opts) {
                            throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                        }
                    });
                }

                opts = $.extend({}, {
                    populateResults: function(container, results, query) {
                        var populate, id=this.opts.id, liveRegion=this.liveRegion;

                        populate=function(results, container, depth) {

                            var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                            results = opts.sortResults(results, container, query);

                            // collect the created nodes for bulk append
                            var nodes = [];
                            for (i = 0, l = results.length; i < l; i = i + 1) {

                                result=results[i];

                                disabled = (result.disabled === true);
                                selectable = (!disabled) && (id(result) !== undefined);

                                compound=result.children && result.children.length > 0;

                                node=$("<li></li>");
                                node.addClass("select2-results-dept-"+depth);
                                node.addClass("select2-result");
                                node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                                if (disabled) { node.addClass("select2-disabled"); }
                                if (compound) { node.addClass("select2-result-with-children"); }
                                node.addClass(self.opts.formatResultCssClass(result));
                                node.attr("role", "presentation");

                                label=$(document.createElement("div"));
                                label.addClass("select2-result-label");
                                label.attr("id", "select2-result-label-" + nextUid());
                                label.attr("role", "option");

                                formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                                if (formatted!==undefined) {
                                    label.html(formatted);
                                    node.append(label);
                                }


                                if (compound) {

                                    innerContainer=$("<ul></ul>");
                                    innerContainer.addClass("select2-result-sub");
                                    populate(result.children, innerContainer, depth+1);
                                    node.append(innerContainer);
                                }

                                node.data("select2-data", result);
                                nodes.push(node[0]);
                            }

                            // bulk append the created nodes
                            container.append(nodes);
                            liveRegion.text(opts.formatMatches(results.length));
                        };

                        populate(results, container, 0);
                    }
                }, $.fn.select2.defaults, opts);

                if (typeof(opts.id) !== "function") {
                    idKey = opts.id;
                    opts.id = function (e) { return e[idKey]; };
                }

                if ($.isArray(opts.element.data("select2Tags"))) {
                    if ("tags" in opts) {
                        throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                    }
                    opts.tags=opts.element.data("select2Tags");
                }

                if (select) {
                    opts.query = this.bind(function (query) {
                        var data = { results: [], more: false },
                            term = query.term,
                            children, placeholderOption, process;

                        process=function(element, collection) {
                            var group;
                            if (element.is("option")) {
                                if (query.matcher(term, element.text(), element)) {
                                    collection.push(self.optionToData(element));
                                }
                            } else if (element.is("optgroup")) {
                                group=self.optionToData(element);
                                element.children().each2(function(i, elm) { process(elm, group.children); });
                                if (group.children.length>0) {
                                    collection.push(group);
                                }
                            }
                        };

                        children=element.children();

                        // ignore the placeholder option if there is one
                        if (this.getPlaceholder() !== undefined && children.length > 0) {
                            placeholderOption = this.getPlaceholderOption();
                            if (placeholderOption) {
                                children=children.not(placeholderOption);
                            }
                        }

                        children.each2(function(i, elm) { process(elm, data.results); });

                        query.callback(data);
                    });
                    // this is needed because inside val() we construct choices from options and their id is hardcoded
                    opts.id=function(e) { return e.id; };
                } else {
                    if (!("query" in opts)) {

                        if ("ajax" in opts) {
                            ajaxUrl = opts.element.data("ajax-url");
                            if (ajaxUrl && ajaxUrl.length > 0) {
                                opts.ajax.url = ajaxUrl;
                            }
                            opts.query = ajax.call(opts.element, opts.ajax);
                        } else if ("data" in opts) {
                            opts.query = local(opts.data);
                        } else if ("tags" in opts) {
                            opts.query = tags(opts.tags);
                            if (opts.createSearchChoice === undefined) {
                                opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                            }
                            if (opts.initSelection === undefined) {
                                opts.initSelection = function (element, callback) {
                                    var data = [];
                                    $(splitVal(element.val(), opts.separator, opts.transformVal)).each(function () {
                                        var obj = { id: this, text: this },
                                            tags = opts.tags;
                                        if ($.isFunction(tags)) tags=tags();
                                        $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                        data.push(obj);
                                    });

                                    callback(data);
                                };
                            }
                        }
                    }
                }
                if (typeof(opts.query) !== "function") {
                    throw "query function not defined for Select2 " + opts.element.attr("id");
                }

                if (opts.createSearchChoicePosition === 'top') {
                    opts.createSearchChoicePosition = function(list, item) { list.unshift(item); };
                }
                else if (opts.createSearchChoicePosition === 'bottom') {
                    opts.createSearchChoicePosition = function(list, item) { list.push(item); };
                }
                else if (typeof(opts.createSearchChoicePosition) !== "function")  {
                    throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
                }

                return opts;
            },

            /**
             * Monitor the original element for changes and update select2 accordingly
             */
            // abstract
            monitorSource: function () {
                var el = this.opts.element, observer, self = this;

                el.on("change.select2", this.bind(function (e) {
                    if (this.opts.element.data("select2-change-triggered") !== true) {
                        this.initSelection();
                    }
                }));

                this._sync = this.bind(function () {

                    // sync enabled state
                    var disabled = el.prop("disabled");
                    if (disabled === undefined) disabled = false;
                    this.enable(!disabled);

                    var readonly = el.prop("readonly");
                    if (readonly === undefined) readonly = false;
                    this.readonly(readonly);

                    if (this.container) {
                        syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                        this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                    }

                    if (this.dropdown) {
                        syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                        this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
                    }

                });

                // IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)
                if (el.length && el[0].attachEvent) {
                    el.each(function() {
                        this.attachEvent("onpropertychange", self._sync);
                    });
                }

                // safari, chrome, firefox, IE11
                observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
                if (observer !== undefined) {
                    if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                    this.propertyObserver = new observer(function (mutations) {
                        $.each(mutations, self._sync);
                    });
                    this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
                }
            },

            // abstract
            triggerSelect: function(data) {
                var evt = $.Event("select2-selecting", { val: this.id(data), object: data, choice: data });
                this.opts.element.trigger(evt);
                return !evt.isDefaultPrevented();
            },

            /**
             * Triggers the change event on the source element
             */
            // abstract
            triggerChange: function (details) {

                details = details || {};
                details= $.extend({}, details, { type: "change", val: this.val() });
                // prevents recursive triggering
                this.opts.element.data("select2-change-triggered", true);
                this.opts.element.trigger(details);
                this.opts.element.data("select2-change-triggered", false);

                // some validation frameworks ignore the change event and listen instead to keyup, click for selects
                // so here we trigger the click event manually
                this.opts.element.click();

                // ValidationEngine ignores the change event and listens instead to blur
                // so here we trigger the blur event manually if so desired
                if (this.opts.blurOnChange)
                    this.opts.element.blur();
            },

            //abstract
            isInterfaceEnabled: function()
            {
                return this.enabledInterface === true;
            },

            // abstract
            enableInterface: function() {
                var enabled = this._enabled && !this._readonly,
                    disabled = !enabled;

                if (enabled === this.enabledInterface) return false;

                this.container.toggleClass("select2-container-disabled", disabled);
                this.close();
                this.enabledInterface = enabled;

                return true;
            },

            // abstract
            enable: function(enabled) {
                if (enabled === undefined) enabled = true;
                if (this._enabled === enabled) return;
                this._enabled = enabled;

                this.opts.element.prop("disabled", !enabled);
                this.enableInterface();
            },

            // abstract
            disable: function() {
                this.enable(false);
            },

            // abstract
            readonly: function(enabled) {
                if (enabled === undefined) enabled = false;
                if (this._readonly === enabled) return;
                this._readonly = enabled;

                this.opts.element.prop("readonly", enabled);
                this.enableInterface();
            },

            // abstract
            opened: function () {
                return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
            },

            // abstract
            positionDropdown: function() {
                var $dropdown = this.dropdown,
                    container = this.container,
                    offset = container.offset(),
                    height = container.outerHeight(false),
                    width = container.outerWidth(false),
                    dropHeight = $dropdown.outerHeight(false),
                    $window = $(window),
                    windowWidth = $window.width(),
                    windowHeight = $window.height(),
                    viewPortRight = $window.scrollLeft() + windowWidth,
                    viewportBottom = $window.scrollTop() + windowHeight,
                    dropTop = offset.top + height,
                    dropLeft = offset.left,
                    enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                    enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                    dropWidth = $dropdown.outerWidth(false),
                    enoughRoomOnRight = function() {
                        return dropLeft + dropWidth <= viewPortRight;
                    },
                    enoughRoomOnLeft = function() {
                        return offset.left + viewPortRight + container.outerWidth(false)  > dropWidth;
                    },
                    aboveNow = $dropdown.hasClass("select2-drop-above"),
                    bodyOffset,
                    above,
                    changeDirection,
                    css,
                    resultsListNode;

                // always prefer the current above/below alignment, unless there is not enough room
                if (aboveNow) {
                    above = true;
                    if (!enoughRoomAbove && enoughRoomBelow) {
                        changeDirection = true;
                        above = false;
                    }
                } else {
                    above = false;
                    if (!enoughRoomBelow && enoughRoomAbove) {
                        changeDirection = true;
                        above = true;
                    }
                }

                //if we are changing direction we need to get positions when dropdown is hidden;
                if (changeDirection) {
                    $dropdown.hide();
                    offset = this.container.offset();
                    height = this.container.outerHeight(false);
                    width = this.container.outerWidth(false);
                    dropHeight = $dropdown.outerHeight(false);
                    viewPortRight = $window.scrollLeft() + windowWidth;
                    viewportBottom = $window.scrollTop() + windowHeight;
                    dropTop = offset.top + height;
                    dropLeft = offset.left;
                    dropWidth = $dropdown.outerWidth(false);
                    $dropdown.show();

                    // fix so the cursor does not move to the left within the search-textbox in IE
                    this.focusSearch();
                }

                if (this.opts.dropdownAutoWidth) {
                    resultsListNode = $('.select2-results', $dropdown)[0];
                    $dropdown.addClass('select2-drop-auto-width');
                    $dropdown.css('width', '');
                    // Add scrollbar width to dropdown if vertical scrollbar is present
                    dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                    dropWidth > width ? width = dropWidth : dropWidth = width;
                    dropHeight = $dropdown.outerHeight(false);
                }
                else {
                    this.container.removeClass('select2-drop-auto-width');
                }

                //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
                //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body.scrollTop(), "enough?", enoughRoomAbove);

                // fix positioning when body has an offset and is not position: static
                if (this.body.css('position') !== 'static') {
                    bodyOffset = this.body.offset();
                    dropTop -= bodyOffset.top;
                    dropLeft -= bodyOffset.left;
                }

                if (!enoughRoomOnRight() && enoughRoomOnLeft()) {
                    dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
                }

                css =  {
                    left: dropLeft,
                    width: width
                };

                if (above) {
                    css.top = offset.top - dropHeight;
                    css.bottom = 'auto';
                    this.container.addClass("select2-drop-above");
                    $dropdown.addClass("select2-drop-above");
                }
                else {
                    css.top = dropTop;
                    css.bottom = 'auto';
                    this.container.removeClass("select2-drop-above");
                    $dropdown.removeClass("select2-drop-above");
                }
                css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));

                $dropdown.css(css);
            },

            // abstract
            shouldOpen: function() {
                var event;

                if (this.opened()) return false;

                if (this._enabled === false || this._readonly === true) return false;

                event = $.Event("select2-opening");
                this.opts.element.trigger(event);
                return !event.isDefaultPrevented();
            },

            // abstract
            clearDropdownAlignmentPreference: function() {
                // clear the classes used to figure out the preference of where the dropdown should be opened
                this.container.removeClass("select2-drop-above");
                this.dropdown.removeClass("select2-drop-above");
            },

            /**
             * Opens the dropdown
             *
             * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
             * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
             */
            // abstract
            open: function () {

                if (!this.shouldOpen()) return false;

                this.opening();

                // Only bind the document mousemove when the dropdown is visible
                $document.on("mousemove.select2Event", function (e) {
                    lastMousePosition.x = e.pageX;
                    lastMousePosition.y = e.pageY;
                });

                return true;
            },

            /**
             * Performs the opening of the dropdown
             */
            // abstract
            opening: function() {
                var cid = this.containerEventName,
                    scroll = "scroll." + cid,
                    resize = "resize."+cid,
                    orient = "orientationchange."+cid,
                    mask;

                this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

                this.clearDropdownAlignmentPreference();

                if(this.dropdown[0] !== this.body.children().last()[0]) {
                    this.dropdown.detach().appendTo(this.body);
                }

                // create the dropdown mask if doesn't already exist
                mask = $("#select2-drop-mask");
                if (mask.length === 0) {
                    mask = $(document.createElement("div"));
                    mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                    mask.hide();
                    mask.appendTo(this.body);
                    mask.on("mousedown touchstart click", function (e) {
                        // Prevent IE from generating a click event on the body
                        reinsertElement(mask);

                        var dropdown = $("#select2-drop"), self;
                        if (dropdown.length > 0) {
                            self=dropdown.data("select2");
                            if (self.opts.selectOnBlur) {
                                self.selectHighlighted({noFocus: true});
                            }
                            self.close();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    });
                }

                // ensure the mask is always right before the dropdown
                if (this.dropdown.prev()[0] !== mask[0]) {
                    this.dropdown.before(mask);
                }

                // move the global id to the correct dropdown
                $("#select2-drop").removeAttr("id");
                this.dropdown.attr("id", "select2-drop");

                // show the elements
                mask.show();

                this.positionDropdown();
                this.dropdown.show();
                this.positionDropdown();

                this.dropdown.addClass("select2-drop-active");

                // attach listeners to events that can change the position of the container and thus require
                // the position of the dropdown to be updated as well so it does not come unglued from the container
                var that = this;
                this.container.parents().add(window).each(function () {
                    $(this).on(resize+" "+scroll+" "+orient, function (e) {
                        if (that.opened()) that.positionDropdown();
                    });
                });


            },

            // abstract
            close: function () {
                if (!this.opened()) return;

                var cid = this.containerEventName,
                    scroll = "scroll." + cid,
                    resize = "resize."+cid,
                    orient = "orientationchange."+cid;

                // unbind event listeners
                this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

                this.clearDropdownAlignmentPreference();

                $("#select2-drop-mask").hide();
                this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
                this.dropdown.hide();
                this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
                this.results.empty();

                // Now that the dropdown is closed, unbind the global document mousemove event
                $document.off("mousemove.select2Event");

                this.clearSearch();
                this.search.removeClass("select2-active");
                this.opts.element.trigger($.Event("select2-close"));
            },

            /**
             * Opens control, sets input value, and updates results.
             */
            // abstract
            externalSearch: function (term) {
                this.open();
                this.search.val(term);
                this.updateResults(false);
            },

            // abstract
            clearSearch: function () {

            },

            //abstract
            getMaximumSelectionSize: function() {
                return evaluate(this.opts.maximumSelectionSize, this.opts.element);
            },

            // abstract
            ensureHighlightVisible: function () {
                var results = this.results, children, index, child, hb, rb, y, more, topOffset;

                index = this.highlight();

                if (index < 0) return;

                if (index == 0) {

                    // if the first element is highlighted scroll all the way to the top,
                    // that way any unselectable headers above it will also be scrolled
                    // into view

                    results.scrollTop(0);
                    return;
                }

                children = this.findHighlightableChoices().find('.select2-result-label');

                child = $(children[index]);

                topOffset = (child.offset() || {}).top || 0;

                hb = topOffset + child.outerHeight(true);

                // if this is the last child lets also make sure select2-more-results is visible
                if (index === children.length - 1) {
                    more = results.find("li.select2-more-results");
                    if (more.length > 0) {
                        hb = more.offset().top + more.outerHeight(true);
                    }
                }

                rb = results.offset().top + results.outerHeight(false);
                if (hb > rb) {
                    results.scrollTop(results.scrollTop() + (hb - rb));
                }
                y = topOffset - results.offset().top;

                // make sure the top of the element is visible
                if (y < 0 && child.css('display') != 'none' ) {
                    results.scrollTop(results.scrollTop() + y); // y is negative
                }
            },

            // abstract
            findHighlightableChoices: function() {
                return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
            },

            // abstract
            moveHighlight: function (delta) {
                var choices = this.findHighlightableChoices(),
                    index = this.highlight();

                while (index > -1 && index < choices.length) {
                    index += delta;
                    var choice = $(choices[index]);
                    if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                        this.highlight(index);
                        break;
                    }
                }
            },

            // abstract
            highlight: function (index) {
                var choices = this.findHighlightableChoices(),
                    choice,
                    data;

                if (arguments.length === 0) {
                    return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
                }

                if (index >= choices.length) index = choices.length - 1;
                if (index < 0) index = 0;

                this.removeHighlight();

                choice = $(choices[index]);
                choice.addClass("select2-highlighted");

                // ensure assistive technology can determine the active choice
                this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

                this.ensureHighlightVisible();

                this.liveRegion.text(choice.text());

                data = choice.data("select2-data");
                if (data) {
                    this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
                }
            },

            removeHighlight: function() {
                this.results.find(".select2-highlighted").removeClass("select2-highlighted");
            },

            touchMoved: function() {
                this._touchMoved = true;
            },

            clearTouchMoved: function() {
              this._touchMoved = false;
            },

            // abstract
            countSelectableResults: function() {
                return this.findHighlightableChoices().length;
            },

            // abstract
            highlightUnderEvent: function (event) {
                var el = $(event.target).closest(".select2-result-selectable");
                if (el.length > 0 && !el.is(".select2-highlighted")) {
                    var choices = this.findHighlightableChoices();
                    this.highlight(choices.index(el));
                } else if (el.length == 0) {
                    // if we are over an unselectable item remove all highlights
                    this.removeHighlight();
                }
            },

            // abstract
            loadMoreIfNeeded: function () {
                var results = this.results,
                    more = results.find("li.select2-more-results"),
                    below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                    page = this.resultsPage + 1,
                    self=this,
                    term=this.search.val(),
                    context=this.context;

                if (more.length === 0) return;
                below = more.offset().top - results.offset().top - results.height();

                if (below <= this.opts.loadMorePadding) {
                    more.addClass("select2-active");
                    this.opts.query({
                            element: this.opts.element,
                            term: term,
                            page: page,
                            context: context,
                            matcher: this.opts.matcher,
                            callback: this.bind(function (data) {

                        // ignore a response if the select2 has been closed before it was received
                        if (!self.opened()) return;


                        self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                        self.postprocessResults(data, false, false);

                        if (data.more===true) {
                            more.detach().appendTo(results).html(self.opts.escapeMarkup(evaluate(self.opts.formatLoadMore, self.opts.element, page+1)));
                            window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                        } else {
                            more.remove();
                        }
                        self.positionDropdown();
                        self.resultsPage = page;
                        self.context = data.context;
                        this.opts.element.trigger({ type: "select2-loaded", items: data });
                    })});
                }
            },

            /**
             * Default tokenizer function which does nothing
             */
            tokenize: function() {

            },

            /**
             * @param initial whether or not this is the call to this method right after the dropdown has been opened
             */
            // abstract
            updateResults: function (initial) {
                var search = this.search,
                    results = this.results,
                    opts = this.opts,
                    data,
                    self = this,
                    input,
                    term = search.val(),
                    lastTerm = $.data(this.container, "select2-last-term"),
                    // sequence number used to drop out-of-order responses
                    queryNumber;

                // prevent duplicate queries against the same term
                if (initial !== true && lastTerm && equal(term, lastTerm)) return;

                $.data(this.container, "select2-last-term", term);

                // if the search is currently hidden we do not alter the results
                if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                    return;
                }

                function postRender() {
                    search.removeClass("select2-active");
                    self.positionDropdown();
                    if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                        self.liveRegion.text(results.text());
                    }
                    else {
                        self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable:not(".select2-selected")').length));
                    }
                }

                function render(html) {
                    results.html(html);
                    postRender();
                }

                queryNumber = ++this.queryCount;

                var maxSelSize = this.getMaximumSelectionSize();
                if (maxSelSize >=1) {
                    data = this.data();
                    if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                        render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                        return;
                    }
                }

                if (search.val().length < opts.minimumInputLength) {
                    if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                        render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                    } else {
                        render("");
                    }
                    if (initial && this.showSearch) this.showSearch(true);
                    return;
                }

                if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                    if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                        render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                    } else {
                        render("");
                    }
                    return;
                }

                if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                    render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
                }

                search.addClass("select2-active");

                this.removeHighlight();

                // give the tokenizer a chance to pre-process the input
                input = this.tokenize();
                if (input != undefined && input != null) {
                    search.val(input);
                }

                this.resultsPage = 1;

                opts.query({
                    element: opts.element,
                        term: search.val(),
                        page: this.resultsPage,
                        context: null,
                        matcher: opts.matcher,
                        callback: this.bind(function (data) {
                    var def; // default choice

                    // ignore old responses
                    if (queryNumber != this.queryCount) {
                      return;
                    }

                    // ignore a response if the select2 has been closed before it was received
                    if (!this.opened()) {
                        this.search.removeClass("select2-active");
                        return;
                    }

                    // handle ajax error
                    if(data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
                        render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
                        return;
                    }

                    // save context, if any
                    this.context = (data.context===undefined) ? null : data.context;
                    // create a default choice and prepend it to the list
                    if (this.opts.createSearchChoice && search.val() !== "") {
                        def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                        if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                            if ($(data.results).filter(
                                function () {
                                    return equal(self.id(this), self.id(def));
                                }).length === 0) {
                                this.opts.createSearchChoicePosition(data.results, def);
                            }
                        }
                    }

                    if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                        render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                        return;
                    }

                    results.empty();
                    self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                    if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                        results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    }

                    this.postprocessResults(data, initial);

                    postRender();

                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
            },

            // abstract
            cancel: function () {
                this.close();
            },

            // abstract
            blur: function () {
                // if selectOnBlur == true, select the currently highlighted option
                if (this.opts.selectOnBlur)
                    this.selectHighlighted({noFocus: true});

                this.close();
                this.container.removeClass("select2-container-active");
                // synonymous to .is(':focus'), which is available in jquery >= 1.6
                if (this.search[0] === document.activeElement) { this.search.blur(); }
                this.clearSearch();
                this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
            },

            // abstract
            focusSearch: function () {
                focus(this.search);
            },

            // abstract
            selectHighlighted: function (options) {
                if (this._touchMoved) {
                  this.clearTouchMoved();
                  return;
                }
                var index=this.highlight(),
                    highlighted=this.results.find(".select2-highlighted"),
                    data = highlighted.closest('.select2-result').data("select2-data");

                if (data) {
                    this.highlight(index);
                    this.onSelect(data, options);
                } else if (options && options.noFocus) {
                    this.close();
                }
            },

            // abstract
            getPlaceholder: function () {
                var placeholderOption;
                return this.opts.element.attr("placeholder") ||
                    this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                    this.opts.element.data("placeholder") ||
                    this.opts.placeholder ||
                    ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
            },

            // abstract
            getPlaceholderOption: function() {
                if (this.select) {
                    var firstOption = this.select.children('option').first();
                    if (this.opts.placeholderOption !== undefined ) {
                        //Determine the placeholder option based on the specified placeholderOption setting
                        return (this.opts.placeholderOption === "first" && firstOption) ||
                               (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                    } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                        //No explicit placeholder option specified, use the first if it's blank
                        return firstOption;
                    }
                }
            },

            /**
             * Get the desired width for the container element.  This is
             * derived first from option `width` passed to select2, then
             * the inline 'style' on the original element, and finally
             * falls back to the jQuery calculated element width.
             */
            // abstract
            initContainerWidth: function () {
                function resolveContainerWidth() {
                    var style, attrs, matches, i, l, attr;

                    if (this.opts.width === "off") {
                        return null;
                    } else if (this.opts.width === "element"){
                        return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                    } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                        // check if there is inline style on the element that contains width
                        style = this.opts.element.attr('style');
                        if (style !== undefined) {
                            attrs = style.split(';');
                            for (i = 0, l = attrs.length; i < l; i = i + 1) {
                                attr = attrs[i].replace(/\s/g, '');
                                matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                                if (matches !== null && matches.length >= 1)
                                    return matches[1];
                            }
                        }

                        if (this.opts.width === "resolve") {
                            // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                            // when attached to input type=hidden or elements hidden via css
                            style = this.opts.element.css('width');
                            if (style.indexOf("%") > 0) return style;

                            // finally, fallback on the calculated width of the element
                            return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                        }

                        return null;
                    } else if ($.isFunction(this.opts.width)) {
                        return this.opts.width();
                    } else {
                        return this.opts.width;
                   }
                }
                var width = resolveContainerWidth.call(this);
                if (width !== null) {
                    this.container.css("width", width);
                }
            }
        });

        SingleSelect2 = clazz(AbstractSelect2, {

            // single

            createContainer: function () {
                var container = $(document.createElement("div")).attr({
                    "class": "select2-container"
                }).html([
                    "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                    "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                    "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                    "</a>",
                    "<label for='' class='select2-offscreen'></label>",
                    "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                    "<div class='select2-drop select2-display-none'>",
                    "   <div class='select2-search'>",
                    "       <label for='' class='select2-offscreen'></label>",
                    "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                    "       aria-autocomplete='list' />",
                    "   </div>",
                    "   <ul class='select2-results' role='listbox'>",
                    "   </ul>",
                    "</div>"].join(""));
                return container;
            },

            // single
            enableInterface: function() {
                if (this.parent.enableInterface.apply(this, arguments)) {
                    this.focusser.prop("disabled", !this.isInterfaceEnabled());
                }
            },

            // single
            opening: function () {
                var el, range, len;

                if (this.opts.minimumResultsForSearch >= 0) {
                    this.showSearch(true);
                }

                this.parent.opening.apply(this, arguments);

                if (this.showSearchInput !== false) {
                    // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                    // all other browsers handle this just fine

                    this.search.val(this.focusser.val());
                }
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                    // move the cursor to the end after focussing, otherwise it will be at the beginning and
                    // new text will appear *before* focusser.val()
                    el = this.search.get(0);
                    if (el.createTextRange) {
                        range = el.createTextRange();
                        range.collapse(false);
                        range.select();
                    } else if (el.setSelectionRange) {
                        len = this.search.val().length;
                        el.setSelectionRange(len, len);
                    }
                }

                // initializes search's value with nextSearchTerm (if defined by user)
                // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
                if(this.search.val() === "") {
                    if(this.nextSearchTerm != undefined){
                        this.search.val(this.nextSearchTerm);
                        this.search.select();
                    }
                }

                this.focusser.prop("disabled", true).val("");
                this.updateResults(true);
                this.opts.element.trigger($.Event("select2-open"));
            },

            // single
            close: function () {
                if (!this.opened()) return;
                this.parent.close.apply(this, arguments);

                this.focusser.prop("disabled", false);

                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            },

            // single
            focus: function () {
                if (this.opened()) {
                    this.close();
                } else {
                    this.focusser.prop("disabled", false);
                    if (this.opts.shouldFocusInput(this)) {
                        this.focusser.focus();
                    }
                }
            },

            // single
            isFocused: function () {
                return this.container.hasClass("select2-container-active");
            },

            // single
            cancel: function () {
                this.parent.cancel.apply(this, arguments);
                this.focusser.prop("disabled", false);

                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            },

            // single
            destroy: function() {
                $("label[for='" + this.focusser.attr('id') + "']")
                    .attr('for', this.opts.element.attr("id"));
                this.parent.destroy.apply(this, arguments);

                cleanupJQueryElements.call(this,
                    "selection",
                    "focusser"
                );
            },

            // single
            initContainer: function () {

                var selection,
                    container = this.container,
                    dropdown = this.dropdown,
                    idSuffix = nextUid(),
                    elementLabel;

                if (this.opts.minimumResultsForSearch < 0) {
                    this.showSearch(false);
                } else {
                    this.showSearch(true);
                }

                this.selection = selection = container.find(".select2-choice");

                this.focusser = container.find(".select2-focusser");

                // add aria associations
                selection.find(".select2-chosen").attr("id", "select2-chosen-"+idSuffix);
                this.focusser.attr("aria-labelledby", "select2-chosen-"+idSuffix);
                this.results.attr("id", "select2-results-"+idSuffix);
                this.search.attr("aria-owns", "select2-results-"+idSuffix);

                // rewrite labels from original element to focusser
                this.focusser.attr("id", "s2id_autogen"+idSuffix);

                elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
                this.opts.element.focus(this.bind(function () { this.focus(); }));

                this.focusser.prev()
                    .text(elementLabel.text())
                    .attr('for', this.focusser.attr('id'));

                // Ensure the original element retains an accessible name
                var originalTitle = this.opts.element.attr("title");
                this.opts.element.attr("title", (originalTitle || elementLabel.text()));

                this.focusser.attr("tabindex", this.elementTabIndex);

                // write label for search field using the label from the focusser element
                this.search.attr("id", this.focusser.attr('id') + '_search');

                this.search.prev()
                    .text($("label[for='" + this.focusser.attr('id') + "']").text())
                    .attr('for', this.search.attr('id'));

                this.search.on("keydown", this.bind(function (e) {
                    if (!this.isInterfaceEnabled()) return;

                    // filter 229 keyCodes (input method editor is processing key input)
                    if (229 == e.keyCode) return;

                    if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                        // prevent the page from scrolling
                        killEvent(e);
                        return;
                    }

                    switch (e.which) {
                        case KEY.UP:
                        case KEY.DOWN:
                            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                            killEvent(e);
                            return;
                        case KEY.ENTER:
                            this.selectHighlighted();
                            killEvent(e);
                            return;
                        case KEY.TAB:
                            this.selectHighlighted({noFocus: true});
                            return;
                        case KEY.ESC:
                            this.cancel(e);
                            killEvent(e);
                            return;
                    }
                }));

                this.search.on("blur", this.bind(function(e) {
                    // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                    // without this the search field loses focus which is annoying
                    if (document.activeElement === this.body.get(0)) {
                        window.setTimeout(this.bind(function() {
                            if (this.opened()) {
                                this.search.focus();
                            }
                        }), 0);
                    }
                }));

                this.focusser.on("keydown", this.bind(function (e) {
                    if (!this.isInterfaceEnabled()) return;

                    if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                        return;
                    }

                    if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                        killEvent(e);
                        return;
                    }

                    if (e.which == KEY.DOWN || e.which == KEY.UP
                        || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                        if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                        this.open();
                        killEvent(e);
                        return;
                    }

                    if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                        if (this.opts.allowClear) {
                            this.clear();
                        }
                        killEvent(e);

                    }
                }));


                installKeyUpChangeEvent(this.focusser);
                this.focusser.on("keyup-change input", this.bind(function(e) {
                    if (this.opts.minimumResultsForSearch >= 0) {
                        e.stopPropagation();
                        if (this.opened()) return;
                        this.open();
                    }
                }));

                selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                    if (!this.isInterfaceEnabled()) {
                        return;
                    }

                    this.clear();
                    killEventImmediately(e);
                    this.close();

                    if (this.selection) {
                        this.selection.focus();
                    }
                }));

                selection.on("mousedown touchstart", this.bind(function (e) {
                    // Prevent IE from generating a click event on the body
                    reinsertElement(selection);

                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }

                    if (this.opened()) {
                        this.close();
                    } else if (this.isInterfaceEnabled()) {
                        this.open();
                    }

                    killEvent(e);
                }));

                dropdown.on("mousedown touchstart", this.bind(function() {
                    if (this.opts.shouldFocusInput(this)) {
                        this.search.focus();
                    }
                }));

                selection.on("focus", this.bind(function(e) {
                    killEvent(e);
                }));

                this.focusser.on("focus", this.bind(function(){
                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }
                    this.container.addClass("select2-container-active");
                })).on("blur", this.bind(function() {
                    if (!this.opened()) {
                        this.container.removeClass("select2-container-active");
                        this.opts.element.trigger($.Event("select2-blur"));
                    }
                }));
                this.search.on("focus", this.bind(function(){
                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }
                    this.container.addClass("select2-container-active");
                }));

                this.initContainerWidth();
                this.opts.element.hide();
                this.setPlaceholder();

            },

            // single
            clear: function(triggerChange) {
                var data=this.selection.data("select2-data");
                if (data) { // guard against queued quick consecutive clicks
                    var evt = $.Event("select2-clearing");
                    this.opts.element.trigger(evt);
                    if (evt.isDefaultPrevented()) {
                        return;
                    }
                    var placeholderOption = this.getPlaceholderOption();
                    this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                    this.selection.find(".select2-chosen").empty();
                    this.selection.removeData("select2-data");
                    this.setPlaceholder();

                    if (triggerChange !== false){
                        this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                        this.triggerChange({removed:data});
                    }
                }
            },

            /**
             * Sets selection based on source element's value
             */
            // single
            initSelection: function () {
                var selected;
                if (this.isPlaceholderOptionSelected()) {
                    this.updateSelection(null);
                    this.close();
                    this.setPlaceholder();
                } else {
                    var self = this;
                    this.opts.initSelection.call(null, this.opts.element, function(selected){
                        if (selected !== undefined && selected !== null) {
                            self.updateSelection(selected);
                            self.close();
                            self.setPlaceholder();
                            self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
                        }
                    });
                }
            },

            isPlaceholderOptionSelected: function() {
                var placeholderOption;
                if (this.getPlaceholder() === undefined) return false; // no placeholder specified so no option should be considered
                return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                    || (this.opts.element.val() === "")
                    || (this.opts.element.val() === undefined)
                    || (this.opts.element.val() === null);
            },

            // single
            prepareOpts: function () {
                var opts = this.parent.prepareOpts.apply(this, arguments),
                    self=this;

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    // install the selection initializer
                    opts.initSelection = function (element, callback) {
                        var selected = element.find("option").filter(function() { return this.selected && !this.disabled });
                        // a single select box always has a value, no need to null check 'selected'
                        callback(self.optionToData(selected));
                    };
                } else if ("data" in opts) {
                    // install default initSelection when applied to hidden input and data is local
                    opts.initSelection = opts.initSelection || function (element, callback) {
                        var id = element.val();
                        //search in data by id, storing the actual matching item
                        var match = null;
                        opts.query({
                            matcher: function(term, text, el){
                                var is_match = equal(id, opts.id(el));
                                if (is_match) {
                                    match = el;
                                }
                                return is_match;
                            },
                            callback: !$.isFunction(callback) ? $.noop : function() {
                                callback(match);
                            }
                        });
                    };
                }

                return opts;
            },

            // single
            getPlaceholder: function() {
                // if a placeholder is specified on a single select without a valid placeholder option ignore it
                if (this.select) {
                    if (this.getPlaceholderOption() === undefined) {
                        return undefined;
                    }
                }

                return this.parent.getPlaceholder.apply(this, arguments);
            },

            // single
            setPlaceholder: function () {
                var placeholder = this.getPlaceholder();

                if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                    // check for a placeholder option if attached to a select
                    if (this.select && this.getPlaceholderOption() === undefined) return;

                    this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                    this.selection.addClass("select2-default");

                    this.container.removeClass("select2-allowclear");
                }
            },

            // single
            postprocessResults: function (data, initial, noHighlightUpdate) {
                var selected = 0, self = this, showSearchInput = true;

                // find the selected element in the result list

                this.findHighlightableChoices().each2(function (i, elm) {
                    if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                        selected = i;
                        return false;
                    }
                });

                // and highlight it
                if (noHighlightUpdate !== false) {
                    if (initial === true && selected >= 0) {
                        this.highlight(selected);
                    } else {
                        this.highlight(0);
                    }
                }

                // hide the search box if this is the first we got the results and there are enough of them for search

                if (initial === true) {
                    var min = this.opts.minimumResultsForSearch;
                    if (min >= 0) {
                        this.showSearch(countResults(data.results) >= min);
                    }
                }
            },

            // single
            showSearch: function(showSearchInput) {
                if (this.showSearchInput === showSearchInput) return;

                this.showSearchInput = showSearchInput;

                this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
                this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
                //add "select2-with-searchbox" to the container if search box is shown
                $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
            },

            // single
            onSelect: function (data, options) {

                if (!this.triggerSelect(data)) { return; }

                var old = this.opts.element.val(),
                    oldData = this.data();

                this.opts.element.val(this.id(data));
                this.updateSelection(data);

                this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

                this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
                this.close();

                if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }

                if (!equal(old, this.id(data))) {
                    this.triggerChange({ added: data, removed: oldData });
                }
            },

            // single
            updateSelection: function (data) {

                var container=this.selection.find(".select2-chosen"), formatted, cssClass;

                this.selection.data("select2-data", data);

                container.empty();
                if (data !== null) {
                    formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
                }
                if (formatted !== undefined) {
                    container.append(formatted);
                }
                cssClass=this.opts.formatSelectionCssClass(data, container);
                if (cssClass !== undefined) {
                    container.addClass(cssClass);
                }

                this.selection.removeClass("select2-default");

                if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                    this.container.addClass("select2-allowclear");
                }
            },

            // single
            val: function () {
                var val,
                    triggerChange = false,
                    data = null,
                    self = this,
                    oldData = this.data();

                if (arguments.length === 0) {
                    return this.opts.element.val();
                }

                val = arguments[0];

                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }

                if (this.select) {
                    this.select
                        .val(val)
                        .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                            data = self.optionToData(elm);
                            return false;
                        });
                    this.updateSelection(data);
                    this.setPlaceholder();
                    if (triggerChange) {
                        this.triggerChange({added: data, removed:oldData});
                    }
                } else {
                    // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                    if (!val && val !== 0) {
                        this.clear(triggerChange);
                        return;
                    }
                    if (this.opts.initSelection === undefined) {
                        throw new Error("cannot call val() if initSelection() is not defined");
                    }
                    this.opts.element.val(val);
                    this.opts.initSelection(this.opts.element, function(data){
                        self.opts.element.val(!data ? "" : self.id(data));
                        self.updateSelection(data);
                        self.setPlaceholder();
                        if (triggerChange) {
                            self.triggerChange({added: data, removed:oldData});
                        }
                    });
                }
            },

            // single
            clearSearch: function () {
                this.search.val("");
                this.focusser.val("");
            },

            // single
            data: function(value) {
                var data,
                    triggerChange = false;

                if (arguments.length === 0) {
                    data = this.selection.data("select2-data");
                    if (data == undefined) data = null;
                    return data;
                } else {
                    if (arguments.length > 1) {
                        triggerChange = arguments[1];
                    }
                    if (!value) {
                        this.clear(triggerChange);
                    } else {
                        data = this.data();
                        this.opts.element.val(!value ? "" : this.id(value));
                        this.updateSelection(value);
                        if (triggerChange) {
                            this.triggerChange({added: value, removed:data});
                        }
                    }
                }
            }
        });

        MultiSelect2 = clazz(AbstractSelect2, {

            // multi
            createContainer: function () {
                var container = $(document.createElement("div")).attr({
                    "class": "select2-container select2-container-multi"
                }).html([
                    "<ul class='select2-choices'>",
                    "  <li class='select2-search-field'>",
                    "    <label for='' class='select2-offscreen'></label>",
                    "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                    "  </li>",
                    "</ul>",
                    "<div class='select2-drop select2-drop-multi select2-display-none'>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
                return container;
            },

            // multi
            prepareOpts: function () {
                var opts = this.parent.prepareOpts.apply(this, arguments),
                    self=this;

                // TODO validate placeholder is a string if specified
                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    // install the selection initializer
                    opts.initSelection = function (element, callback) {

                        var data = [];

                        element.find("option").filter(function() { return this.selected && !this.disabled }).each2(function (i, elm) {
                            data.push(self.optionToData(elm));
                        });
                        callback(data);
                    };
                } else if ("data" in opts) {
                    // install default initSelection when applied to hidden input and data is local
                    opts.initSelection = opts.initSelection || function (element, callback) {
                        var ids = splitVal(element.val(), opts.separator, opts.transformVal);
                        //search in data by array of ids, storing matching items in a list
                        var matches = [];
                        opts.query({
                            matcher: function(term, text, el){
                                var is_match = $.grep(ids, function(id) {
                                    return equal(id, opts.id(el));
                                }).length;
                                if (is_match) {
                                    matches.push(el);
                                }
                                return is_match;
                            },
                            callback: !$.isFunction(callback) ? $.noop : function() {
                                // reorder matches based on the order they appear in the ids array because right now
                                // they are in the order in which they appear in data array
                                var ordered = [];
                                for (var i = 0; i < ids.length; i++) {
                                    var id = ids[i];
                                    for (var j = 0; j < matches.length; j++) {
                                        var match = matches[j];
                                        if (equal(id, opts.id(match))) {
                                            ordered.push(match);
                                            matches.splice(j, 1);
                                            break;
                                        }
                                    }
                                }
                                callback(ordered);
                            }
                        });
                    };
                }

                return opts;
            },

            // multi
            selectChoice: function (choice) {

                var selected = this.container.find(".select2-search-choice-focus");
                if (selected.length && choice && choice[0] == selected[0]) {

                } else {
                    if (selected.length) {
                        this.opts.element.trigger("choice-deselected", selected);
                    }
                    selected.removeClass("select2-search-choice-focus");
                    if (choice && choice.length) {
                        this.close();
                        choice.addClass("select2-search-choice-focus");
                        this.opts.element.trigger("choice-selected", choice);
                    }
                }
            },

            // multi
            destroy: function() {
                $("label[for='" + this.search.attr('id') + "']")
                    .attr('for', this.opts.element.attr("id"));
                this.parent.destroy.apply(this, arguments);

                cleanupJQueryElements.call(this,
                    "searchContainer",
                    "selection"
                );
            },

            // multi
            initContainer: function () {

                var selector = ".select2-choices", selection;

                this.searchContainer = this.container.find(".select2-search-field");
                this.selection = selection = this.container.find(selector);

                var _this = this;
                this.selection.on("click", ".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)", function (e) {
                    _this.search[0].focus();
                    _this.selectChoice($(this));
                });

                // rewrite labels from original element to focusser
                this.search.attr("id", "s2id_autogen"+nextUid());

                this.search.prev()
                    .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                    .attr('for', this.search.attr('id'));
                this.opts.element.focus(this.bind(function () { this.focus(); }));

                this.search.on("input paste", this.bind(function() {
                    if (this.search.attr('placeholder') && this.search.val().length == 0) return;
                    if (!this.isInterfaceEnabled()) return;
                    if (!this.opened()) {
                        this.open();
                    }
                }));

                this.search.attr("tabindex", this.elementTabIndex);

                this.keydowns = 0;
                this.search.on("keydown", this.bind(function (e) {
                    if (!this.isInterfaceEnabled()) return;

                    ++this.keydowns;
                    var selected = selection.find(".select2-search-choice-focus");
                    var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                    var next = selected.next(".select2-search-choice:not(.select2-locked)");
                    var pos = getCursorInfo(this.search);

                    if (selected.length &&
                        (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                        var selectedChoice = selected;
                        if (e.which == KEY.LEFT && prev.length) {
                            selectedChoice = prev;
                        }
                        else if (e.which == KEY.RIGHT) {
                            selectedChoice = next.length ? next : null;
                        }
                        else if (e.which === KEY.BACKSPACE) {
                            if (this.unselect(selected.first())) {
                                this.search.width(10);
                                selectedChoice = prev.length ? prev : next;
                            }
                        } else if (e.which == KEY.DELETE) {
                            if (this.unselect(selected.first())) {
                                this.search.width(10);
                                selectedChoice = next.length ? next : null;
                            }
                        } else if (e.which == KEY.ENTER) {
                            selectedChoice = null;
                        }

                        this.selectChoice(selectedChoice);
                        killEvent(e);
                        if (!selectedChoice || !selectedChoice.length) {
                            this.open();
                        }
                        return;
                    } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                        || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                        this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                        killEvent(e);
                        return;
                    } else {
                        this.selectChoice(null);
                    }

                    if (this.opened()) {
                        switch (e.which) {
                        case KEY.UP:
                        case KEY.DOWN:
                            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                            killEvent(e);
                            return;
                        case KEY.ENTER:
                            this.selectHighlighted();
                            killEvent(e);
                            return;
                        case KEY.TAB:
                            this.selectHighlighted({noFocus:true});
                            this.close();
                            return;
                        case KEY.ESC:
                            this.cancel(e);
                            killEvent(e);
                            return;
                        }
                    }

                    if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                     || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                        return;
                    }

                    if (e.which === KEY.ENTER) {
                        if (this.opts.openOnEnter === false) {
                            return;
                        } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                            return;
                        }
                    }

                    this.open();

                    if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                        // prevent the page from scrolling
                        killEvent(e);
                    }

                    if (e.which === KEY.ENTER) {
                        // prevent form from being submitted
                        killEvent(e);
                    }

                }));

                this.search.on("keyup", this.bind(function (e) {
                    this.keydowns = 0;
                    this.resizeSearch();
                })
                );

                this.search.on("blur", this.bind(function(e) {
                    this.container.removeClass("select2-container-active");
                    this.search.removeClass("select2-focused");
                    this.selectChoice(null);
                    if (!this.opened()) this.clearSearch();
                    e.stopImmediatePropagation();
                    this.opts.element.trigger($.Event("select2-blur"));
                }));

                this.container.on("click", selector, this.bind(function (e) {
                    if (!this.isInterfaceEnabled()) return;
                    if ($(e.target).closest(".select2-search-choice").length > 0) {
                        // clicked inside a select2 search choice, do not open
                        return;
                    }
                    this.selectChoice(null);
                    this.clearPlaceholder();
                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }
                    this.open();
                    this.focusSearch();
                    e.preventDefault();
                }));

                this.container.on("focus", selector, this.bind(function () {
                    if (!this.isInterfaceEnabled()) return;
                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }
                    this.container.addClass("select2-container-active");
                    this.dropdown.addClass("select2-drop-active");
                    this.clearPlaceholder();
                }));

                this.initContainerWidth();
                this.opts.element.hide();

                // set the placeholder if necessary
                this.clearSearch();
            },

            // multi
            enableInterface: function() {
                if (this.parent.enableInterface.apply(this, arguments)) {
                    this.search.prop("disabled", !this.isInterfaceEnabled());
                }
            },

            // multi
            initSelection: function () {
                var data;
                if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                    this.updateSelection([]);
                    this.close();
                    // set the placeholder if necessary
                    this.clearSearch();
                }
                if (this.select || this.opts.element.val() !== "") {
                    var self = this;
                    this.opts.initSelection.call(null, this.opts.element, function(data){
                        if (data !== undefined && data !== null) {
                            self.updateSelection(data);
                            self.close();
                            // set the placeholder if necessary
                            self.clearSearch();
                        }
                    });
                }
            },

            // multi
            clearSearch: function () {
                var placeholder = this.getPlaceholder(),
                    maxWidth = this.getMaxSearchWidth();

                if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                    this.search.val(placeholder).addClass("select2-default");
                    // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                    // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                    this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
                } else {
                    this.search.val("").width(10);
                }
            },

            // multi
            clearPlaceholder: function () {
                if (this.search.hasClass("select2-default")) {
                    this.search.val("").removeClass("select2-default");
                }
            },

            // multi
            opening: function () {
                this.clearPlaceholder(); // should be done before super so placeholder is not used to search
                this.resizeSearch();

                this.parent.opening.apply(this, arguments);

                this.focusSearch();

                // initializes search's value with nextSearchTerm (if defined by user)
                // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
                if(this.search.val() === "") {
                    if(this.nextSearchTerm != undefined){
                        this.search.val(this.nextSearchTerm);
                        this.search.select();
                    }
                }

                this.updateResults(true);
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
                this.opts.element.trigger($.Event("select2-open"));
            },

            // multi
            close: function () {
                if (!this.opened()) return;
                this.parent.close.apply(this, arguments);
            },

            // multi
            focus: function () {
                this.close();
                this.search.focus();
            },

            // multi
            isFocused: function () {
                return this.search.hasClass("select2-focused");
            },

            // multi
            updateSelection: function (data) {
                var ids = [], filtered = [], self = this;

                // filter out duplicates
                $(data).each(function () {
                    if (indexOf(self.id(this), ids) < 0) {
                        ids.push(self.id(this));
                        filtered.push(this);
                    }
                });
                data = filtered;

                this.selection.find(".select2-search-choice").remove();
                $(data).each(function () {
                    self.addSelectedChoice(this);
                });
                self.postprocessResults();
            },

            // multi
            tokenize: function() {
                var input = this.search.val();
                input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
                if (input != null && input != undefined) {
                    this.search.val(input);
                    if (input.length > 0) {
                        this.open();
                    }
                }

            },

            // multi
            onSelect: function (data, options) {

                if (!this.triggerSelect(data) || data.text === "") { return; }

                this.addSelectedChoice(data);

                this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

                // keep track of the search's value before it gets cleared
                this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());

                this.clearSearch();
                this.updateResults();

                if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

                if (this.opts.closeOnSelect) {
                    this.close();
                    this.search.width(10);
                } else {
                    if (this.countSelectableResults()>0) {
                        this.search.width(10);
                        this.resizeSearch();
                        if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                            // if we reached max selection size repaint the results so choices
                            // are replaced with the max selection reached message
                            this.updateResults(true);
                        } else {
                            // initializes search's value with nextSearchTerm and update search result
                            if(this.nextSearchTerm != undefined){
                                this.search.val(this.nextSearchTerm);
                                this.updateResults();
                                this.search.select();
                            }
                        }
                        this.positionDropdown();
                    } else {
                        // if nothing left to select close
                        this.close();
                        this.search.width(10);
                    }
                }

                // since its not possible to select an element that has already been
                // added we do not need to check if this is a new element before firing change
                this.triggerChange({ added: data });

                if (!options || !options.noFocus)
                    this.focusSearch();
            },

            // multi
            cancel: function () {
                this.close();
                this.focusSearch();
            },

            addSelectedChoice: function (data) {
                var enableChoice = !data.locked,
                    enabledItem = $(
                        "<li class='select2-search-choice'>" +
                        "    <div></div>" +
                        "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                        "</li>"),
                    disabledItem = $(
                        "<li class='select2-search-choice select2-locked'>" +
                        "<div></div>" +
                        "</li>");
                var choice = enableChoice ? enabledItem : disabledItem,
                    id = this.id(data),
                    val = this.getVal(),
                    formatted,
                    cssClass;

                formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
                if (formatted != undefined) {
                    choice.find("div").replaceWith($("<div></div>").html(formatted));
                }
                cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
                if (cssClass != undefined) {
                    choice.addClass(cssClass);
                }

                if(enableChoice){
                  choice.find(".select2-search-choice-close")
                      .on("mousedown", killEvent)
                      .on("click dblclick", this.bind(function (e) {
                      if (!this.isInterfaceEnabled()) return;

                      this.unselect($(e.target));
                      this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                      killEvent(e);
                      this.close();
                      this.focusSearch();
                  })).on("focus", this.bind(function () {
                      if (!this.isInterfaceEnabled()) return;
                      this.container.addClass("select2-container-active");
                      this.dropdown.addClass("select2-drop-active");
                  }));
                }

                choice.data("select2-data", data);
                choice.insertBefore(this.searchContainer);

                val.push(id);
                this.setVal(val);
            },

            // multi
            unselect: function (selected) {
                var val = this.getVal(),
                    data,
                    index;
                selected = selected.closest(".select2-search-choice");

                if (selected.length === 0) {
                    throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
                }

                data = selected.data("select2-data");

                if (!data) {
                    // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                    // and invoked on an element already removed
                    return;
                }

                var evt = $.Event("select2-removing");
                evt.val = this.id(data);
                evt.choice = data;
                this.opts.element.trigger(evt);

                if (evt.isDefaultPrevented()) {
                    return false;
                }

                while((index = indexOf(this.id(data), val)) >= 0) {
                    val.splice(index, 1);
                    this.setVal(val);
                    if (this.select) this.postprocessResults();
                }

                selected.remove();

                this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                this.triggerChange({ removed: data });

                return true;
            },

            // multi
            postprocessResults: function (data, initial, noHighlightUpdate) {
                var val = this.getVal(),
                    choices = this.results.find(".select2-result"),
                    compound = this.results.find(".select2-result-with-children"),
                    self = this;

                choices.each2(function (i, choice) {
                    var id = self.id(choice.data("select2-data"));
                    if (indexOf(id, val) >= 0) {
                        choice.addClass("select2-selected");
                        // mark all children of the selected parent as selected
                        choice.find(".select2-result-selectable").addClass("select2-selected");
                    }
                });

                compound.each2(function(i, choice) {
                    // hide an optgroup if it doesn't have any selectable children
                    if (!choice.is('.select2-result-selectable')
                        && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                        choice.addClass("select2-selected");
                    }
                });

                if (this.highlight() == -1 && noHighlightUpdate !== false && this.opts.closeOnSelect === true){
                    self.highlight(0);
                }

                //If all results are chosen render formatNoMatches
                if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                    if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                        if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                            this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                        }
                    }
                }

            },

            // multi
            getMaxSearchWidth: function() {
                return this.selection.width() - getSideBorderPadding(this.search);
            },

            // multi
            resizeSearch: function () {
                var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                    sideBorderPadding = getSideBorderPadding(this.search);

                minimumWidth = measureTextWidth(this.search) + 10;

                left = this.search.offset().left;

                maxWidth = this.selection.width();
                containerLeft = this.selection.offset().left;

                searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

                if (searchWidth < minimumWidth) {
                    searchWidth = maxWidth - sideBorderPadding;
                }

                if (searchWidth < 40) {
                    searchWidth = maxWidth - sideBorderPadding;
                }

                if (searchWidth <= 0) {
                  searchWidth = minimumWidth;
                }

                this.search.width(Math.floor(searchWidth));
            },

            // multi
            getVal: function () {
                var val;
                if (this.select) {
                    val = this.select.val();
                    return val === null ? [] : val;
                } else {
                    val = this.opts.element.val();
                    return splitVal(val, this.opts.separator, this.opts.transformVal);
                }
            },

            // multi
            setVal: function (val) {
                var unique;
                if (this.select) {
                    this.select.val(val);
                } else {
                    unique = [];
                    // filter out duplicates
                    $(val).each(function () {
                        if (indexOf(this, unique) < 0) unique.push(this);
                    });
                    this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
                }
            },

            // multi
            buildChangeDetails: function (old, current) {
                var current = current.slice(0),
                    old = old.slice(0);

                // remove intersection from each array
                for (var i = 0; i < current.length; i++) {
                    for (var j = 0; j < old.length; j++) {
                        if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                            current.splice(i, 1);
                            if(i>0){
                                i--;
                            }
                            old.splice(j, 1);
                            j--;
                        }
                    }
                }

                return {added: current, removed: old};
            },


            // multi
            val: function (val, triggerChange) {
                var oldData, self=this;

                if (arguments.length === 0) {
                    return this.getVal();
                }

                oldData=this.data();
                if (!oldData.length) oldData=[];

                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.opts.element.val("");
                    this.updateSelection([]);
                    this.clearSearch();
                    if (triggerChange) {
                        this.triggerChange({added: this.data(), removed: oldData});
                    }
                    return;
                }

                // val is a list of ids
                this.setVal(val);

                if (this.select) {
                    this.opts.initSelection(this.select, this.bind(this.updateSelection));
                    if (triggerChange) {
                        this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                    }
                } else {
                    if (this.opts.initSelection === undefined) {
                        throw new Error("val() cannot be called if initSelection() is not defined");
                    }

                    this.opts.initSelection(this.opts.element, function(data){
                        var ids=$.map(data, self.id);
                        self.setVal(ids);
                        self.updateSelection(data);
                        self.clearSearch();
                        if (triggerChange) {
                            self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                        }
                    });
                }
                this.clearSearch();
            },

            // multi
            onSortStart: function() {
                if (this.select) {
                    throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
                }

                // collapse search field into 0 width so its container can be collapsed as well
                this.search.width(0);
                // hide the container
                this.searchContainer.hide();
            },

            // multi
            onSortEnd:function() {

                var val=[], self=this;

                // show search and move it to the end of the list
                this.searchContainer.show();
                // make sure the search container is the last item in the list
                this.searchContainer.appendTo(this.searchContainer.parent());
                // since we collapsed the width in dragStarted, we resize it here
                this.resizeSearch();

                // update selection
                this.selection.find(".select2-search-choice").each(function() {
                    val.push(self.opts.id($(this).data("select2-data")));
                });
                this.setVal(val);
                this.triggerChange();
            },

            // multi
            data: function(values, triggerChange) {
                var self=this, ids, old;
                if (arguments.length === 0) {
                     return this.selection
                         .children(".select2-search-choice")
                         .map(function() { return $(this).data("select2-data"); })
                         .get();
                } else {
                    old = this.data();
                    if (!values) { values = []; }
                    ids = $.map(values, function(e) { return self.opts.id(e); });
                    this.setVal(ids);
                    this.updateSelection(values);
                    this.clearSearch();
                    if (triggerChange) {
                        this.triggerChange(this.buildChangeDetails(old, this.data()));
                    }
                }
            }
        });

        $.fn.select2 = function () {

            var args = Array.prototype.slice.call(arguments, 0),
                opts,
                select2,
                method, value, multiple,
                allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
                valueMethods = ["opened", "isFocused", "container", "dropdown"],
                propertyMethods = ["val", "data"],
                methodsMap = { search: "externalSearch" };

            this.each(function () {
                if (args.length === 0 || typeof(args[0]) === "object") {
                    opts = args.length === 0 ? {} : $.extend({}, args[0]);
                    opts.element = $(this);

                    if (opts.element.get(0).tagName.toLowerCase() === "select") {
                        multiple = opts.element.prop("multiple");
                    } else {
                        multiple = opts.multiple || false;
                        if ("tags" in opts) {opts.multiple = multiple = true;}
                    }

                    select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                    select2.init(opts);
                } else if (typeof(args[0]) === "string") {

                    if (indexOf(args[0], allowedMethods) < 0) {
                        throw "Unknown method: " + args[0];
                    }

                    value = undefined;
                    select2 = $(this).data("select2");
                    if (select2 === undefined) return;

                    method=args[0];

                    if (method === "container") {
                        value = select2.container;
                    } else if (method === "dropdown") {
                        value = select2.dropdown;
                    } else {
                        if (methodsMap[method]) method = methodsMap[method];

                        value = select2[method].apply(select2, args.slice(1));
                    }
                    if (indexOf(args[0], valueMethods) >= 0
                        || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                        return false; // abort the iteration, ready to return first matched value
                    }
                } else {
                    throw "Invalid arguments to select2 plugin: " + args;
                }
            });
            return (value === undefined) ? this : value;
        };

        // plugin defaults, accessible to users
        $.fn.select2.defaults = {
            width: "copy",
            loadMorePadding: 0,
            closeOnSelect: true,
            openOnEnter: true,
            containerCss: {},
            dropdownCss: {},
            containerCssClass: "",
            dropdownCssClass: "",
            formatResult: function(result, container, query, escapeMarkup) {
                var markup=[];
                markMatch(this.text(result), query.term, markup, escapeMarkup);
                return markup.join("");
            },
            transformVal: function(val) {
                return $.trim(val);
            },
            formatSelection: function (data, container, escapeMarkup) {
                return data ? escapeMarkup(this.text(data)) : undefined;
            },
            sortResults: function (results, container, query) {
                return results;
            },
            formatResultCssClass: function(data) {return data.css;},
            formatSelectionCssClass: function(data, container) {return undefined;},
            minimumResultsForSearch: 0,
            minimumInputLength: 0,
            maximumInputLength: null,
            maximumSelectionSize: 0,
            id: function (e) { return e == undefined ? null : e.id; },
            text: function (e) {
              if (e && this.data && this.data.text) {
                if ($.isFunction(this.data.text)) {
                  return this.data.text(e);
                } else {
                  return e[this.data.text];
                }
              } else {
                return e.text;
              }
            },
            matcher: function(term, text) {
                return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
            },
            separator: ",",
            tokenSeparators: [],
            tokenizer: defaultTokenizer,
            escapeMarkup: defaultEscapeMarkup,
            blurOnChange: false,
            selectOnBlur: false,
            adaptContainerCssClass: function(c) { return c; },
            adaptDropdownCssClass: function(c) { return null; },
            nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; },
            searchInputPlaceholder: '',
            createSearchChoicePosition: 'top',
            shouldFocusInput: function (instance) {
                // Attempt to detect touch devices
                var supportsTouchEvents = (('ontouchstart' in window) ||
                                           (navigator.msMaxTouchPoints > 0));

                // Only devices which support touch events should be special cased
                if (!supportsTouchEvents) {
                    return true;
                }

                // Never focus the input if search is disabled
                if (instance.opts.minimumResultsForSearch < 0) {
                    return false;
                }

                return true;
            }
        };

        $.fn.select2.locales = [];

        $.fn.select2.locales['en'] = {
             formatMatches: function (matches) { if (matches === 1) { return "One result is available, press enter to select it."; } return matches + " results are available, use up and down arrow keys to navigate."; },
             formatNoMatches: function () { return "No matches found"; },
             formatAjaxError: function (jqXHR, textStatus, errorThrown) { return "Loading failed"; },
             formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1 ? "" : "s"); },
             formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1 ? "" : "s"); },
             formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
             formatLoadMore: function (pageNumber) { return "Loading more results…"; },
             formatSearching: function () { return "Searching…"; }
        };

        $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);

        $.fn.select2.ajaxDefaults = {
            transport: $.ajax,
            params: {
                type: "GET",
                cache: false,
                dataType: "json"
            }
        };

        // exports
        window.Select2 = {
            query: {
                ajax: ajax,
                local: local,
                tags: tags
            }, util: {
                debounce: debounce,
                markMatch: markMatch,
                escapeMarkup: defaultEscapeMarkup,
                stripDiacritics: stripDiacritics
            }, "class": {
                "abstract": AbstractSelect2,
                "single": SingleSelect2,
                "multi": MultiSelect2
            }
        };

    }(jQuery));
/*-------------------------------  FRESCO  ---------------------------------------*/
    /*
     * Fresco - A Beautiful Responsive Lightbox - v1.1.2
     * (c) 2012 Nick Stakenburg
     *
     * http://www.frescojs.com
     *
     * License: http://www.frescojs.com/license
     */
var Fresco = {
        version: '1.1.2'
    };
    Fresco.skins = {
    'base': {
        effects: {
            content: {
                show: 0,
                hide: 0,
                sync: true
            },
            loading: {
                show: 0,
                hide: 300,
                delay: 250
            },
            thumbnails: {
                show: 200,
                slide: 0,
                load: 300,
                delay: 250
            },
            window: {
                show: 440,
                hide: 300,
                position: 180
            },
            ui: {
                show: 250,
                hide: 200,
                delay: 3000
            }
        },
        touchEffects: {
            ui: {
                show: 175,
                hide: 175,
                delay: 5000
            }
        },
        fit: 'both',
        keyboard: {
            left: true,
            right: true,
            esc: true
        },
        loop: false,
        onClick: 'previous-next',
        overlay: {
            close: true
        },
        position: false,
        preload: true,
        spacing: {
            both: {
                horizontal: 20,
                vertical: 20
            },

            width: {
                horizontal: 0,
                vertical: 0
            },
            height: {
                    horizontal: 0,
                    vertical: 0
                },
                none: {
                    horizontal: 0,
                    vertical: 0
                }
            },
            thumbnails: true,
            ui: 'outside',
            vimeo: {
                autoplay: 1,
                title: 1,
                byline: 1,
                portrait: 0,
                loop: 0
            },
            youtube: {
                autoplay: 1,
                controls: 1,
                enablejsapi: 1,
                hd: 1,
                iv_load_policy: 3,
                loop: 0,
                modestbranding: 1,
                rel: 0
            },
            initialTypeOptions: {
                'image': {},
                'youtube': {
                    width: 640,
                    height: 360
                },
                'vimeo': {
                    width: 640,
                    height: 360
                }
            }
        },
        'reset': {},
        'fresco': {},
        'IE6': {}
    };
    (function ($) {
        (function () {
            function wheel(a) {
                var b;
                if (a.originalEvent.wheelDelta) {
                    b = a.originalEvent.wheelDelta / 120
                } else {
                    if (a.originalEvent.detail) {
                        b = -a.originalEvent.detail / 3
                    }
                }
                if (!b) {
                    return
                }
                var c = $.Event("fresco:mousewheel");
                $(a.target).trigger(c, b);
                if (c.isPropagationStopped()) {
                    a.stopPropagation()
                }
                if (c.isDefaultPrevented()) {
                    a.preventDefault()
                }
            }
            $(document.documentElement).bind("mousewheel DOMMouseScroll", wheel)
        })();
        var q = Array.prototype.slice;
        var _ = {
            isElement: function (a) {
                return a && a.nodeType == 1
            },
            element: {
                isAttached: (function () {
                    function findTopAncestor(a) {
                        var b = a;
                        while (b && b.parentNode) {
                            b = b.parentNode
                        }
                        return b
                    }
                    return function (a) {
                        var b = findTopAncestor(a);
                        return !!(b && b.body)
                    }
                })()
            }
        };
        var r = (function (c) {
            function getVersion(a) {
                var b = new RegExp(a + "([\\d.]+)").exec(c);
                return b ? parseFloat(b[1]) : true
            }
            return {
                IE: !! (window.attachEvent && c.indexOf("Opera") === -1) && getVersion("MSIE "),
                Opera: c.indexOf("Opera") > -1 && (( !! window.opera && opera.version && parseFloat(opera.version())) || 7.55),
                WebKit: c.indexOf("AppleWebKit/") > -1 && getVersion("AppleWebKit/"),
                Gecko: c.indexOf("Gecko") > -1 && c.indexOf("KHTML") === -1 && getVersion("rv:"),
                MobileSafari: !! c.match(/Apple.*Mobile.*Safari/),
                Chrome: c.indexOf("Chrome") > -1 && getVersion("Chrome/"),
                Android: c.indexOf("Android") > -1 && getVersion("Android "),
                IEMobile: c.indexOf("IEMobile") > -1 && getVersion("IEMobile/")
            }
        })(navigator.userAgent);

        function px(a) {
            var b = {};
            for (var c in a) {
                b[c] = a[c] + "px"
            }
            return b
        }
        var t = {};
        (function () {
            var c = {};
            $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (i, a) {
                c[a] = function (p) {
                    return Math.pow(p, i + 2)
                }
            });
            $.extend(c, {
                Sine: function (p) {
                    return 1 - Math.cos(p * Math.PI / 2)
                }
            });
            $.each(c, function (a, b) {
                t["easeIn" + a] = b;
                t["easeOut" + a] = function (p) {
                    return 1 - b(1 - p)
                };
                t["easeInOut" + a] = function (p) {
                    return p < 0.5 ? b(p * 2) / 2 : 1 - b(p * -2 + 2) / 2
                }
            });
            $.each(t, function (a, b) {
                if (!$.easing[a]) {
                    $.easing[a] = b
                }
            })
        })();

        function sfcc(c) {
            return String.fromCharCode.apply(String, c.split(","))
        }
        function warn(a) {
            if ( !! window.console) {
                console[console.warn ? "warn" : "log"](a)
            }
        }
        var u = {
            scripts: {
                jQuery: {
                    required: "1.4.4",
                    available: window.jQuery && jQuery.fn.jquery
                }
            },
            check: (function () {
                var c = /^(\d+(\.?\d+){0,3})([A-Za-z_-]+[A-Za-z0-9]+)?/;

                function convertVersionString(a) {
                    var b = a.match(c),
                        nA = b && b[1] && b[1].split(".") || [],
                        v = 0;
                    for (var i = 0, l = nA.length; i < l; i++) {
                        v += parseInt(nA[i] * Math.pow(10, 6 - i * 2))
                    }
                    return b && b[3] ? v - 1 : v
                }
                return function require(a) {
                    if (!this.scripts[a].available || (convertVersionString(this.scripts[a].available) < convertVersionString(this.scripts[a].required)) && !this.scripts[a].notified) {
                        this.scripts[a].notified = true;
                        warn("Fresco requires " + a + " >= " + this.scripts[a].required)
                    }
                }
            })()
        };
        var w = (function () {
            return {
                canvas: (function () {
                    var a = document.createElement("canvas");
                    return !!(a.getContext && a.getContext("2d"))
                })(),
                touch: (function () {
                    try {
                        return !!(("ontouchstart" in window) || window.DocumentTouch && document instanceof DocumentTouch)
                    } catch (e) {
                        return false
                    }
                })()
            }
        })();
        w.mobileTouch = w.touch && (r.MobileSafari || r.Android || r.IEMobile || !/^(Win|Mac|Linux)/.test(navigator.platform));
        var A;
        (function ($) {
            var e = ".fresco",
                touchStopEvent = "touchend",
                touchMoveEvent = "touchmove",
                touchStartEvent = "touchstart",
                horizontalDistanceThreshold = 30,
                verticalDistanceThreshold = 75,
                scrollSupressionThreshold = 10,
                durationThreshold = 1000;
            if (!w.mobileTouch) {
                A = function () {};
                return
            }
            A = function (a, b, c) {
                if (c) {
                    $(a).data("stopPropagation" + e, true)
                }
                if (b) {
                    swipe(a, b)
                }
            };

            function swipe(a, b) {
                if (!$(a).data("fresco-swipe" + e)) {
                    $(a).data("fresco-swipe", b)
                }
                addSwipe(a)
            }
            function addSwipe(a) {
                $(a).bind(touchStartEvent, touchStart)
            }
            function touchStart(c) {
                if ($(this).hasClass("fr-prevent-swipe")) {
                    return
                }
                var d = new Date().getTime(),
                    data = c.originalEvent.touches ? c.originalEvent.touches[0] : c,
                    $this = $(this).bind(touchMoveEvent, moveHandler).one(touchStopEvent, touchEnded),
                    pageX = data.pageX,
                    pageY = data.pageY,
                    newPageX, newPageY, newTime;
                if ($this.data("stopPropagation" + e)) {
                    c.stopImmediatePropagation()
                }
                function touchEnded(a) {
                    $this.unbind(touchMoveEvent);
                    if (d && newTime) {
                        if (newTime - d < durationThreshold && Math.abs(pageX - newPageX) > horizontalDistanceThreshold && Math.abs(pageY - newPageY) < verticalDistanceThreshold) {
                            var b = $this.data("fresco-swipe");
                            if (pageX > newPageX) {
                                if (b) {
                                    b("left")
                                }
                            } else {
                                if (b) {
                                    b("right")
                                }
                            }
                        }
                    }
                    d = newTime = null
                }
                function moveHandler(a) {
                    if (d) {
                        data = a.originalEvent.touches ? a.originalEvent.touches[0] : a;
                        newTime = new Date().getTime();
                        newPageX = data.pageX;
                        newPageY = data.pageY;
                        if (Math.abs(pageX - newPageX) > scrollSupressionThreshold) {
                            a.preventDefault()
                        }
                    }
                }
            }
        })(jQuery);

        function deepExtend(a, b) {
            for (var c in b) {
                if (b[c] && b[c].constructor && b[c].constructor === Object) {
                    a[c] = $.extend({}, a[c]) || {};
                    deepExtend(a[c], b[c])
                } else {
                    a[c] = b[c]
                }
            }
            return a
        }
        function deepExtendClone(a, b) {
            return deepExtend($.extend({}, a), b)
        }
        var B = (function () {
            var j = Fresco.skins.base,
                RESET = deepExtendClone(j, Fresco.skins.reset);

            function create(d, e, f) {
                d = d || {};
                f = f || {};
                d.skin = d.skin || (Fresco.skins[C.defaultSkin] ? C.defaultSkin : "fresco");
                if (r.IE && r.IE < 7) {
                    d.skin = "IE6"
                }
                var g = d.skin ? $.extend({}, Fresco.skins[d.skin] || Fresco.skins[C.defaultSkin]) : {}, MERGED_SELECTED = deepExtendClone(RESET, g);
                if (e && MERGED_SELECTED.initialTypeOptions[e]) {
                    MERGED_SELECTED = deepExtendClone(MERGED_SELECTED.initialTypeOptions[e], MERGED_SELECTED);
                    delete MERGED_SELECTED.initialTypeOptions
                }
                var h = deepExtendClone(MERGED_SELECTED, d);
                if (1 != 0 + 1) {
                    $.extend(h, {
                        fit: "both",
                        ui: "outside",
                        thumbnails: false
                    })
                }
                if (h.fit) {
                    if ($.type(h.fit) == "boolean") {
                        h.fit = "both"
                    }
                } else {
                    h.fit = "none"
                }
                if (h.controls) {
                    if ($.type(h.controls) == "string") {
                        h.controls = deepExtendClone(MERGED_SELECTED.controls || RESET.controls || j.controls, {
                            type: h.controls
                        })
                    } else {
                        h.controls = deepExtendClone(j.controls, h.controls)
                    }
                }
                if (!h.effects || (w.mobileTouch && !h.touchEffects)) {
                    h.effects = {};
                    $.each(j.effects, function (b, c) {
                        $.each((h.effects[b] = $.extend({}, c)), function (a) {
                            h.effects[b][a] = 0
                        })
                    })
                } else {
                    if (w.mobileTouch && h.touchEffects) {
                        h.effects = deepExtendClone(h.effects, h.touchEffects)
                    }
                }
                if (r.IE && r.IE < 9) {
                    deepExtend(h.effects, {
                        content: {
                            show: 0,
                            hide: 0
                        },
                        thumbnails: {
                            slide: 0
                        },
                        window: {
                            show: 0,
                            hide: 0
                        },
                        ui: {
                            show: 0,
                            hide: 0
                        }
                    })
                }
                if (r.IE && r.IE < 7) {
                    h.thumbnails = false
                }
                if (h.keyboard && e != "image") {
                    $.extend(h.keyboard, {
                        left: false,
                        right: false
                    })
                }
                if (!h.thumbnail && $.type(h.thumbnail) != "boolean") {
                    var i = false;
                    switch (e) {
                        case "youtube":
                            i = "http://img.youtube.com/vi/" + f.id + "/0.jpg";
                            break;
                        case "image":
                            i = true;
                            break
                    }
                    h.thumbnail = i
                }
                return h
            }
            return {
                create: create
            }
        })();

        function Overlay() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(Overlay.prototype, {
            initialize: function (a) {
                this.options = $.extend({
                    className: "fr-overlay"
                }, arguments[1] || {});
                this.Window = a;
                this.build();
                if (r.IE && r.IE < 9) {
                    $(window).bind("resize", $.proxy(function () {
                        if (this.element && this.element.is(":visible")) {
                            this.max()
                        }
                    }, this))
                }
                this.draw()
            },
            build: function () {
                this.element = $("<div>").addClass(this.options.className).append(this.background = $("<div>").addClass(this.options.className + "-background"));
                $(document.body).prepend(this.element);
                if (r.IE && r.IE < 7) {
                    this.element.css({
                        position: "absolute"
                    });
                    var s = this.element[0].style;
                    s.setExpression("top", "((!!window.jQuery ? jQuery(window).scrollTop() : 0) + 'px')");
                    s.setExpression("left", "((!!window.jQuery ? jQuery(window).scrollLeft() : 0) + 'px')")
                }
                this.element.hide();
                this.element.bind("click", $.proxy(function () {
                    if (this.Window.view && this.Window.view.options && this.Window.view.options.overlay && !this.Window.view.options.overlay.close) {
                        return
                    }
                    this.Window.hide()
                }, this));
                this.element.bind("fresco:mousewheel", function (a) {
                    a.preventDefault()
                })
            },
            setSkin: function (a) {
                this.element[0].className = this.options.className + " " + this.options.className + "-" + a
            },
            setOptions: function (a) {
                this.options = a;
                this.draw()
            },
            draw: function () {
                this.max()
            },
            show: function (a) {
                this.max();
                this.element.stop(1, 0);
                var b = H._frames && H._frames[H._position - 1];
                this.setOpacity(1, b ? b.view.options.effects.window.show : 0, a);
                return this
            },
            hide: function (a) {
                var b = H._frames && H._frames[H._position - 1];
                this.element.stop(1, 0).fadeOut(b ? b.view.options.effects.window.hide || 0 : 0, "easeInOutSine", a);
                return this
            },
            setOpacity: function (a, b, c) {
                this.element.fadeTo(b || 0, a, "easeInOutSine", c)
            },
            getScrollDimensions: function () {
                var a = {};
                $.each(["width", "height"], function (i, d) {
                    var D = d.substr(0, 1).toUpperCase() + d.substr(1),
                        ddE = document.documentElement;
                    a[d] = (r.IE ? Math.max(ddE["offset" + D], ddE["scroll" + D]) : r.WebKit ? document.body["scroll" + D] : ddE["scroll" + D]) || 0
                });
                return a
            },
            max: function () {
                if ((r.MobileSafari && (r.WebKit && r.WebKit < 533.18))) {
                    this.element.css(px(getScrollDimensions()))
                }
                if (r.IE) {
                    this.element.css(px({
                        height: $(window).height(),
                        width: $(window).width()
                    }))
                }
            }
        });

        function Loading() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(Loading.prototype, {
            initialize: function (a) {
                this.Window = a;
                this.options = $.extend({
                    thumbnails: J,
                    className: "fr-loading"
                }, arguments[1] || {});
                if (this.options.thumbnails) {
                    this.thumbnails = this.options.thumbnails
                }
                this.build();
                this.startObserving()
            },
            build: function () {
                $(document.body).append(this.element = $("<div>").addClass(this.options.className).hide().append(this.offset = $("<div>").addClass(this.options.className + "-offset").append($("<div>").addClass(this.options.className + "-background")).append($("<div>").addClass(this.options.className + "-icon"))));
                if (r.IE && r.IE < 7) {
                    var s = this.element[0].style;
                    s.position = "absolute";
                    s.setExpression("top", "((!!window.jQuery ? jQuery(window).scrollTop() + (.5 * jQuery(window).height()) : 0) + 'px')");
                    s.setExpression("left", "((!!window.jQuery ? jQuery(window).scrollLeft() + (.5 * jQuery(window).width()): 0) + 'px')")
                }
            },
            setSkin: function (a) {
                this.element[0].className = this.options.className + " " + this.options.className + "-" + a
            },
            startObserving: function () {
                this.element.bind("click", $.proxy(function (a) {
                    this.Window.hide()
                }, this))
            },
            start: function (a) {
                this.center();
                var b = H._frames && H._frames[H._position - 1];
                this.element.stop(1, 0).fadeTo(b ? b.view.options.effects.loading.show : 0, 1, a)
            },
            stop: function (a, b) {
                var c = H._frames && H._frames[H._position - 1];
                this.element.stop(1, 0).delay(b ? 0 : c ? c.view.options.effects.loading.dela : 0).fadeOut(c.view.options.effects.loading.hide, a)
            },
            center: function () {
                var a = 0;
                if (this.thumbnails) {
                    this.thumbnails.updateVars();
                    var a = this.thumbnails._vars.thumbnails.height
                }
                this.offset.css({
                    "margin-top": (this.Window.view.options.thumbnails ? (a * -0.5) : 0) + "px"
                })
            }
        });
        var C = {
            defaultSkin: "fresco",
            initialize: function () {
                this.queues = [];
                this.queues.showhide = $({});
                this.queues.update = $({});
                this.states = new States();
                this.timeouts = new Timeouts();
                this.build();
                this.startObserving();
                this.setSkin(this.defaultSkin)
            },
            build: function () {
                this.overlay = new Overlay(this);
                $(document.body).prepend(this.element = $("<div>").addClass("fr-window").append(this.bubble = $("<div>").addClass("fr-bubble").hide().append(this.frames = $("<div>").addClass("fr-frames")).append(this.thumbnails = $("<div>").addClass("fr-thumbnails"))));
                this.loading = new Loading(this);
                if (r.IE && r.IE < 7) {
                    var s = this.element[0].style;
                    s.position = "absolute";
                    s.setExpression("top", "((!!window.jQuery ? jQuery(window).scrollTop() : 0) + 'px')");
                    s.setExpression("left", "((!!window.jQuery ? jQuery(window).scrollLeft() : 0) + 'px')")
                }
                if (r.IE) {
                    if (r.IE < 9) {
                        this.element.addClass("fr-oldIE")
                    }
                    for (var i = 6; i <= 9; i++) {
                        if (r.IE < i) {
                            this.element.addClass("fr-ltIE" + i)
                        }
                    }
                }
                if (w.touch) {
                    this.element.addClass("fr-touch-enabled")
                }
                if (w.mobileTouch) {
                    this.element.addClass("fr-mobile-touch-enabled")
                }
                this.element.data("class-skinless", this.element[0].className);
                J.initialize(this.element);
                H.initialize(this.element);
                G.initialize();
                this.element.hide()
            },
            setSkin: function (a, b) {
                b = b || {};
                if (a) {
                    b.skin = a
                }
                this.overlay.setSkin(a);
                var c = this.element.data("class-skinless");
                this.element[0].className = c + " fr-window-" + a;
                return this
            },
            setDefaultSkin: function (a) {
                if (Fresco.skins[a]) {
                    this.defaultSkin = a
                }
            },
            startObserving: function () {
                $(document.documentElement).delegate(".fresco[href]", "click", function (a, b) {
                    a.stopPropagation();
                    a.preventDefault();
                    var b = a.currentTarget;
                    H.setXY({
                        x: a.pageX,
                        y: a.pageY
                    });
                    K.show(b)
                });
                $(document.documentElement).bind("click", function (a) {
                    H.setXY({
                        x: a.pageX,
                        y: a.pageY
                    })
                });
                this.element.delegate(".fr-ui-spacer, .fr-box-spacer", "click", $.proxy(function (a) {
                    a.stopPropagation()
                }, this));
                $(document.documentElement).delegate(".fr-overlay, .fr-ui, .fr-frame, .fr-bubble", "click", $.proxy(function (a) {
                    if (C.view && C.view.options && C.view.options.overlay && !C.view.options.overlay.close) {
                        return
                    }
                    a.preventDefault();
                    a.stopPropagation();
                    C.hide()
                }, this));
                this.element.bind("fresco:mousewheel", function (a) {
                    a.preventDefault()
                })
            },
            load: function (b, c) {
                var d = $.extend({}, arguments[2] || {});
                this._reset();
                var e = false;
                $.each(b, function (i, a) {
                    if (!a.options.thumbnail) {
                        e = true;
                        return false
                    }
                });
                if (e) {
                    $.each(b, function (i, a) {
                        a.options.thumbnail = false;
                        a.options.thumbnails = false
                    })
                }
                if (b.length < 2) {
                    var f = b[0].options.onClick;
                    if (f && f != "close") {
                        b[0].options.onClick = "close"
                    }
                }
                this.views = b;
                J.load(b);
                H.load(b);
                if (c) {
                    this.setPosition(c, function () {
                        if (d.callback) {
                            d.callback()
                        }
                    })
                }
            },
            hideOverlapping: function () {
                if (this.states.get("overlapping")) {
                    return
                }
                var c = $("embed, object, select");
                var d = [];
                c.each(function (i, a) {
                    var b;
                    if ($(a).is("object, embed") && ((b = $(a).find('param[name="wmode"]')[0]) && b.value && b.value.toLowerCase() == "transparent") || $(a).is("[wmode='transparent']")) {
                        return
                    }
                    d.push({
                        element: a,
                        visibility: $(a).css("visibility")
                    })
                });
                $.each(d, function (i, a) {
                    $(a.element).css({
                        visibility: "hidden"
                    })
                });
                this.states.set("overlapping", d)
            },
            restoreOverlapping: function () {
                var b = this.states.get("overlapping");
                if (b && b.length > 0) {
                    $.each(b, function (i, a) {
                        $(a.element).css({
                            visibility: a.visibility
                        })
                    })
                }
                this.states.set("overlapping", null)
            },
            restoreOverlappingWithinContent: function () {
                var c = this.states.get("overlapping");
                if (!c) {
                    return
                }
                $.each(c, $.proxy(function (i, a) {
                    var b;
                    if ((b = $(a.element).closest(".fs-content")[0]) && b == this.content[0]) {
                        $(a.element).css({
                            visibility: a.visibility
                        })
                    }
                }, this))
            },
            show: (function () {
                var e = function () {};
                return function (b) {
                    var c = H._frames && H._frames[H._position - 1],
                        shq = this.queues.showhide,
                        duration = (c && c.view.options.effects.window.hide) || 0;
                    if (this.states.get("visible")) {
                        if ($.type(b) == "function") {
                            b()
                        }
                        return
                    }
                    this.states.set("visible", true);
                    shq.queue([]);
                    this.hideOverlapping();
                    if (c && $.type(c.view.options.onShow) == "function") {
                        c.view.options.onShow.call(Fresco)
                    }
                    var d = 2;
                    shq.queue($.proxy(function (a) {
                        if (c.view.options.overlay) {
                            this.overlay.show($.proxy(function () {
                                if (--d < 1) {
                                    a()
                                }
                            }, this))
                        }
                        this.timeouts.set("show-window", $.proxy(function () {
                            this._show(function () {
                                if (--d < 1) {
                                    a()
                                }
                            })
                        }, this), duration > 1 ? Math.min(duration * 0.5, 50) : 1)
                    }, this));
                    e();
                    shq.queue($.proxy(function (a) {
                        G.enable();
                        a()
                    }, this));
                    if ($.type(b) == "function") {
                        shq.queue($.proxy(function (a) {
                            b();
                            a()
                        }), this)
                    }
                }
            })(),
            _show: function (a) {
                H.resize();
                this.element.show();
                this.bubble.stop(true);
                var b = H._frames && H._frames[H._position - 1];
                this.setOpacity(1, b.view.options.effects.window.show, $.proxy(function () {
                    if (a) {
                        a()
                    }
                }, this));
                return this
            },
            hide: function () {
                var c = H._frames && H._frames[H._position - 1],
                    shq = this.queues.showhide;
                shq.queue([]);
                this.stopQueues();
                this.loading.stop(null, true);
                var d = 1;
                shq.queue($.proxy(function (a) {
                    var b = c.view.options.effects.window.hide || 0;
                    this.bubble.stop(true, true).fadeOut(b, "easeInSine", $.proxy(function () {
                        this.element.hide();
                        H.hideAll();
                        if (--d < 1) {
                            this._hide();
                            a()
                        }
                    }, this));
                    if (c.view.options.overlay) {
                        d++;
                        this.timeouts.set("hide-overlay", $.proxy(function () {
                            this.overlay.hide($.proxy(function () {
                                if (--d < 1) {
                                    this._hide();
                                    a()
                                }
                            }, this))
                        }, this), b > 1 ? Math.min(b * 0.5, 150) : 1)
                    }
                }, this))
            },
            _hide: function () {
                this.states.set("visible", false);
                this.restoreOverlapping();
                G.disable();
                var a = H._frames && H._frames[H._position - 1];
                if (a && $.type(a.view.options.afterHide) == "function") {
                    a.view.options.afterHide.call(Fresco)
                }
                this.timeouts.clear();
                this._reset()
            },
            _reset: function () {
                var a = $.extend({
                    after: false,
                    before: false
                }, arguments[0] || {});
                if ($.type(a.before) == "function") {
                    a.before.call(Fresco)
                }
                this.stopQueues();
                this.timeouts.clear();
                this.position = -1;
                this._pinchZoomed = false;
                C.states.set("_m", false);
                if (this._m) {
                    $(this._m).stop().remove();
                    this._m = null
                }
                if (this._s) {
                    $(this._s).stop().remove();
                    this._s = null
                }
                if ($.type(a.after) == "function") {
                    a.after.call(Fresco)
                }
            },
            setOpacity: function (a, b, c) {
                this.bubble.stop(true, true).fadeTo(b || 0, a || 1, "easeOutSine", c)
            },
            stopQueues: function () {
                this.queues.update.queue([]);
                this.bubble.stop(true)
            },
            setPosition: function (a, b) {
                if (!a || this.position == a) {
                    return
                }
                this.timeouts.clear("_m");
                var c = this._position;
                this.position = a;
                this.view = this.views[a - 1];
                this.setSkin(this.view.options && this.view.options.skin, this.view.options);
                H.setPosition(a, b)
            }
        };
        var E = {
            viewport: function () {
                var a = {
                    height: $(window).height(),
                    width: $(window).width()
                };
                if (r.MobileSafari) {
                    a.width = window.innerWidth;
                    a.height = window.innerHeight
                }
                return a
            }
        };
        var F = {
            within: function (a) {
                var b = $.extend({
                    fit: "both",
                    ui: "inside"
                }, arguments[1] || {});
                if (!b.bounds) {
                    b.bounds = $.extend({}, H._boxDimensions)
                }
                var c = b.bounds,
                    size = $.extend({}, a),
                    f = 1,
                    attempts = 5;
                if (b.border) {
                    c.width -= 2 * b.border;
                    c.height -= 2 * b.border
                }
                var d = {
                    height: true,
                    width: true
                };
                switch (b.fit) {
                    case "none":
                        d = {};
                    case "width":
                    case "height":
                        d = {};
                        d[b.fit] = true;
                        break
                }
                while (attempts > 0 && ((d.width && size.width > c.width) || (d.height && size.height > c.height))) {
                    var e = 1,
                        scaleY = 1;
                    if (d.width && size.width > c.width) {
                        e = (c.width / size.width)
                    }
                    if (d.height && size.height > c.height) {
                        scaleY = (c.height / size.height)
                    }
                    var f = Math.min(e, scaleY);
                    size = {
                        width: Math.round(a.width * f),
                        height: Math.round(a.height * f)
                    };
                    attempts--
                }
                size.width = Math.max(size.width, 0);
                size.height = Math.max(size.height, 0);
                return size
            }
        };
        var G = {
            enabled: false,
            keyCode: {
                left: 37,
                right: 39,
                esc: 27
            },
            enable: function () {
                this.fetchOptions()
            },
            disable: function () {
                this.enabled = false
            },
            initialize: function () {
                this.fetchOptions();
                $(document).keydown($.proxy(this.onkeydown, this)).keyup($.proxy(this.onkeyup, this));
                G.disable()
            },
            fetchOptions: function () {
                var a = H._frames && H._frames[H._position - 1];
                this.enabled = a && a.view.options.keyboard
            },
            onkeydown: function (a) {
                if (!this.enabled || !C.element.is(":visible")) {
                    return
                }
                var b = this.getKeyByKeyCode(a.keyCode);
                if (!b || (b && this.enabled && !this.enabled[b])) {
                    return
                }
                a.preventDefault();
                a.stopPropagation();
                switch (b) {
                    case "left":
                        H.previous();
                        break;
                    case "right":
                        H.next();
                        break
                }
            },
            onkeyup: function (a) {
                if (!this.enabled || !C.element.is(":visible")) {
                    return
                }
                var b = this.getKeyByKeyCode(a.keyCode);
                if (!b || (b && this.enabled && !this.enabled[b])) {
                    return
                }
                switch (b) {
                    case "esc":
                        C.hide();
                        break
                }
            },
            getKeyByKeyCode: function (a) {
                for (var b in this.keyCode) {
                    if (this.keyCode[b] == a) {
                        return b
                    }
                }
                return null
            }
        };
        var H = {
            initialize: function (a) {
                if (!a) {
                    return
                }
                this.element = a;
                this._position = -1;
                this._visible = [];
                this._sideWidth = 0;
                this._tracking = [];
                this.queues = [];
                this.queues.sides = $({});
                this.frames = this.element.find(".fr-frames:first");
                this.uis = this.element.find(".fr-uis:first");
                this.updateDimensions();
                this.startObserving()
            },
            startObserving: function () {
                $(window).bind("resize orientationchange", $.proxy(function () {
                    if (C.states.get("visible")) {
                        this.resize()
                    }
                }, this));
                this.frames.delegate(".fr-side", "click", $.proxy(function (a) {
                    a.stopPropagation();
                    this.setXY({
                        x: a.pageX,
                        y: a.pageY
                    });
                    var b = $(a.target).closest(".fr-side").data("side");
                    this[b]()
                }, this))
            },
            load: function (b) {
                if (this._frames) {
                    $.each(this._frames, function (i, a) {
                        a.remove()
                    });
                    this._frames = null;
                    this._tracking = []
                }
                this._sideWidth = 0;
                this._frames = [];
                $.each(b, $.proxy(function (i, a) {
                    this._frames.push(new Frame(a, i + 1))
                }, this));
                this.updateDimensions()
            },
            handleTracking: function (a) {
                if (r.IE && r.IE < 9) {
                    this.setXY({
                        x: a.pageX,
                        y: a.pageY
                    });
                    this.position()
                } else {
                    this._tracking_timer = setTimeout($.proxy(function () {
                        this.setXY({
                            x: a.pageX,
                            y: a.pageY
                        });
                        this.position()
                    }, this), 30)
                }
            },
            clearTrackingTimer: function () {
                if (this._tracking_timer) {
                    clearTimeout(this._tracking_timer);
                    this._tracking_timer = null
                }
            },
            startTracking: function () {
                if (w.mobileTouch || this._handleTracking) {
                    return
                }
                this.element.bind("mousemove", this._handleTracking = $.proxy(this.handleTracking, this))
            },
            stopTracking: function () {
                if (w.mobileTouch || !this._handleTracking) {
                    return
                }
                this.element.unbind("mousemove", this._handleTracking);
                this._handleTracking = null;
                this.clearTrackingTimer()
            },
            setPosition: function (a, b) {
                this.clearLoads();
                this._position = a;
                var c = this._frames[a - 1];
                this.frames.append(c.frame);
                J.setPosition(a);
                c.load($.proxy(function () {
                    this.show(a, function () {
                        if (b) {
                            b()
                        }
                        if ($.type(c.view.options.afterPosition) == "function") {
                            c.view.options.afterPosition.call(Fresco, a)
                        }
                    })
                }, this));
                this.preloadSurroundingImages()
            },
            preloadSurroundingImages: function () {
                if (!(this._frames && this._frames.length > 1)) {
                    return
                }
                var c = this.getSurroundingIndexes(),
                    previous = c.previous,
                    next = c.next,
                    images = {
                        previous: previous != this._position && this._frames[previous - 1].view,
                        next: next != this._position && this._frames[next - 1].view
                    };
                if (this._position == 1) {
                    images.previous = null
                }
                if (this._position == this._frames.length) {
                    images.next = null
                }
                $.each(images, function (a, b) {
                    if (b && b.type == "image" && b.options.preload) {
                        I.preload(images[a].url, {
                            once: true
                        })
                    }
                })
            },
            getSurroundingIndexes: function () {
                if (!this._frames) {
                    return {}
                }
                var a = this._position,
                    length = this._frames.length;
                var b = (a <= 1) ? length : a - 1,
                    next = (a >= length) ? 1 : a + 1;
                return {
                    previous: b,
                    next: next
                }
            },
            mayPrevious: function () {
                var a = H._frames && H._frames[H._position - 1];
                return (a && a.view.options.loop && this._frames && this._frames.length > 1) || this._position != 1
            },
            previous: function (a) {
                if (a || this.mayPrevious()) {
                    C.setPosition(this.getSurroundingIndexes().previous)
                }
            },
            mayNext: function () {
                var a = H._frames && H._frames[H._position - 1];
                return (a && a.view.options.loop && this._frames && this._frames.length > 1) || (this._frames && this._frames.length > 1 && this.getSurroundingIndexes().next != 1)
            },
            next: function (a) {
                if (a || this.mayNext()) {
                    C.setPosition(this.getSurroundingIndexes().next)
                }
            },
            setVisible: function (a) {
                if (!this.isVisible(a)) {
                    this._visible.push(a)
                }
            },
            setHidden: function (b) {
                this._visible = $.grep(this._visible, function (a) {
                    return a != b
                })
            },
            isVisible: function (a) {
                return $.inArray(a, this._visible) > -1
            },
            resize: function () {
                if (!(r.IE && r.IE < 7)) {
                    J.resize()
                }
                this.updateDimensions();
                this.frames.css(px(this._dimensions));
                $.each(this._frames, function (i, a) {
                    a.resize()
                })
            },
            position: function () {
                if (this._tracking.length < 1) {
                    return
                }
                $.each(this._tracking, function (i, a) {
                    a.position()
                })
            },
            setXY: function (a) {
                a.y -= $(window).scrollTop();
                a.x -= $(window).scrollLeft();
                var b = {
                    y: Math.min(Math.max(a.y / this._dimensions.height, 0), 1),
                    x: Math.min(Math.max(a.x / this._dimensions.width, 0), 1)
                };
                var c = 20;
                var d = {
                    x: "width",
                    y: "height"
                };
                var e = {};
                $.each("x y".split(" "), $.proxy(function (i, z) {
                    e[z] = Math.min(Math.max(c / this._dimensions[d[z]], 0), 1);
                    b[z] *= 1 + 2 * e[z];
                    b[z] -= e[z];
                    b[z] = Math.min(Math.max(b[z], 0), 1)
                }, this));
                this.setXYP(b)
            },
            setXYP: function (a) {
                this._xyp = a
            },
            updateDimensions: function (e) {
                var f = E.viewport();
                if (J.visible()) {
                    J.updateVars();
                    f.height -= J._vars.thumbnails.height
                }
                this._sideWidth = 0;
                if (this._frames) {
                    $.each(this._frames, $.proxy(function (i, b) {
                        if (b.view.options.ui == "outside") {
                            var c = b.close;
                            if (this._frames.length > 1) {
                                if (b._pos) {
                                    c = c.add(b._pos)
                                }
                                if (b._next_button) {
                                    c = c.add(b._next_button)
                                }
                            }
                            var d = 0;
                            b._whileVisible(function () {
                                $.each(c, function (i, a) {
                                    d = Math.max(d, $(a).outerWidth(true))
                                })
                            });
                            this._sideWidth = Math.max(this._sideWidth, d) || 0
                        }
                    }, this))
                }
                var g = $.extend({}, f, {
                    width: f.width - 2 * (this._sideWidth || 0)
                });
                this._dimensions = f;
                this._boxDimensions = g
            },
            pn: function () {
                return {
                    previous: this._position - 1 > 0,
                    next: this._position + 1 <= this._frames.length
                }
            },
            show: function (b, c) {
                var d = [];
                $.each(this._frames, function (i, a) {
                    if (a._position != b) {
                        d.push(a)
                    }
                });
                var e = d.length + 1;
                var f = this._frames[this._position - 1];
                J[f.view.options.thumbnails ? "show" : "hide"]();
                this.resize();
                var g = f.view.options.effects.content.sync;
                $.each(d, $.proxy(function (i, a) {
                    a.hide($.proxy(function () {
                        if (!g) {
                            if (e-- <= 2) {
                                this._frames[b - 1].show(c)
                            }
                        } else {
                            if (c && e-- <= 1) {
                                c()
                            }
                        }
                    }, this))
                }, this));
                if (g) {
                    this._frames[b - 1].show(function () {
                        if (c && e-- <= 1) {
                            c()
                        }
                    })
                }
            },
            hideAll: function () {
                $.each(this._visible, $.proxy(function (j, i) {
                    this._frames[i - 1].hide()
                }, this));
                J.hide();
                this.setXY({
                    x: 0,
                    y: 0
                })
            },
            hideAllBut: function (b) {
                $.each(this._frames, $.proxy(function (i, a) {
                    if (a.position != b) {
                        a.hide()
                    }
                }, this))
            },
            setTracking: function (a) {
                if (!this.isTracking(a)) {
                    this._tracking.push(this._frames[a - 1]);
                    if (this._tracking.length == 1) {
                        this.startTracking()
                    }
                }
            },
            clearTracking: function () {
                this._tracking = []
            },
            removeTracking: function (b) {
                this._tracking = $.grep(this._tracking, function (a) {
                    return a._position != b
                });
                if (this._tracking.length < 1) {
                    this.stopTracking()
                }
            },
            isTracking: function (b) {
                var c = false;
                $.each(this._tracking, function (i, a) {
                    if (a._position == b) {
                        c = true;
                        return false
                    }
                });
                return c
            },
            bounds: function () {
                var a = this._dimensions;
                if (C._scrollbarWidth) {
                    a.width -= scrollbarWidth
                }
                return a
            },
            clearLoads: function () {
                $.each(this._frames, $.proxy(function (i, a) {
                    a.clearLoad()
                }, this))
            }
        };

        function Frame() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(Frame.prototype, {
            initialize: function (a, b) {
                this.view = a;
                this._position = b;
                this._dimensions = {};
                this.build()
            },
            remove: function () {
                this.clearUITimer();
                if (this._track) {
                    H.removeTracking(this._position);
                    this._track = false
                }
                this.frame.remove();
                this.frame = null;
                this.ui.remove();
                this.ui = null;
                this.view = null;
                this._dimensions = {};
                this._reset();
                if (this._interval_load) {
                    clearInterval(this._interval_load);
                    this._interval_load = null
                }
            },
            build: function () {
                var b = this.view.options.ui,
                    positions = C.views.length;
                H.frames.append(this.frame = $("<div>").addClass("fr-frame").append(this.box = $("<div>").addClass("fr-box").addClass("fr-box-has-ui-" + this.view.options.ui)).hide());
                var c = this.view.options.onClick;
                if (this.view.type == "image" && ((c == "next" && (this.view.options.loop || (!this.view.options.loop && this._position != C.views.length))) || c == "close")) {
                    this.frame.addClass("fr-frame-onclick-" + c.toLowerCase())
                }
                if (this.view.options.ui == "outside") {
                    this.frame.prepend(this.ui = $("<div>").addClass("fr-ui fr-ui-outside"))
                } else {
                    this.frame.append(this.ui = $("<div>").addClass("fr-ui fr-ui-inside"))
                }
                this.box.append(this.box_spacer = $("<div>").addClass("fr-box-spacer").append(this.box_padder = $("<div>").addClass("fr-box-padder").append(this.box_outer_border = $("<div>").addClass("fr-box-outer-border").append(this.box_wrapper = $("<div>").addClass("fr-box-wrapper")))));
                if (w.mobileTouch) {
                    A(this.box, function (a) {
                        H[a == "left" ? "next" : "previous"]()
                    }, false)
                }
                this.box_spacer.bind("click", $.proxy(function (a) {
                    if (a.target == this.box_spacer[0] && this.view.options.overlay && this.view.options.overlay.close) {
                        C.hide()
                    }
                }, this));
                this.spacers = this.box_spacer;
                this.wrappers = this.box_wrapper;
                this.padders = this.box_padder;
                if (this.view.options.ui == "outside") {
                    this.ui.append(this.ui_wrapper = $("<div>").addClass("fr-ui-wrapper-outside"))
                } else {
                    this.ui.append(this.ui_spacer = $("<div>").addClass("fr-ui-spacer").append(this.ui_padder = $("<div>").addClass("fr-ui-padder").append(this.ui_outer_border = $("<div>").addClass("fr-ui-outer-border").append(this.ui_toggle = $("<div>").addClass("fr-ui-toggle").append(this.ui_wrapper = $("<div>").addClass("fr-ui-wrapper"))))));
                    this.spacers = this.spacers.add(this.ui_spacer);
                    this.wrapper = this.wrappers.add(this.ui_wrapper);
                    this.padders = this.padders.add(this.ui_padder)
                }
                if (positions > 1) {
                    this.ui_wrapper.append(this._next = $("<div>").addClass("fr-side fr-side-next").append(this._next_button = $("<div>").addClass("fr-side-button").append($("<div>").addClass("fr-side-button-icon"))).data("side", "next"));
                    if (this._position == positions && !this.view.options.loop) {
                        this._next.addClass("fr-side-disabled");
                        this._next_button.addClass("fr-side-button-disabled")
                    }
                    this.ui_wrapper.append(this._previous = $("<div>").addClass("fr-side fr-side-previous").append(this._previous_button = $("<div>").addClass("fr-side-button").append($("<div>").addClass("fr-side-button-icon"))).data("side", "previous"));
                    if (this._position == 1 && !this.view.options.loop) {
                        this._previous.addClass("fr-side-disabled");
                        this._previous_button.addClass("fr-side-button-disabled")
                    }
                }
                this.frame.addClass("fr-no-caption");
                if (this.view.caption || (this.view.options.ui == "inside" && !this.view.caption)) {
                    this[this.view.options.ui == "inside" ? "ui_wrapper" : "frame"].append(this.info = $("<div>").addClass("fr-info fr-info-" + this.view.options.ui).append(this.info_background = $("<div>").addClass("fr-info-background")).append(this.info_padder = $("<div>").addClass("fr-info-padder")));
                    this.info.bind("click", function (a) {
                        a.stopPropagation()
                    })
                }
                if (this.view.caption) {
                    this.frame.removeClass("fr-no-caption").addClass("fr-has-caption");
                    this.info_padder.append(this.caption = $("<div>").addClass("fr-caption").html(this.view.caption))
                }
                if (positions > 1 && this.view.options.position) {
                    var d = this._position + " / " + positions;
                    this.frame.addClass("fr-has-position");
                    var b = this.view.options.ui;
                    this[b == "inside" ? "info_padder" : "ui_wrapper"][b == "inside" ? "prepend" : "append"](this._pos = $("<div>").addClass("fr-position").append($("<div>").addClass("fr-position-background")).append($("<span>").addClass("fr-position-text").html(d)))
                }
                this.ui_wrapper.append(this.close = $("<div>").addClass("fr-close").bind("click", function () {
                    C.hide()
                }).append($("<span>").addClass("fr-close-background")).append($("<span>").addClass("fr-close-icon")));
                if (this.view.type == "image" && this.view.options.onClick == "close") {
                    this[this.view.options.ui == "outside" ? "box_wrapper" : "ui_padder"].bind("click", function (a) {
                        a.preventDefault();
                        a.stopPropagation();
                        C.hide()
                    })
                }
                this.frame.hide()
            },
            _getInfoHeight: function (a) {
                if (!this.view.caption) {
                    return 0
                }
                if (this.view.options.ui == "outside") {
                    a = Math.min(a, H._boxDimensions.width)
                }
                var b, info_pw = this.info.css("width");
                this.info.css({
                    width: a + "px"
                });
                b = parseFloat(this.info.css("height"));
                this.info.css({
                    width: info_pw
                });
                return b
            },
            _whileVisible: function (b, c) {
                var d = [];
                var e = C.element.add(C.bubble).add(this.frame).add(this.ui);
                if (c) {
                    e = e.add(c)
                }
                $.each(e, function (i, a) {
                    d.push({
                        visible: $(a).is(":visible"),
                        element: $(a).show()
                    })
                });
                b();
                $.each(d, function (i, a) {
                    if (!a.visible) {
                        a.element.hide()
                    }
                })
            },
            getLayout: function () {
                this.updateVars();
                var d = this._dimensions.max,
                    ui = this.view.options.ui,
                    fit = this._fit,
                    i = this._spacing,
                    border = this._border;
                var e = F.within(d, {
                    fit: fit,
                    ui: ui,
                    border: border
                });
                var f = $.extend({}, e),
                    contentPosition = {
                        top: 0,
                        left: 0
                    };
                if (border) {
                    f = F.within(f, {
                        bounds: e,
                        ui: ui
                    });
                    e.width += 2 * border;
                    e.height += 2 * border
                }
                if (i.horizontal || i.vertical) {
                    var g = $.extend({}, H._boxDimensions);
                    if (border) {
                        g.width -= 2 * border;
                        g.height -= 2 * border
                    }
                    g = {
                        width: Math.max(g.width - 2 * i.horizontal, 0),
                        height: Math.max(g.height - 2 * i.vertical, 0)
                    };
                    f = F.within(f, {
                        fit: fit,
                        bounds: g,
                        ui: ui
                    })
                }
                var h = {
                    caption: true
                }, cfitted = false;
                if (ui == "outside") {
                    var i = {
                        height: e.height - f.height,
                        width: e.width - f.width
                    };
                    var j = $.extend({}, f),
                        noCaptionClass = this.caption && this.frame.hasClass("fr-no-caption");
                    var k;
                    if (this.caption) {
                        k = this.caption;
                        this.info.removeClass("fr-no-caption");
                        var l = this.frame.hasClass("fr-no-caption");
                        this.frame.removeClass("fr-no-caption");
                        var m = this.frame.hasClass("fr-has-caption");
                        this.frame.addClass("fr-has-caption")
                    }
                    C.element.css({
                        visibility: "visible"
                    });
                    this._whileVisible($.proxy(function () {
                        var a = 0,
                            attempts = 2;
                        while ((a < attempts)) {
                            h.height = this._getInfoHeight(f.width);
                            var b = 0.5 * (H._boxDimensions.height - 2 * border - (i.vertical ? i.vertical * 2 : 0) - f.height);
                            if (b < h.height) {
                                f = F.within(f, {
                                    bounds: $.extend({}, {
                                        width: f.width,
                                        height: Math.max(f.height - h.height, 0)
                                    }),
                                    fit: fit,
                                    ui: ui
                                })
                            }
                            a++
                        }
                        h.height = this._getInfoHeight(f.width);
                        var c = E.viewport();
                        if (((c.height <= 320 && c.width <= 568) || (c.width <= 320 && c.height <= 568)) || (h.height >= 0.5 * f.height) || (h.height >= 0.6 * f.width)) {
                            h.caption = false;
                            h.height = 0;
                            f = j
                        }
                    }, this), k);
                    C.element.css({
                        visibility: "visible"
                    });
                    if (l) {
                        this.frame.addClass("fr-no-caption")
                    }
                    if (m) {
                        this.frame.addClass("fr-has-caption")
                    }
                    var n = {
                        height: e.height - f.height,
                        width: e.width - f.width
                    };
                    e.height += (i.height - n.height);
                    e.width += (i.width - n.width);
                    if (f.height != j.height) {
                        cfitted = true
                    }
                } else {
                    h.height = 0
                }
                var o = {
                    width: f.width + 2 * border,
                    height: f.height + 2 * border
                };
                if (h.height) {
                    e.height += h.height
                }
                if (ui == "inside") {
                    h.height = 0
                }
                var p = {
                    spacer: {
                        dimensions: e
                    },
                    padder: {
                        dimensions: o
                    },
                    wrapper: {
                        dimensions: f,
                        bounds: o,
                        margin: {
                            top: 0.5 * (e.height - o.height) - (0.5 * h.height),
                            left: 0.5 * (e.width - o.width)
                        }
                    },
                    content: {
                        dimensions: f
                    },
                    info: h
                };
                if (ui == "outside") {
                    p.info.top = p.wrapper.margin.top;
                    h.width = Math.min(f.width, H._boxDimensions.width)
                }
                var g = $.extend({}, H._boxDimensions);
                if (ui == "outside") {
                    p.box = {
                        dimensions: {
                            width: H._boxDimensions.width
                        },
                        position: {
                            left: 0.5 * (H._dimensions.width - H._boxDimensions.width)
                        }
                    }
                }
                p.ui = {
                    spacer: {
                        dimensions: {
                            width: Math.min(e.width, g.width),
                            height: Math.min(e.height, g.height)
                        }
                    },
                    padder: {
                        dimensions: o
                    },
                    wrapper: {
                        dimensions: {
                            width: Math.min(p.wrapper.dimensions.width, g.width - 2 * border),
                            height: Math.min(p.wrapper.dimensions.height, g.height - 2 * border)
                        },
                        margin: {
                            top: p.wrapper.margin.top + border,
                            left: p.wrapper.margin.left + border
                        }
                    }
                };
                return p
            },
            updateVars: function () {
                var a = $.extend({}, this._dimensions.max);
                var b = parseInt(this.box_outer_border.css("border-top-width"));
                this._border = b;
                if (b) {
                    a.width -= 2 * b;
                    a.height -= 2 * b
                }
                var c = this.view.options.fit;
                if (c == "smart") {
                    if (a.width > a.height) {
                        c = "height"
                    } else {
                        if (a.height > a.width) {
                            c = "width"
                        } else {
                            c = "none"
                        }
                    }
                } else {
                    if (!c) {
                        c = "none"
                    }
                }
                this._fit = c;
                var d = this.view.options.spacing[this._fit];
                this._spacing = d
            },
            clearLoadTimer: function () {
                if (this._loadTimer) {
                    clearTimeout(this._loadTimer);
                    this._loadTimer = null
                }
            },
            clearLoad: function () {
                if (this._loadTimer && this._loading && !this._loaded) {
                    this.clearLoadTimer();
                    this._loading = false
                }
            },
            load: function (i) {
                if (this._loaded || this._loading) {
                    if (this._loaded) {
                        this.afterLoad(i)
                    }
                    return
                }
                if (!(I.cache.get(this.view.url) || I.preloaded.getDimensions(this.view.url))) {
                    C.loading.start()
                }
                this._loading = true;
                this._loadTimer = setTimeout($.proxy(function () {
                    this.clearLoadTimer();
                    switch (this.view.type) {
                        case "image":
                            I.get(this.view.url, $.proxy(function (c, d) {
                                this._dimensions._max = c;
                                this._dimensions.max = c;
                                this._loaded = true;
                                this._loading = false;
                                this.updateVars();
                                var e = this.getLayout();
                                this._dimensions.spacer = e.spacer.dimensions;
                                this._dimensions.content = e.content.dimensions;
                                this.content = $("<img>").attr({
                                    src: this.view.url
                                });
                                this.box_wrapper.append(this.content.addClass("fr-content fr-content-image"));
                                this.box_wrapper.append($("<div>").addClass("fr-content-image-overlay "));
                                var f;
                                if (this.view.options.ui == "outside" && ((f = this.view.options.onClick) && f == "next" || f == "previous-next")) {
                                    if (!this.view.options.loop && this._position != H._frames.length) {
                                        this.box_wrapper.append($("<div>").addClass("fr-onclick-side fr-onclick-next").data("side", "next"))
                                    }
                                    if (f == "previous-next" && (!this.view.options.loop && this._position != 1)) {
                                        this.box_wrapper.append($("<div>").addClass("fr-onclick-side fr-onclick-previous").data("side", "previous"))
                                    }
                                    this.frame.delegate(".fr-onclick-side", "click", $.proxy(function (a) {
                                        var b = $(a.target).data("side");
                                        H[b]()
                                    }, this));
                                    this.frame.delegate(".fr-onclick-side", "mouseenter", $.proxy(function (a) {
                                        var b = $(a.target).data("side"),
                                            button = b && this["_" + b + "_button"];
                                        if (!button) {
                                            return
                                        }
                                        this["_" + b + "_button"].addClass("fr-side-button-active")
                                    }, this));
                                    this.frame.delegate(".fr-onclick-side", "mouseleave", $.proxy(function (a) {
                                        var b = $(a.target).data("side"),
                                            button = b && this["_" + b + "_button"];
                                        if (!button) {
                                            return
                                        }
                                        this["_" + b + "_button"].removeClass("fr-side-button-active")
                                    }, this))
                                }
                                this.afterLoad(i)
                            }, this));
                            break;
                        case "youtube":
                        case "vimeo":
                            var g = {
                                width: this.view.options.width,
                                height: this.view.options.height
                            };
                            if (this.view.type == "youtube" && this.view.options.youtube && this.view.options.youtube.hd) {
                                this.view._data.quality = (g.width > 720) ? "hd1080" : "hd720"
                            }
                            this._dimensions._max = g;
                            this._dimensions.max = g;
                            this._loaded = true;
                            this._loading = false;
                            this.updateVars();
                            var h = this.getLayout();
                            this._dimensions.spacer = h.spacer.dimensions;
                            this._dimensions.content = h.content.dimensions;
                            this.box_wrapper.append(this.content = $("<div>").addClass("fr-content fr-content-" + this.view.type));
                            this.afterLoad(i);
                            break
                    }
                }, this), 10)
            },
            afterLoad: function (a) {
                this.resize();
                if (this.view.options.ui == "inside") {
                    this.ui_outer_border.bind("mouseenter", $.proxy(this.showUI, this)).bind("mouseleave", $.proxy(this.hideUI, this))
                }
                if (!w.mobileTouch) {
                    this.ui.delegate(".fr-ui-padder", "mousemove", $.proxy(function () {
                        if (!this.ui_wrapper.is(":visible")) {
                            this.showUI()
                        }
                        this.startUITimer()
                    }, this))
                } else {
                    this.box.bind("click", $.proxy(function () {
                        if (!this.ui_wrapper.is(":visible")) {
                            this.showUI()
                        }
                        this.startUITimer()
                    }, this))
                }
                var b;
                if (H._frames && (b = H._frames[H._position - 1]) && b.view.url == this.view.url) {
                    C.loading.stop()
                }
                if (a) {
                    a()
                }
            },
            resize: function () {
                if (this.content) {
                    var a = this.getLayout();
                    this._dimensions.spacer = a.spacer.dimensions;
                    this._dimensions.content = a.content.dimensions;
                    this.box_spacer.css(px(a.spacer.dimensions));
                    if (this.view.options.ui == "inside") {
                        this.ui_spacer.css(px(a.ui.spacer.dimensions))
                    }
                    this.box_wrapper.add(this.box_outer_border).css(px(a.wrapper.dimensions));
                    var b = 0;
                    if (this.view.options.ui == "outside" && a.info.caption) {
                        b = a.info.height
                    }
                    this.box_outer_border.css({
                        "padding-bottom": b + "px"
                    });
                    this.box_padder.css(px({
                        width: a.padder.dimensions.width,
                        height: a.padder.dimensions.height + b
                    }));
                    if (a.spacer.dimensions.width > (this.view.options.ui == "outside" ? a.box.dimensions.width : E.viewport().width)) {
                        this.box.addClass("fr-prevent-swipe")
                    } else {
                        this.box.removeClass("fr-prevent-swipe")
                    }
                    if (this.view.options.ui == "outside") {
                        if (this.caption) {
                            this.info.css(px({
                                width: a.info.width
                            }))
                        }
                    } else {
                        this.ui_wrapper.add(this.ui_outer_border).add(this.ui_toggle).css(px(a.ui.wrapper.dimensions));
                        this.ui_padder.css(px(a.ui.padder.dimensions));
                        var c = 0;
                        if (this.caption) {
                            var d = this.frame.hasClass("fr-no-caption"),
                                has_hascap = this.frame.hasClass("fr-has-caption");
                            this.frame.removeClass("fr-no-caption");
                            this.frame.addClass("fr-has-caption");
                            var c = 0;
                            this._whileVisible($.proxy(function () {
                                c = this.info.outerHeight()
                            }, this), this.ui_wrapper.add(this.caption));
                            var e = E.viewport();
                            if (c >= 0.45 * a.wrapper.dimensions.height || ((e.height <= 320 && e.width <= 568) || (e.width <= 320 && e.height <= 568))) {
                                a.info.caption = false
                            }
                            if (d) {
                                this.frame.addClass("fr-no-caption")
                            }
                            if (!has_hascap) {
                                this.frame.removeClass("fr-has-caption")
                            }
                        }
                    }
                    if (this.caption) {
                        var f = a.info.caption;
                        this.caption[f ? "show" : "hide"]();
                        this.frame[(!f ? "add" : "remove") + "Class"]("fr-no-caption");
                        this.frame[(!f ? "remove" : "add") + "Class"]("fr-has-caption")
                    }
                    this.box_padder.add(this.ui_padder).css(px(a.wrapper.margin));
                    var g = H._boxDimensions,
                        spacer_dimensions = this._dimensions.spacer;
                    this.overlap = {
                        y: spacer_dimensions.height - g.height,
                        x: spacer_dimensions.width - g.width
                    };
                    this._track = this.overlap.x > 0 || this.overlap.y > 0;
                    H[(this._track ? "set" : "remove") + "Tracking"](this._position);
                    if (r.IE && r.IE < 8 && this.view.type == "image") {
                        this.content.css(px(a.wrapper.dimensions))
                    }
                    if (/^(vimeo|youtube)$/.test(this.view.type)) {
                        var h = a.wrapper.dimensions;
                        if (this.player) {
                            this.player.setSize(h.width, h.height)
                        } else {
                            if (this.player_iframe) {
                                this.player_iframe.attr(h)
                            }
                        }
                    }
                }
                this.position()
            },
            position: function () {
                if (!this.content) {
                    return
                }
                var a = H._xyp;
                var b = H._boxDimensions,
                    spacer_dimensions = this._dimensions.spacer;
                var c = {
                    top: 0,
                    left: 0
                };
                var d = this.overlap;
                this.frame.removeClass("fr-frame-touch");
                if (d.x || d.y) {
                    if (w.scroll) {
                        this.frame.addClass("fr-frame-touch")
                    }
                }
                if (d.y > 0) {
                    c.top = 0 - a.y * d.y
                } else {
                    c.top = b.height * 0.5 - spacer_dimensions.height * 0.5
                }
                if (d.x > 0) {
                    c.left = 0 - a.x * d.x
                } else {
                    c.left = b.width * 0.5 - spacer_dimensions.width * 0.5
                }
                if (w.mobileTouch) {
                    if (d.y > 0) {
                        c.top = 0
                    }
                    if (d.x > 0) {
                        c.left = 0
                    }
                    this.box_spacer.css({
                        position: "relative"
                    })
                }
                this._style = c;
                this.box_spacer.css({
                    top: c.top + "px",
                    left: c.left + "px"
                });
                var e = $.extend({}, c);
                if (e.top < 0) {
                    e.top = 0
                }
                if (e.left < 0) {
                    e.left = 0
                }
                if (this.view.options.ui == "outside") {
                    var f = this.getLayout();
                    this.box.css(px(f.box.dimensions)).css(px(f.box.position));
                    if (this.view.caption) {
                        var g = c.top + f.wrapper.margin.top + f.wrapper.dimensions.height + this._border;
                        if (g > H._boxDimensions.height - f.info.height) {
                            g = H._boxDimensions.height - f.info.height
                        }
                        var h = H._sideWidth + c.left + f.wrapper.margin.left + this._border;
                        if (h < H._sideWidth) {
                            h = H._sideWidth
                        }
                        if (h + f.info.width > H._sideWidth + f.box.dimensions.width) {
                            h = H._sideWidth
                        }
                        this.info.css({
                            top: g + "px",
                            left: h + "px"
                        })
                    }
                } else {
                    this.ui_spacer.css({
                        left: e.left + "px",
                        top: e.top + "px"
                    })
                }
            },
            setDimensions: function (a) {
                this.dimensions = a
            },
            _preShow: function () {
                switch (this.view.type) {
                    case "youtube":
                        var b = r.IE && r.IE < 8,
                            d = this.getLayout(),
                            lwd = d.wrapper.dimensions;
                        if ( !! window.YT) {
                            var p;
                            this.content.append(this.player_div = $("<div>").append(p = $("<div>")[0]));
                            this.player = new YT.Player(p, {
                                height: lwd.height,
                                width: lwd.width,
                                videoId: this.view._data.id,
                                playerVars: this.view.options.youtube,
                                events: b ? {} : {
                                    onReady: $.proxy(function (a) {
                                        if (this.view.options.youtube.hd) {
                                            try {
                                                a.target.setPlaybackQuality(this.view._data.quality)
                                            } catch (e) {}
                                        }
                                        this.resize()
                                    }, this)
                                }
                            })
                        } else {
                            var c = $.param(this.view.options.youtube || {});
                            this.content.append(this.player_iframe = $("<iframe webkitAllowFullScreen mozallowfullscreen allowFullScreen>").attr({
                                src: "http://www.youtube.com/embed/" + this.view._data.id + "?" + c,
                                height: lwd.height,
                                width: lwd.width,
                                frameborder: 0
                            }))
                        }
                        break;
                    case "vimeo":
                        var d = this.getLayout(),
                            lwd = d.wrapper.dimensions;
                        var c = $.param(this.view.options.vimeo || {});
                        this.content.append(this.player_iframe = $("<iframe webkitAllowFullScreen mozallowfullscreen allowFullScreen>").attr({
                            src: "http://player.vimeo.com/video/" + this.view._data.id + "?" + c,
                            height: lwd.height,
                            width: lwd.width,
                            frameborder: 0
                        }));
                        break
                }
            },
            show: function (a) {
                var b = r.IE && r.IE < 8;
                this._preShow();
                H.setVisible(this._position);
                this.frame.stop(1, 0);
                this.ui.stop(1, 0);
                this.showUI(null, true);
                if (this._track) {
                    H.setTracking(this._position)
                }
                this.setOpacity(1, Math.max(this.view.options.effects.content.show, r.IE && r.IE < 9 ? 0 : 10), $.proxy(function () {
                    if (a) {
                        a()
                    }
                }, this))
            },
            _postHide: function () {
                if (this.player_iframe) {
                    this.player_iframe.remove();
                    this.player_iframe = null
                }
                if (this.player) {
                    this.player.destroy();
                    this.player = null
                }
                if (this.player_div) {
                    this.player_div.remove();
                    this.player_div = null
                }
            },
            _reset: function () {
                H.removeTracking(this._position);
                H.setHidden(this._position);
                this._postHide()
            },
            hide: function (a) {
                var b = Math.max(this.view.options.effects.content.hide || 0, r.IE && r.IE < 9 ? 0 : 10);
                var c = this.view.options.effects.content.sync ? "easeInQuad" : "easeOutSine";
                this.frame.stop(1, 0).fadeOut(b, c, $.proxy(function () {
                    this._reset();
                    if (a) {
                        a()
                    }
                }, this))
            },
            setOpacity: function (a, b, c) {
                var d = this.view.options.effects.content.sync ? "easeOutQuart" : "easeInSine";
                this.frame.stop(1, 0).fadeTo(b || 0, a, d, c)
            },
            showUI: function (a, b) {
                if (!b) {
                    this.ui_wrapper.stop(1, 0).fadeTo(b ? 0 : this.view.options.effects.ui.show, 1, "easeInSine", $.proxy(function () {
                        this.startUITimer();
                        if ($.type(a) == "function") {
                            a()
                        }
                    }, this))
                } else {
                    this.ui_wrapper.show();
                    this.startUITimer();
                    if ($.type(a) == "function") {
                        a()
                    }
                }
            },
            hideUI: function (a, b) {
                if (this.view.options.ui == "outside") {
                    return
                }
                if (!b) {
                    this.ui_wrapper.stop(1, 0).fadeOut(b ? 0 : this.view.options.effects.ui.hide, "easeOutSine", function () {
                        if ($.type(a) == "function") {
                            a()
                        }
                    })
                } else {
                    this.ui_wrapper.hide();
                    if ($.type(a) == "function") {
                        a()
                    }
                }
            },
            clearUITimer: function () {
                if (this._ui_timer) {
                    clearTimeout(this._ui_timer);
                    this._ui_timer = null
                }
            },
            startUITimer: function () {
                this.clearUITimer();
                this._ui_timer = setTimeout($.proxy(function () {
                    this.hideUI()
                }, this), this.view.options.effects.ui.delay)
            },
            hideUIDelayed: function () {
                this.clearUITimer();
                this._ui_timer = setTimeout($.proxy(function () {
                    this.hideUI()
                }, this), this.view.options.effects.ui.delay)
            }
        });

        function Timeouts() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(Timeouts.prototype, {
            initialize: function () {
                this._timeouts = {};
                this._count = 0
            },
            set: function (a, b, c) {
                if ($.type(a) == "string") {
                    this.clear(a)
                }
                if ($.type(a) == "function") {
                    c = b;
                    b = a;
                    while (this._timeouts["timeout_" + this._count]) {
                        this._count++
                    }
                    a = "timeout_" + this._count
                }
                this._timeouts[a] = window.setTimeout($.proxy(function () {
                    if (b) {
                        b()
                    }
                    this._timeouts[a] = null;
                    delete this._timeouts[a]
                }, this), c)
            },
            get: function (a) {
                return this._timeouts[a]
            },
            clear: function (b) {
                if (!b) {
                    $.each(this._timeouts, $.proxy(function (i, a) {
                        window.clearTimeout(a);
                        this._timeouts[i] = null;
                        delete this._timeouts[i]
                    }, this));
                    this._timeouts = {}
                }
                if (this._timeouts[b]) {
                    window.clearTimeout(this._timeouts[b]);
                    this._timeouts[b] = null;
                    delete this._timeouts[b]
                }
            }
        });

        function States() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(States.prototype, {
            initialize: function () {
                this._states = {}
            },
            set: function (a, b) {
                this._states[a] = b
            },
            get: function (a) {
                return this._states[a] || false
            }
        });

        function View() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(View.prototype, {
            initialize: function (a) {
                var b = arguments[1] || {};
                var c = {};
                if ($.type(a) == "string") {
                    a = {
                        url: a
                    }
                } else {
                    if (a && a.nodeType == 1) {
                        var d = $(a);
                        a = {
                            element: d[0],
                            url: d.attr("href"),
                            caption: d.data("fresco-caption"),
                            group: d.data("fresco-group"),
                            extension: d.data("fresco-extension"),
                            type: d.data("fresco-type"),
                            options: (d.data("fresco-options") && eval("({" + d.data("fresco-options") + "})")) || {}
                        }
                    }
                }
                if (a) {
                    if (!a.extension) {
                        a.extension = detectExtension(a.url)
                    }
                    if (!a.type) {
                        var c = getURIData(a.url);
                        a._data = c;
                        a.type = c.type
                    }
                }
                if (!a._data) {
                    a._data = getURIData(a.url)
                }
                if (a && a.options) {
                    a.options = $.extend(true, $.extend({}, b), $.extend({}, a.options))
                } else {
                    a.options = $.extend({}, b)
                }
                a.options = B.create(a.options, a.type, a._data);
                $.extend(this, a);
                return this
            }
        });
        var I = {
            get: function (a, b, c) {
                if ($.type(b) == "function") {
                    c = b;
                    b = {}
                }
                b = $.extend({
                    track: true,
                    type: false,
                    lifetime: 1000 * 60 * 5
                }, b || {});
                var d = I.cache.get(a),
                    type = b.type || getURIData(a).type,
                    data = {
                        type: type,
                        callback: c
                    };
                if (!d && type == "image") {
                    var e;
                    if ((e = I.preloaded.get(a)) && e.dimensions) {
                        d = e;
                        I.cache.set(a, e.dimensions, e.data)
                    }
                }
                if (!d) {
                    if (b.track) {
                        I.loading.clear(a)
                    }
                    switch (type) {
                        case "image":
                            var f = new Image();
                            f.onload = function () {
                                f.onload = function () {};
                                d = {
                                    dimensions: {
                                        width: f.width,
                                        height: f.height
                                    }
                                };
                                data.image = f;
                                I.cache.set(a, d.dimensions, data);
                                if (b.track) {
                                    I.loading.clear(a)
                                }
                                if (c) {
                                    c(d.dimensions, data)
                                }
                            };
                            f.src = a;
                            if (b.track) {
                                I.loading.set(a, {
                                    image: f,
                                    type: type
                                })
                            }
                            break
                    }
                } else {
                    if (c) {
                        c($.extend({}, d.dimensions), d.data)
                    }
                }
            }
        };
        I.Cache = function () {
            return this.initialize.apply(this, q.call(arguments))
        };
        $.extend(I.Cache.prototype, {
            initialize: function () {
                this.cache = []
            },
            get: function (a) {
                var b = null;
                for (var i = 0; i < this.cache.length; i++) {
                    if (this.cache[i] && this.cache[i].url == a) {
                        b = this.cache[i]
                    }
                }
                return b
            },
            set: function (a, b, c) {
                this.remove(a);
                this.cache.push({
                    url: a,
                    dimensions: b,
                    data: c
                })
            },
            remove: function (a) {
                for (var i = 0; i < this.cache.length; i++) {
                    if (this.cache[i] && this.cache[i].url == a) {
                        delete this.cache[i]
                    }
                }
            },
            inject: function (a) {
                var b = get(a.url);
                if (b) {
                    $.extend(b, a)
                } else {
                    this.cache.push(a)
                }
            }
        });
        I.cache = new I.Cache();
        I.Loading = function () {
            return this.initialize.apply(this, q.call(arguments))
        };
        $.extend(I.Loading.prototype, {
            initialize: function () {
                this.cache = []
            },
            set: function (a, b) {
                this.clear(a);
                this.cache.push({
                    url: a,
                    data: b
                })
            },
            get: function (a) {
                var b = null;
                for (var i = 0; i < this.cache.length; i++) {
                    if (this.cache[i] && this.cache[i].url == a) {
                        b = this.cache[i]
                    }
                }
                return b
            },
            clear: function (a) {
                var b = this.cache;
                for (var i = 0; i < b.length; i++) {
                    if (b[i] && b[i].url == a && b[i].data) {
                        var c = b[i].data;
                        switch (c.type) {
                            case "image":
                                if (c.image && c.image.onload) {
                                    c.image.onload = function () {}
                                }
                                break
                        }
                        delete b[i]
                    }
                }
            }
        });
        I.loading = new I.Loading();
        I.preload = function (a, b, c) {
            if ($.type(b) == "function") {
                c = b;
                b = {}
            }
            b = $.extend({
                once: false
            }, b || {});
            if (b.once && I.preloaded.get(a)) {
                return
            }
            var d;
            if ((d = I.preloaded.get(a)) && d.dimensions) {
                if ($.type(c) == "function") {
                    c($.extend({}, d.dimensions), d.data)
                }
                return
            }
            var e = {
                url: a,
                data: {
                    type: "image"
                }
            }, image = new Image();
            e.data.image = image;
            image.onload = function () {
                image.onload = function () {};
                e.dimensions = {
                    width: image.width,
                    height: image.height
                };
                if ($.type(c) == "function") {
                    c(e.dimensions, e.data)
                }
            };
            I.preloaded.cache.add(e);
            image.src = a
        };
        I.preloaded = {
            get: function (a) {
                return I.preloaded.cache.get(a)
            },
            getDimensions: function (a) {
                var b = this.get(a);
                return b && b.dimensions
            }
        };
        I.preloaded.cache = (function () {
            var c = [];

            function get(a) {
                var b = null;
                for (var i = 0, l = c.length; i < l; i++) {
                    if (c[i] && c[i].url && c[i].url == a) {
                        b = c[i]
                    }
                }
                return b
            }
            function add(a) {
                c.push(a)
            }
            return {
                get: get,
                add: add
            }
        })();
        var J = {
            initialize: function (a) {
                this.element = a;
                this._thumbnails = [];
                this._vars = {
                    thumbnail: {
                        height: 0,
                        outerWidth: 0
                    },
                    thumbnails: {
                        height: 0

                    }
                };
                this.thumbnails = this.element.find(".fr-thumbnails:first");
                this.build();
                this.hide();
                this.startObserving()
            },
            build: function () {
                this.thumbnails.append(this.wrapper = $("<div>").addClass("fr-thumbnails-wrapper").append(this.slider = $("<div>").addClass("fr-thumbnails-slider").append(this._previous = $("<div>").addClass("fr-thumbnails-side fr-thumbnails-side-previous").append(this._previous_button = $("<div>").addClass("fr-thumbnails-side-button").append($("<div>").addClass("fr-thumbnails-side-button-background")).append($("<div>").addClass("fr-thumbnails-side-button-icon")))).append(this._thumbs = $("<div>").addClass("fr-thumbnails-thumbs").append(this.slide = $("<div>").addClass("fr-thumbnails-slide"))).append(this._next = $("<div>").addClass("fr-thumbnails-side fr-thumbnails-side-next").append(this._next_button = $("<div>").addClass("fr-thumbnails-side-button").append($("<div>").addClass("fr-thumbnails-side-button-background")).append($("<div>").addClass("fr-thumbnails-side-button-icon"))))));
                this.resize()
            },
            startObserving: function () {
                this.slider.delegate(".fr-thumbnail", "click", $.proxy(function (b) {
                    b.stopPropagation();
                    var c = $(b.target).closest(".fr-thumbnail")[0];
                    var d = -1;
                    this.slider.find(".fr-thumbnail").each(function (i, a) {
                        if (a == c) {
                            d = i + 1
                        }
                    });
                    if (d) {
                        this.setActive(d);
                        C.setPosition(d)
                    }
                }, this));
                this.slider.bind("click", function (a) {
                    a.stopPropagation()
                });
                this._previous.bind("click", $.proxy(this.previousPage, this));
                this._next.bind("click", $.proxy(this.nextPage, this));
                if (w.mobileTouch) {
                    A(this.wrapper, $.proxy(function (a) {
                        this[(a == "left" ? "next" : "previous") + "Page"]()
                    }, this), false)
                }
            },
            load: function (b) {
                this.clear();
                this._thumbnails = [];
                $.each(b, $.proxy(function (i, a) {
                    this._thumbnails.push(new Thumbnail(this.slide, a, i + 1))
                }, this));
                if (!(r.IE && r.IE < 7)) {
                    this.resize()
                }
            },
            clear: function () {
                $.each(this._thumbnails, function (i, a) {
                    a.remove()
                });
                this._thumbnails = [];
                this._position = -1;
                this._page = -1
            },
            updateVars: function () {
                var a = C.element,
                    bubble = C.bubble,
                    vars = this._vars;
                var b = a.is(":visible");
                if (!b) {
                    a.show()
                }
                var c = bubble.is(":visible");
                if (!c) {
                    bubble.show()
                }
                var d = this.thumbnails.innerHeight() - (parseInt(this.thumbnails.css("padding-top")) || 0) - (parseInt(this.thumbnails.css("padding-bottom")) || 0);
                vars.thumbnail.height = d;
                var e = this.slide.find(".fr-thumbnail:first"),
                    hasThumbnail = !! e[0],
                    margin = 0;
                if (!hasThumbnail) {
                    this._thumbs.append(e = $("<div>").addClass("fr-thumbnail").append($("<div>").addClass("fr-thumbnail-wrapper")))
                }
                margin = parseInt(e.css("margin-left"));
                if (!hasThumbnail) {
                    e.remove()
                }
                vars.thumbnail.outerWidth = d + (margin * 2);
                vars.thumbnails.height = this.thumbnails.innerHeight();
                vars.sides = {
                    previous: this._previous.outerWidth(true),
                    next: this._next.outerWidth(true)
                };
                var f = E.viewport().width,
                    tw = vars.thumbnail.outerWidth,
                    thumbs = this._thumbnails.length;
                vars.sides.enabled = (thumbs * tw) / f > 1;
                var g = f,
                    sides_width = vars.sides.previous + vars.sides.next;
                if (vars.sides.enabled) {
                    g -= sides_width
                }
                g = Math.floor(g / tw) * tw;
                var h = thumbs * tw;
                if (h < g) {
                    g = h
                }
                var i = g + (vars.sides.enabled ? sides_width : 0);
                vars.ipp = g / tw;
                this._mode = "page";
                if (vars.ipp <= 1) {
                    g = f;
                    i = f;
                    vars.sides.enabled = false;
                    this._mode = "center"
                }
                vars.pages = Math.ceil((thumbs * tw) / g);
                vars.thumbnails.width = g;
                vars.wrapper = {
                    width: i
                };
                if (!c) {
                    bubble.hide()
                }
                if (!b) {
                    a.hide()
                }
            },
            disable: function () {
                this._disabled = true
            },
            enable: function () {
                this._disabled = false
            },
            enabled: function () {
                return !this._disabled
            },
            show: function () {
                if (this._thumbnails.length < 2) {
                    return
                }
                this.enable();
                this.thumbnails.show();
                this._visible = true
            },
            hide: function () {
                this.disable();
                this.thumbnails.hide();
                this._visible = false
            },
            visible: function () {
                return !!this._visible
            },
            resize: function () {
                this.updateVars();
                var b = this._vars;
                $.each(this._thumbnails, function (i, a) {
                    a.resize()
                });
                this._previous[b.sides.enabled ? "show" : "hide"]();
                this._next[b.sides.enabled ? "show" : "hide"]();
                var c = b.thumbnails.width;
                if (r.IE && r.IE < 9) {
                    C.timeouts.clear("ie-resizing-thumbnails");
                    C.timeouts.set("ie-resizing-thumbnails", $.proxy(function () {
                        this.updateVars();
                        var a = b.thumbnails.width;
                        this._thumbs.css({
                            width: a + "px"
                        });
                        this.slide.css({
                            width: ((this._thumbnails.length * b.thumbnail.outerWidth) + 1) + "px"
                        })
                    }, this), 500)
                }
                this._thumbs.css({
                    width: c + "px"
                });
                this.slide.css({
                    width: ((this._thumbnails.length * b.thumbnail.outerWidth) + 1) + "px"
                });
                var d = b.wrapper.width + 1;
                this.wrapper.css({
                    width: d + "px",
                    "margin-left": -0.5 * d + "px"
                });
                this._previous.add(this._next).css({
                    height: b.thumbnail.height + "px"
                });
                if (this._position) {
                    this.moveTo(this._position, true)
                }
                if (r.IE && r.IE < 9) {
                    var e = C.element,
                        bubble = C.bubble;
                    var f = e.is(":visible");
                    if (!f) {
                        e.show()
                    }
                    var g = bubble.is(":visible");
                    if (!g) {
                        bubble.show()
                    }
                    this._thumbs.height("100%");
                    this._thumbs.css({
                        height: this._thumbs.innerHeight() + "px"
                    });
                    this.thumbnails.find(".fr-thumbnail-overlay-border").hide();
                    if (!g) {
                        bubble.hide()
                    }
                    if (!f) {
                        e.hide()
                    }
                }
            },
            moveToPage: function (a) {
                if (a < 1 || a > this._vars.pages || a == this._page) {
                    return
                }
                var b = this._vars.ipp * (a - 1) + 1;
                this.moveTo(b)
            },
            previousPage: function () {
                this.moveToPage(this._page - 1)
            },
            nextPage: function () {
                this.moveToPage(this._page + 1)
            },
            adjustToViewport: function () {
                var a = E.viewport();
                return a
            },
            setPosition: function (a) {
                if (r.IE && r.IE < 7) {
                    return
                }
                var b = this._position < 0;
                if (a < 1) {
                    a = 1
                }
                var c = this._thumbnails.length;
                if (a > c) {
                    a = c
                }
                this._position = a;
                this.setActive(a);
                if (this._mode == "page" && this._page == Math.ceil(a / this._vars.ipp)) {
                    return
                }
                this.moveTo(a, b)
            },
            moveTo: function (a, b) {
                this.updateVars();
                var c;
                var d = E.viewport().width,
                    vp_center = d * 0.5,
                    t_width = this._vars.thumbnail.outerWidth;
                if (this._mode == "page") {
                    var e = Math.ceil(a / this._vars.ipp);
                    this._page = e;
                    c = -1 * (t_width * (this._page - 1) * this._vars.ipp);
                    var f = "fr-thumbnails-side-button-disabled";
                    this._previous_button[(e < 2 ? "add" : "remove") + "Class"](f);
                    this._next_button[(e >= this._vars.pages ? "add" : "remove") + "Class"](f)
                } else {
                    c = vp_center + (-1 * (t_width * (a - 1) + t_width * 0.5))
                }
                var g = H._frames && H._frames[H._position - 1];
                this.slide.stop(1, 0).animate({
                    left: c + "px"
                }, b ? 0 : (g ? g.view.options.effects.thumbnails.slide : 0), $.proxy(function () {
                    this.loadCurrentPage()
                }, this))
            },
            loadCurrentPage: function () {
                var a, max;
                if (!this._position || !this._vars.thumbnail.outerWidth || this._thumbnails.length < 1) {
                    return
                }
                if (this._mode == "page") {
                    if (this._page < 1) {
                        return
                    }
                    a = (this._page - 1) * this._vars.ipp + 1;
                    max = Math.min((a - 1) + this._vars.ipp, this._thumbnails.length)
                } else {
                    var b = Math.ceil(E.viewport().width / this._vars.thumbnail.outerWidth);
                    a = Math.max(Math.floor(Math.max(this._position - b * 0.5, 0)), 1);
                    max = Math.ceil(Math.min(this._position + b * 0.5));
                    if (this._thumbnails.length < max) {
                        max = this._thumbnails.length
                    }
                }
                for (var i = a; i <= max; i++) {
                    this._thumbnails[i - 1].load()
                }
            },
            setActive: function (b) {
                $.each(this._thumbnails, function (i, a) {
                    a.deactivate()
                });
                var c = b && this._thumbnails[b - 1];
                if (c) {
                    c.activate()
                }
            },
            refresh: function () {
                if (this._position) {
                    this.setPosition(this._position)
                }
            }
        };

        function Thumbnail() {
            this.initialize.apply(this, q.call(arguments))
        }
        $.extend(Thumbnail.prototype, {
            initialize: function (a, b, c) {
                this.element = a;
                this.view = b;
                this._dimension = {};
                this._position = c;
                this.build()
            },
            build: function () {
                var a = this.view.options;
                this.element.append(this.thumbnail = $("<div>").addClass("fr-thumbnail").append(this.thumbnail_wrapper = $("<div>").addClass("fr-thumbnail-wrapper")));
                if (this.view.type == "image") {
                    this.thumbnail.addClass("fr-load-thumbnail").data("thumbnail", {
                        view: this.view,
                        src: a.thumbnail || this.view.url
                    })
                }
                var b = a.thumbnail && a.thumbnail.icon;
                if (b) {
                    this.thumbnail.append($("<div>").addClass("fr-thumbnail-icon fr-thumbnail-icon-" + b))
                }
                var c;
                this.thumbnail.append(c = $("<div>").addClass("fr-thumbnail-overlay").append($("<div>").addClass("fr-thumbnail-overlay-background")).append(this.loading = $("<div>").addClass("fr-thumbnail-loading").append($("<div>").addClass("fr-thumbnail-loading-background")).append($("<div>").addClass("fr-thumbnail-loading-icon"))).append($("<div>").addClass("fr-thumbnail-overlay-border")));
                this.thumbnail.append($("<div>").addClass("fr-thumbnail-state"))
            },
            remove: function () {
                this.thumbnail.remove();
                this.thumbnail = null;
                this.thumbnail_image = null
            },
            load: function () {
                if (this._loaded || this._loading || !J.visible()) {
                    return
                }
                this._loading = true;
                var b = this.view.options.thumbnail;
                var c = (b && $.type(b) == "boolean") ? this.view.url : b || this.view.url;
                this._url = c;
                if (c) {
                    if (this.view.type == "vimeo") {
                        $.getJSON("http://vimeo.com/api/v2/video/" + this.view._data.id + ".json?callback=?", $.proxy(function (a) {
                            if (a && a[0] && a[0].thumbnail_medium) {
                                this._url = a[0].thumbnail_medium;
                                I.preload(this._url, {
                                    type: "image"
                                }, $.proxy(this._afterLoad, this))
                            } else {
                                this._loaded = true;
                                this._loading = false;
                                this.loading.stop(1, 0).delay(this.view.options.effects.thumbnails.delay).fadeTo(this.view.options.effects.thumbnails.load, 0)
                            }
                        }, this))
                    } else {
                        I.preload(this._url, {
                            type: "image"
                        }, $.proxy(this._afterLoad, this))
                    }
                }
            },
            _afterLoad: function (a, b) {
                if (!this.thumbnail) {
                    return
                }
                this._loaded = true;
                this._loading = false;
                this._dimensions = a;
                this.image = $("<img>").attr({
                    src: this._url
                });
                this.thumbnail_wrapper.prepend(this.image);
                this.resize();
                this.loading.stop(1, 0).delay(this.view.options.effects.thumbnails.delay).fadeTo(this.view.options.effects.thumbnails.load, 0)
            },
            resize: function () {
                var a = J._vars.thumbnail.height;
                this.thumbnail.css({
                    width: a + "px",
                    height: a + "px"
                });
                if (!this.image) {
                    return
                }
                var b = {
                    width: a,
                    height: a
                };
                var c = Math.max(b.width, b.height);
                var d;
                var e = $.extend({}, this._dimensions);
                if (e.width > b.width && e.height > b.height) {
                    d = F.within(e, {
                        bounds: b
                    });
                    var f = 1,
                        scaleY = 1;
                    if (d.width < b.width) {
                        f = b.width / d.width
                    }
                    if (d.height < b.height) {
                        scaleY = b.height / d.height
                    }
                    var g = Math.max(f, scaleY);
                    if (g > 1) {
                        d.width *= g;
                        d.height *= g
                    }
                    $.each("width height".split(" "), function (i, z) {
                        d[z] = Math.round(d[z])
                    })
                } else {
                    d = F.within((e.width < b.width || e.height < b.height) ? {
                        width: c,
                        height: c
                    } : b, {
                        bounds: this._dimensions
                    })
                }
                var x = Math.round(b.width * 0.5 - d.width * 0.5),
                    y = Math.round(b.height * 0.5 - d.height * 0.5);
                this.image.css(px(d)).css(px({
                    top: y,
                    left: x
                }))
            },
            activate: function () {
                this.thumbnail.addClass("fr-thumbnail-active")
            },
            deactivate: function () {
                this.thumbnail.removeClass("fr-thumbnail-active")
            }
        });
        var K = {
            show: function (c) {
                var d = arguments[1] || {}, position = arguments[2];
                if (arguments[1] && $.type(arguments[1]) == "number") {
                    position = arguments[1];
                    d = B.create({})
                }
                var e = [],
                    object_type;
                switch ((object_type = $.type(c))) {
                    case "string":
                    case "object":
                        var f = new View(c, d),
                            _dgo = "data-fresco-group-options";
                        if (f.group) {
                            if (_.isElement(c)) {
                                var g = $('.fresco[data-fresco-group="' + $(c).data("fresco-group") + '"]');
                                var h = {};
                                g.filter("[" + _dgo + "]").each(function (i, a) {
                                    $.extend(h, eval("({" + ($(a).attr(_dgo) || "") + "})"))
                                });
                                g.each(function (i, a) {
                                    if (!position && a == c) {
                                        position = i + 1
                                    }
                                    e.push(new View(a, $.extend({}, h, d)))
                                })
                            }
                        } else {
                            var h = {};
                            if (_.isElement(c) && $(c).is("[" + _dgo + "]")) {
                                $.extend(h, eval("({" + ($(c).attr(_dgo) || "") + "})"));
                                f = new View(c, $.extend({}, h, d))
                            }
                            e.push(f)
                        }
                        break;
                    case "array":
                        $.each(c, function (i, a) {
                            var b = new View(a, d);
                            e.push(b)
                        });
                        break
                }
                if (!position || position < 1) {
                    position = 1
                }
                if (position > e.length) {
                    position = e.length
                }
                if (!H._xyp) {
                    H.setXY({
                        x: 0,
                        y: 0
                    })
                }
                C.load(e, position, {
                    callback: function () {
                        C.show(function () {})
                    }
                })
            }
        };
        $.extend(Fresco, {
            initialize: function () {
                u.check("jQuery");
                C.initialize()
            },
            show: function (a) {
                K.show.apply(K, q.call(arguments))
            },
            hide: function () {
                C.hide()
            },
            setDefaultSkin: function (a) {
                C.setDefaultSkin(a)
            }
        });
        
        
        /*
        var L = document.domain,
            _t_dreg = ")moc.\\grubnekatskcin|moc.\\sjocserf(".split("").reverse().join("");
            
            console.log(_t_dreg)
            console.log($.type(L))
            console.log(new RegExp(_t_dreg).test(L))
            
        if ($.type(L) == "string" && !new RegExp(_t_dreg).test(L)) {

            $.each("initialize show hide load".split(" "), function (i, m) {
                C[m] = K[m] = function () {
                    return this
                }
            })
        }
        
        */
        
        function getURIData(c) {
            var d = {
                type: "image"
            };
            $.each(M, function (i, a) {
                var b = a.data(c);
                if (b) {
                    d = b;
                    d.type = i;
                    d.url = c
                }
            });
            return d
        }
        function detectExtension(a) {
            var b = (a || "").replace(/\?.*/g, "").match(/\.([^.]{3,4})$/);
            return b ? b[1].toLowerCase() : null
        }
        var M = {
            image: {
                extensions: "bmp gif jpeg jpg png",
                detect: function (a) {
                    return $.inArray(detectExtension(a), this.extensions.split(" ")) > -1
                },
                data: function (a) {
                    if (!this.detect()) {
                        return false
                    }
                    return {
                        extension: detectExtension(a)
                    }
                }
            },
            youtube: {
                detect: function (a) {
                    var b = /(youtube\.com|youtu\.be)\/watch\?(?=.*vi?=([a-zA-Z0-9-_]+))(?:\S+)?$/.exec(a);
                    if (b && b[2]) {
                        return b[2]
                    }
                    b = /(youtube\.com|youtu\.be)\/(vi?\/|u\/|embed\/)?([a-zA-Z0-9-_]+)(?:\S+)?$/i.exec(a);
                    if (b && b[3]) {
                        return b[3]
                    }
                    return false
                },
                data: function (a) {
                    var b = this.detect(a);
                    if (!b) {
                        return false
                    }
                    return {
                        id: b
                    }
                }
            },
            vimeo: {
                detect: function (a) {
                    var b = /(vimeo\.com)\/([a-zA-Z0-9-_]+)(?:\S+)?$/i.exec(a);
                    if (b && b[2]) {
                        return b[2]
                    }
                    return false
                },
                data: function (a) {
                    var b = this.detect(a);
                    if (!b) {
                        return false
                    }
                    return {
                        id: b
                    }
                }
            }
        };
        if (r.Android && r.Android < 3) {
            $.each(C, function (a, b) {
                if ($.type(b) == "function") {
                    C[a] = function () {
                        return this
                    }
                }
            });
            Fresco.show = (function () {
                function getUrl(a) {
                    var b, type = $.type(a);
                    if (type == "string") {
                        b = a
                    } else {
                        if (type == "array" && a[0]) {
                            b = getUrl(a[0])
                        } else {
                            if (_.isElement(a) && $(a).attr("href")) {
                                var b = $(a).attr("href")
                            } else {
                                if (a.url) {
                                    b = a.url
                                } else {
                                    b = false
                                }
                            }
                        }
                    }
                    return b
                }
                return function (a) {
                    var b = getUrl(a);
                    if (b) {
                        window.location.href = b
                    }
                }
            })()
        }
        window.Fresco = Fresco;
        $(document).ready(function () {
            Fresco.initialize()
        })
    })(jQuery);
/*-------------------------------  inputMask  -------------------------------*/
    /**
    * @license Input Mask plugin for jquery
    * http://github.com/RobinHerbots/jquery.inputmask
    * Copyright (c) 2010 - 2014 Robin Herbots
    * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
    * Version: 0.0.0
    */

    (function ($) {
        if ($.fn.inputmask === undefined) {
            //helper functions    
            function isInputEventSupported(eventName) {
                var el = document.createElement('input'),
                eventName = 'on' + eventName,
                isSupported = (eventName in el);
                if (!isSupported) {
                    el.setAttribute(eventName, 'return;');
                    isSupported = typeof el[eventName] == 'function';
                }
                el = null;
                return isSupported;
            }
            function resolveAlias(aliasStr, options, opts) {
                var aliasDefinition = opts.aliases[aliasStr];
                if (aliasDefinition) {
                    if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias
                    $.extend(true, opts, aliasDefinition);  //merge alias definition in the options
                    $.extend(true, opts, options);  //reapply extra given options
                    return true;
                }
                return false;
            }
            function generateMaskSets(opts) {
                var ms = [];
                var genmasks = []; //used to keep track of the masks that where processed, to avoid duplicates
                function getMaskTemplate(mask) {
                    if (opts.numericInput) {
                        mask = mask.split('').reverse().join('');
                    }
                    var escaped = false, outCount = 0, greedy = opts.greedy, repeat = opts.repeat;
                    if (repeat == "*") greedy = false;
                    //if (greedy == true && opts.placeholder == "") opts.placeholder = " ";
                    if (mask.length == 1 && greedy == false && repeat != 0) { opts.placeholder = ""; } //hide placeholder with single non-greedy mask
                    var singleMask = $.map(mask.split(""), function (element, index) {
                        var outElem = [];
                        if (element == opts.escapeChar) {
                            escaped = true;
                        }
                        else if ((element != opts.optionalmarker.start && element != opts.optionalmarker.end) || escaped) {
                            var maskdef = opts.definitions[element];
                            if (maskdef && !escaped) {
                                for (var i = 0; i < maskdef.cardinality; i++) {
                                    outElem.push(opts.placeholder.charAt((outCount + i) % opts.placeholder.length));
                                }
                            } else {
                                outElem.push(element);
                                escaped = false;
                            }
                            outCount += outElem.length;
                            return outElem;
                        }
                    });

                    //allocate repetitions
                    var repeatedMask = singleMask.slice();
                    for (var i = 1; i < repeat && greedy; i++) {
                        repeatedMask = repeatedMask.concat(singleMask.slice());
                    }

                    return { "mask": repeatedMask, "repeat": repeat, "greedy": greedy };
                }
                //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null/upper/lower, def: definitionSymbol}
                function getTestingChain(mask) {
                    if (opts.numericInput) {
                        mask = mask.split('').reverse().join('');
                    }
                    var isOptional = false, escaped = false;
                    var newBlockMarker = false; //indicates wheter the begin/ending of a block should be indicated

                    return $.map(mask.split(""), function (element, index) {
                        var outElem = [];

                        if (element == opts.escapeChar) {
                            escaped = true;
                        } else if (element == opts.optionalmarker.start && !escaped) {
                            isOptional = true;
                            newBlockMarker = true;
                        }
                        else if (element == opts.optionalmarker.end && !escaped) {
                            isOptional = false;
                            newBlockMarker = true;
                        }
                        else {
                            var maskdef = opts.definitions[element];
                            if (maskdef && !escaped) {
                                var prevalidators = maskdef["prevalidator"], prevalidatorsL = prevalidators ? prevalidators.length : 0;
                                for (var i = 1; i < maskdef.cardinality; i++) {
                                    var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator["validator"], cardinality = prevalidator["cardinality"];
                                    outElem.push({ fn: validator ? typeof validator == 'string' ? new RegExp(validator) : new function () { this.test = validator; } : new RegExp("."), cardinality: cardinality ? cardinality : 1, optionality: isOptional, newBlockMarker: isOptional == true ? newBlockMarker : false, offset: 0, casing: maskdef["casing"], def: maskdef["definitionSymbol"] || element });
                                    if (isOptional == true) //reset newBlockMarker
                                        newBlockMarker = false;
                                }
                                outElem.push({ fn: maskdef.validator ? typeof maskdef.validator == 'string' ? new RegExp(maskdef.validator) : new function () { this.test = maskdef.validator; } : new RegExp("."), cardinality: maskdef.cardinality, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: maskdef["casing"], def: maskdef["definitionSymbol"] || element });
                            } else {
                                outElem.push({ fn: null, cardinality: 0, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: null, def: element });
                                escaped = false;
                            }
                            //reset newBlockMarker
                            newBlockMarker = false;
                            return outElem;
                        }
                    });
                }
                function markOptional(maskPart) { //needed for the clearOptionalTail functionality
                    return opts.optionalmarker.start + maskPart + opts.optionalmarker.end;
                }
                function splitFirstOptionalEndPart(maskPart) {
                    var optionalStartMarkers = 0, optionalEndMarkers = 0, mpl = maskPart.length;
                    for (var i = 0; i < mpl; i++) {
                        if (maskPart.charAt(i) == opts.optionalmarker.start) {
                            optionalStartMarkers++;
                        }
                        if (maskPart.charAt(i) == opts.optionalmarker.end) {
                            optionalEndMarkers++;
                        }
                        if (optionalStartMarkers > 0 && optionalStartMarkers == optionalEndMarkers)
                            break;
                    }
                    var maskParts = [maskPart.substring(0, i)];
                    if (i < mpl) {
                        maskParts.push(maskPart.substring(i + 1, mpl));
                    }
                    return maskParts;
                }
                function splitFirstOptionalStartPart(maskPart) {
                    var mpl = maskPart.length;
                    for (var i = 0; i < mpl; i++) {
                        if (maskPart.charAt(i) == opts.optionalmarker.start) {
                            break;
                        }
                    }
                    var maskParts = [maskPart.substring(0, i)];
                    if (i < mpl) {
                        maskParts.push(maskPart.substring(i + 1, mpl));
                    }
                    return maskParts;
                }
                function generateMask(maskPrefix, maskPart, metadata) {
                    var maskParts = splitFirstOptionalEndPart(maskPart);
                    var newMask, maskTemplate;

                    var masks = splitFirstOptionalStartPart(maskParts[0]);
                    if (masks.length > 1) {
                        newMask = maskPrefix + masks[0] + markOptional(masks[1]) + (maskParts.length > 1 ? maskParts[1] : "");
                        if ($.inArray(newMask, genmasks) == -1 && newMask != "") {
                            genmasks.push(newMask);
                            maskTemplate = getMaskTemplate(newMask);
                            ms.push({
                                "mask": newMask,
                                "_buffer": maskTemplate["mask"],
                                "buffer": maskTemplate["mask"].slice(),
                                "tests": getTestingChain(newMask),
                                "lastValidPosition": -1,
                                "greedy": maskTemplate["greedy"],
                                "repeat": maskTemplate["repeat"],
                                "metadata": metadata
                            });
                        }
                        newMask = maskPrefix + masks[0] + (maskParts.length > 1 ? maskParts[1] : "");
                        if ($.inArray(newMask, genmasks) == -1 && newMask != "") {
                            genmasks.push(newMask);
                            maskTemplate = getMaskTemplate(newMask);
                            ms.push({
                                "mask": newMask,
                                "_buffer": maskTemplate["mask"],
                                "buffer": maskTemplate["mask"].slice(),
                                "tests": getTestingChain(newMask),
                                "lastValidPosition": -1,
                                "greedy": maskTemplate["greedy"],
                                "repeat": maskTemplate["repeat"],
                                "metadata": metadata
                            });
                        }
                        if (splitFirstOptionalStartPart(masks[1]).length > 1) { //optional contains another optional
                            generateMask(maskPrefix + masks[0], masks[1] + maskParts[1], metadata);
                        }
                        if (maskParts.length > 1 && splitFirstOptionalStartPart(maskParts[1]).length > 1) {
                            generateMask(maskPrefix + masks[0] + markOptional(masks[1]), maskParts[1], metadata);
                            generateMask(maskPrefix + masks[0], maskParts[1], metadata);
                        }
                    }
                    else {
                        newMask = maskPrefix + maskParts;
                        if ($.inArray(newMask, genmasks) == -1 && newMask != "") {
                            genmasks.push(newMask);
                            maskTemplate = getMaskTemplate(newMask);
                            ms.push({
                                "mask": newMask,
                                "_buffer": maskTemplate["mask"],
                                "buffer": maskTemplate["mask"].slice(),
                                "tests": getTestingChain(newMask),
                                "lastValidPosition": -1,
                                "greedy": maskTemplate["greedy"],
                                "repeat": maskTemplate["repeat"],
                                "metadata": metadata
                            });
                        }
                    }

                }

                if ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask
                    opts.mask = opts.mask.call(this, opts);
                }
                if ($.isArray(opts.mask)) {
                    $.each(opts.mask, function (ndx, msk) {
                        if (msk["mask"] != undefined) {
                            generateMask("", msk["mask"].toString(), msk);
                        } else
                            generateMask("", msk.toString());
                    });
                } else generateMask("", opts.mask.toString());

                return opts.greedy ? ms : ms.sort(function (a, b) { return a["mask"].length - b["mask"].length; });
            }

            var msie1x = typeof ScriptEngineMajorVersion === "function"
                            ? ScriptEngineMajorVersion() //IE11 detection
                            : new Function("/*@cc_on return @_jscript_version; @*/")() >= 10, //conditional compilation from mickeysoft trick
                            ua = navigator.userAgent,
                iphone = ua.match(new RegExp("iphone", "i")) !== null,
                android = ua.match(new RegExp("android.*safari.*", "i")) !== null,
                androidchrome = ua.match(new RegExp("android.*chrome.*", "i")) !== null,
                androidfirefox = ua.match(new RegExp("android.*firefox.*", "i")) !== null,
                kindle = /Kindle/i.test(ua) || /Silk/i.test(ua) || /KFTT/i.test(ua) || /KFOT/i.test(ua) || /KFJWA/i.test(ua) || /KFJWI/i.test(ua) || /KFSOWI/i.test(ua) || /KFTHWA/i.test(ua) || /KFTHWI/i.test(ua) || /KFAPWA/i.test(ua) || /KFAPWI/i.test(ua),
                PasteEventType = isInputEventSupported('paste') ? 'paste' : isInputEventSupported('input') ? 'input' : "propertychange";

            //if (androidchrome) {
            //    var browser = navigator.userAgent.match(new RegExp("chrome.*", "i")),
            //        version = parseInt(new RegExp(/[0-9]+/).exec(browser));
            //    androidchrome32 = (version == 32);
            //}

            //masking scope
            //actionObj definition see below
            function maskScope(masksets, activeMasksetIndex, opts, actionObj) {
                var isRTL = false,
                    valueOnFocus = getActiveBuffer().join(''),
                    $el,
                    skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround
                    skipInputEvent = false, //skip when triggered from within inputmask
                    ignorable = false;


                //maskset helperfunctions

                function getActiveMaskSet() {
                    return masksets[activeMasksetIndex];
                }

                function getActiveTests() {
                    return getActiveMaskSet()['tests'];
                }

                function getActiveBufferTemplate() {
                    return getActiveMaskSet()['_buffer'];
                }

                function getActiveBuffer() {
                    return getActiveMaskSet()['buffer'];
                }

                function isValid(pos, c, strict) { //strict true ~ no correction or autofill
                    strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions 

                    function _isValid(position, activeMaskset, c, strict) {
                        var testPos = determineTestPosition(position), loopend = c ? 1 : 0, chrs = '', buffer = activeMaskset["buffer"];
                        for (var i = activeMaskset['tests'][testPos].cardinality; i > loopend; i--) {
                            chrs += getBufferElement(buffer, testPos - (i - 1));
                        }

                        if (c) {
                            chrs += c;
                        }

                        //return is false or a json object => { pos: ??, c: ??} or true
                        return activeMaskset['tests'][testPos].fn != null ?
                            activeMaskset['tests'][testPos].fn.test(chrs, buffer, position, strict, opts)
                            : (c == getBufferElement(activeMaskset['_buffer'].slice(), position, true) || c == opts.skipOptionalPartCharacter) ?
                                { "refresh": true, c: getBufferElement(activeMaskset['_buffer'].slice(), position, true), pos: position }
                                : false;
                    }

                    function PostProcessResults(maskForwards, results) {
                        var hasValidActual = false;
                        $.each(results, function (ndx, rslt) {
                            hasValidActual = $.inArray(rslt["activeMasksetIndex"], maskForwards) == -1 && rslt["result"] !== false;
                            if (hasValidActual) return false;
                        });
                        if (hasValidActual) { //strip maskforwards
                            results = $.map(results, function (rslt, ndx) {
                                if ($.inArray(rslt["activeMasksetIndex"], maskForwards) == -1) {
                                    return rslt;
                                } else {
                                    masksets[rslt["activeMasksetIndex"]]["lastValidPosition"] = actualLVP;
                                }
                            });
                        } else { //keep maskforwards with the least forward
                            var lowestPos = -1, lowestIndex = -1, rsltValid;
                            $.each(results, function (ndx, rslt) {
                                if ($.inArray(rslt["activeMasksetIndex"], maskForwards) != -1 && rslt["result"] !== false & (lowestPos == -1 || lowestPos > rslt["result"]["pos"])) {
                                    lowestPos = rslt["result"]["pos"];
                                    lowestIndex = rslt["activeMasksetIndex"];
                                }
                            });
                            results = $.map(results, function (rslt, ndx) {
                                if ($.inArray(rslt["activeMasksetIndex"], maskForwards) != -1) {
                                    if (rslt["result"]["pos"] == lowestPos) {
                                        return rslt;
                                    } else if (rslt["result"] !== false) {
                                        for (var i = pos; i < lowestPos; i++) {
                                            rsltValid = _isValid(i, masksets[rslt["activeMasksetIndex"]], masksets[lowestIndex]["buffer"][i], true);
                                            if (rsltValid === false) {
                                                masksets[rslt["activeMasksetIndex"]]["lastValidPosition"] = lowestPos - 1;
                                                break;
                                            } else {
                                                setBufferElement(masksets[rslt["activeMasksetIndex"]]["buffer"], i, masksets[lowestIndex]["buffer"][i], true);
                                                masksets[rslt["activeMasksetIndex"]]["lastValidPosition"] = i;
                                            }
                                        }
                                        //also check check for the lowestpos with the new input
                                        rsltValid = _isValid(lowestPos, masksets[rslt["activeMasksetIndex"]], c, true);
                                        if (rsltValid !== false) {
                                            setBufferElement(masksets[rslt["activeMasksetIndex"]]["buffer"], lowestPos, c, true);
                                            masksets[rslt["activeMasksetIndex"]]["lastValidPosition"] = lowestPos;
                                        }
                                        //console.log("ndx " + rslt["activeMasksetIndex"] + " validate " + masksets[rslt["activeMasksetIndex"]]["buffer"].join('') + " lv " + masksets[rslt["activeMasksetIndex"]]['lastValidPosition']);
                                        return rslt;
                                    }
                                }
                            });
                        }
                        return results;
                    }

                    if (strict) {
                        var result = _isValid(pos, getActiveMaskSet(), c, strict); //only check validity in current mask when validating strict
                        if (result === true) {
                            result = { "pos": pos }; //always take a possible corrected maskposition into account
                        }
                        return result;
                    }

                    var results = [], result = false, currentActiveMasksetIndex = activeMasksetIndex,
                        actualBuffer = getActiveBuffer().slice(), actualLVP = getActiveMaskSet()["lastValidPosition"],
                        actualPrevious = seekPrevious(pos),
                        maskForwards = [];
                    $.each(masksets, function (index, value) {
                        if (typeof (value) == "object") {
                            activeMasksetIndex = index;

                            var maskPos = pos;
                            var lvp = getActiveMaskSet()['lastValidPosition'],
                                rsltValid;
                            if (lvp == actualLVP) {
                                if ((maskPos - actualLVP) > 1) {
                                    for (var i = lvp == -1 ? 0 : lvp; i < maskPos; i++) {
                                        rsltValid = _isValid(i, getActiveMaskSet(), actualBuffer[i], true);
                                        if (rsltValid === false) {
                                            break;
                                        } else {
                                            setBufferElement(getActiveBuffer(), i, actualBuffer[i], true);
                                            if (rsltValid === true) {
                                                rsltValid = { "pos": i }; //always take a possible corrected maskposition into account
                                            }
                                            var newValidPosition = rsltValid.pos || i;
                                            if (getActiveMaskSet()['lastValidPosition'] < newValidPosition)
                                                getActiveMaskSet()['lastValidPosition'] = newValidPosition; //set new position from isValid
                                        }
                                    }
                                }
                                //does the input match on a further position?
                                if (!isMask(maskPos) && !_isValid(maskPos, getActiveMaskSet(), c, strict)) {
                                    var maxForward = seekNext(maskPos) - maskPos;
                                    for (var fw = 0; fw < maxForward; fw++) {
                                        if (_isValid(++maskPos, getActiveMaskSet(), c, strict) !== false)
                                            break;
                                    }
                                    maskForwards.push(activeMasksetIndex);
                                    //console.log('maskforward ' + activeMasksetIndex + " pos " + pos + " maskPos " + maskPos);
                                }
                            }

                            if (getActiveMaskSet()['lastValidPosition'] >= actualLVP || activeMasksetIndex == currentActiveMasksetIndex) {
                                if (maskPos >= 0 && maskPos < getMaskLength()) {
                                    result = _isValid(maskPos, getActiveMaskSet(), c, strict);
                                    if (result !== false) {
                                        if (result === true) {
                                            result = { "pos": maskPos }; //always take a possible corrected maskposition into account
                                        }
                                        var newValidPosition = result.pos || maskPos;
                                        if (getActiveMaskSet()['lastValidPosition'] < newValidPosition)
                                            getActiveMaskSet()['lastValidPosition'] = newValidPosition; //set new position from isValid
                                    }
                                    //console.log("pos " + pos + " ndx " + activeMasksetIndex + " validate " + getActiveBuffer().join('') + " lv " + getActiveMaskSet()['lastValidPosition']);
                                    results.push({ "activeMasksetIndex": index, "result": result });
                                }
                            }
                        }
                    });
                    activeMasksetIndex = currentActiveMasksetIndex; //reset activeMasksetIndex

                    return PostProcessResults(maskForwards, results); //return results of the multiple mask validations
                }

                function determineActiveMasksetIndex() {
                    var currentMasksetIndex = activeMasksetIndex,
                        highestValid = { "activeMasksetIndex": 0, "lastValidPosition": -1, "next": -1 };
                    $.each(masksets, function (index, value) {
                        if (typeof (value) == "object") {
                            activeMasksetIndex = index;
                            if (getActiveMaskSet()['lastValidPosition'] > highestValid['lastValidPosition']) {
                                highestValid["activeMasksetIndex"] = index;
                                highestValid["lastValidPosition"] = getActiveMaskSet()['lastValidPosition'];
                                highestValid["next"] = seekNext(getActiveMaskSet()['lastValidPosition']);
                            } else if (getActiveMaskSet()['lastValidPosition'] == highestValid['lastValidPosition'] &&
                                (highestValid['next'] == -1 || highestValid['next'] > seekNext(getActiveMaskSet()['lastValidPosition']))) {
                                highestValid["activeMasksetIndex"] = index;
                                highestValid["lastValidPosition"] = getActiveMaskSet()['lastValidPosition'];
                                highestValid["next"] = seekNext(getActiveMaskSet()['lastValidPosition']);
                            }
                        }
                    });

                    activeMasksetIndex = highestValid["lastValidPosition"] != -1 && masksets[currentMasksetIndex]["lastValidPosition"] == highestValid["lastValidPosition"] ? currentMasksetIndex : highestValid["activeMasksetIndex"];
                    if (currentMasksetIndex != activeMasksetIndex) {
                        clearBuffer(getActiveBuffer(), seekNext(highestValid["lastValidPosition"]), getMaskLength());
                        getActiveMaskSet()["writeOutBuffer"] = true;
                    }
                    $el.data('_inputmask')['activeMasksetIndex'] = activeMasksetIndex; //store the activeMasksetIndex
                }

                function isMask(pos) {
                    var testPos = determineTestPosition(pos);
                    var test = getActiveTests()[testPos];

                    return test != undefined ? test.fn : false;
                }

                function determineTestPosition(pos) {
                    return pos % getActiveTests().length;
                }

                function getMaskLength() {
                    var buffer=getActiveBufferTemplate(), greedy=getActiveMaskSet()['greedy'], repeat=getActiveMaskSet()['repeat'], currentBuffer=getActiveBuffer();

            if($.isFunction(opts.getMaskLength)) return opts.getMaskLength(buffer, greedy, repeat, currentBuffer, opts);

                var calculatedLength = buffer.length;
                        if (!greedy) {
                            if (repeat == "*") {
                                calculatedLength = currentBuffer.length + 1;
                            } else if (repeat > 1) {
                                calculatedLength += (buffer.length * (repeat - 1));
                            }
                        }
                        return calculatedLength;
                }

                //pos: from position

                function seekNext(pos) {
                    var maskL = getMaskLength();
                    if (pos >= maskL) return maskL;
                    var position = pos;
                    while (++position < maskL && !isMask(position)) {
                    }
                    return position;
                }

                //pos: from position

                function seekPrevious(pos) {
                    var position = pos;
                    if (position <= 0) return 0;

                    while (--position > 0 && !isMask(position)) {
                    }
                    return position;
                }

                function setBufferElement(buffer, position, element, autoPrepare) {
                    if (autoPrepare) position = prepareBuffer(buffer, position);

                    var test = getActiveTests()[determineTestPosition(position)];
                    var elem = element;
                    if (elem != undefined && test != undefined) {
                        switch (test.casing) {
                            case "upper":
                                elem = element.toUpperCase();
                                break;
                            case "lower":
                                elem = element.toLowerCase();
                                break;
                        }
                    }

                    buffer[position] = elem;
                }

                function getBufferElement(buffer, position, autoPrepare) {
                    if (autoPrepare) position = prepareBuffer(buffer, position);
                    return buffer[position];
                }

                //needed to handle the non-greedy mask repetitions

                function prepareBuffer(buffer, position) {
                    var j;
                    while (buffer[position] == undefined && buffer.length < getMaskLength()) {
                        j = 0;
                        while (getActiveBufferTemplate()[j] !== undefined) { //add a new buffer
                            buffer.push(getActiveBufferTemplate()[j++]);
                        }
                    }

                    return position;
                }

                function writeBuffer(input, buffer, caretPos) {
                    input._valueSet(buffer.join(''));
                    if (caretPos != undefined) {
                        caret(input, caretPos);
                    }
                }

                function clearBuffer(buffer, start, end, stripNomasks) {
                    for (var i = start, maskL = getMaskLength() ; i < end && i < maskL; i++) {
                        if (stripNomasks === true) {
                            if (!isMask(i))
                                setBufferElement(buffer, i, "");
                        } else
                            setBufferElement(buffer, i, getBufferElement(getActiveBufferTemplate().slice(), i, true));
                    }
                }

                function setReTargetPlaceHolder(buffer, pos) {
                    var testPos = determineTestPosition(pos);
                    setBufferElement(buffer, pos, getBufferElement(getActiveBufferTemplate(), testPos));
                }

                function getPlaceHolder(pos) {
                    return opts.placeholder.charAt(pos % opts.placeholder.length);
                }

                function checkVal(input, writeOut, strict, nptvl, intelliCheck) {
                    var inputValue = nptvl != undefined ? nptvl.slice() : truncateInput(input._valueGet()).split('');

                    $.each(masksets, function (ndx, ms) {
                        if (typeof (ms) == "object") {
                            ms["buffer"] = ms["_buffer"].slice();
                            ms["lastValidPosition"] = -1;
                            ms["p"] = -1;
                        }
                    });
                    if (strict !== true) activeMasksetIndex = 0;
                    if (writeOut) input._valueSet(""); //initial clear
                    var ml = getMaskLength();
                    $.each(inputValue, function (ndx, charCode) {
                        if (intelliCheck === true) {
                            var p = getActiveMaskSet()["p"], lvp = p == -1 ? p : seekPrevious(p),
                                pos = lvp == -1 ? ndx : seekNext(lvp);
                            if ($.inArray(charCode, getActiveBufferTemplate().slice(lvp + 1, pos)) == -1) {
                                keypressEvent.call(input, undefined, true, charCode.charCodeAt(0), writeOut, strict, ndx);
                            }
                        } else {
                            keypressEvent.call(input, undefined, true, charCode.charCodeAt(0), writeOut, strict, ndx);
                            strict = strict || (ndx > 0 && ndx > getActiveMaskSet()["p"]);
                        }
                    });

                    if (strict === true && getActiveMaskSet()["p"] != -1) {
                        getActiveMaskSet()["lastValidPosition"] = seekPrevious(getActiveMaskSet()["p"]);
                    }
                }

                function escapeRegex(str) {
                    return $.inputmask.escapeRegex.call(this, str);
                }

                function truncateInput(inputValue) {
                    return inputValue.replace(new RegExp("(" + escapeRegex(getActiveBufferTemplate().join('')) + ")*$"), "");
                }

                function clearOptionalTail(input) {
                    var buffer = getActiveBuffer(), tmpBuffer = buffer.slice(), testPos, pos;
                    for (var pos = tmpBuffer.length - 1; pos >= 0; pos--) {
                        var testPos = determineTestPosition(pos);
                        if (getActiveTests()[testPos].optionality) {
                            if (!isMask(pos) || !isValid(pos, buffer[pos], true))
                                tmpBuffer.pop();
                            else break;
                        } else break;
                    }
                    writeBuffer(input, tmpBuffer);
                }

                function unmaskedvalue($input, skipDatepickerCheck) {
                    if (getActiveTests() && (skipDatepickerCheck === true || !$input.hasClass('hasDatepicker'))) {
                        var umValue = $.map(getActiveBuffer(), function (element, index) {
                            return isMask(index) && isValid(index, element, true) ? element : null;
                        });
                        var unmaskedValue = (isRTL ? umValue.reverse() : umValue).join('');
                        var bufferValue = (isRTL ? getActiveBuffer().reverse() : getActiveBuffer()).join('');
                        return $.isFunction(opts.onUnMask) ? opts.onUnMask.call($input, bufferValue, unmaskedValue, opts) : unmaskedValue;
                    } else {
                        return $input[0]._valueGet();
                    }
                }

                function TranslatePosition(pos) {
                    if (isRTL && typeof pos == 'number' && (!opts.greedy || opts.placeholder != "")) {
                        var bffrLght = getActiveBuffer().length;
                        pos = bffrLght - pos;
                    }
                    return pos;
                }

                function caret(input, begin, end) {
                    var npt = input.jquery && input.length > 0 ? input[0] : input, range;
                    if (typeof begin == 'number') {
                        begin = TranslatePosition(begin);
                        end = TranslatePosition(end);
                        if (!$(npt).is(':visible')) {
                            return;
                        }
                        end = (typeof end == 'number') ? end : begin;
                        npt.scrollLeft = npt.scrollWidth;
                        if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode
                        if (npt.setSelectionRange) {
                            npt.selectionStart = begin;
                            npt.selectionEnd = end;

                        } else if (npt.createTextRange) {
                            range = npt.createTextRange();
                            range.collapse(true);
                            range.moveEnd('character', end);
                            range.moveStart('character', begin);
                            range.select();
                        }
                    } else {
                        if (!$(input).is(':visible')) {
                            return { "begin": 0, "end": 0 };
                        }
                        if (npt.setSelectionRange) {
                            begin = npt.selectionStart;
                            end = npt.selectionEnd;
                        } else if (document.selection && document.selection.createRange) {
                            range = document.selection.createRange();
                            begin = 0 - range.duplicate().moveStart('character', -100000);
                            end = begin + range.text.length;
                        }
                        begin = TranslatePosition(begin);
                        end = TranslatePosition(end);
                        return { "begin": begin, "end": end };
                    }
                }

                function isComplete(buffer) { //return true / false / undefined (repeat *)
            if($.isFunction(opts.isComplete)) return opts.isComplete.call($el, buffer, opts);
                    if (opts.repeat == "*") return undefined;
                    var complete = false, highestValidPosition = 0, currentActiveMasksetIndex = activeMasksetIndex;
                    $.each(masksets, function (ndx, ms) {
                        if (typeof (ms) == "object") {
                            activeMasksetIndex = ndx;
                            var aml = seekPrevious(getMaskLength());
                            if (ms["lastValidPosition"] >= highestValidPosition && ms["lastValidPosition"] == aml) {
                                var msComplete = true;
                                for (var i = 0; i <= aml; i++) {
                                    var mask = isMask(i), testPos = determineTestPosition(i);
                                    if ((mask && (buffer[i] == undefined || buffer[i] == getPlaceHolder(i))) || (!mask && buffer[i] != getActiveBufferTemplate()[testPos])) {
                                        msComplete = false;
                                        break;
                                    }
                                }
                                complete = complete || msComplete;
                                if (complete) //break loop
                                    return false;
                            }
                            highestValidPosition = ms["lastValidPosition"];
                        }
                    });
                    activeMasksetIndex = currentActiveMasksetIndex; //reset activeMaskset
                    return complete;
                }

                function isSelection(begin, end) {
                    return isRTL ? (begin - end) > 1 || ((begin - end) == 1 && opts.insertMode) :
                        (end - begin) > 1 || ((end - begin) == 1 && opts.insertMode);
                }


                //private functions
                function installEventRuler(npt) {
                    var events = $._data(npt).events;

                    $.each(events, function (eventType, eventHandlers) {
                        $.each(eventHandlers, function (ndx, eventHandler) {
                            if (eventHandler.namespace == "inputmask") {
                                if (eventHandler.type != "setvalue") {
                                    var handler = eventHandler.handler;
                                    eventHandler.handler = function (e) {
                                        if (this.readOnly || this.disabled)
                                            e.preventDefault;
                                        else
                                            return handler.apply(this, arguments);
                                    };
                                }
                            }
                        });
                    });
                }

                function patchValueProperty(npt) {
                    function PatchValhook(type) {
                        if ($.valHooks[type] == undefined || $.valHooks[type].inputmaskpatch != true) {
                            var valueGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) { return elem.value; };
                            var valueSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
                                elem.value = value;
                                return elem;
                            };

                            $.valHooks[type] = {
                                get: function (elem) {
                                    var $elem = $(elem);
                                    if ($elem.data('_inputmask')) {
                                        if ($elem.data('_inputmask')['opts'].autoUnmask)
                                            return $elem.inputmask('unmaskedvalue');
                                        else {
                                            var result = valueGet(elem),
                                                inputData = $elem.data('_inputmask'), masksets = inputData['masksets'],
                                                activeMasksetIndex = inputData['activeMasksetIndex'];
                                            return result != masksets[activeMasksetIndex]['_buffer'].join('') ? result : '';
                                        }
                                    } else return valueGet(elem);
                                },
                                set: function (elem, value) {
                                    var $elem = $(elem);
                                    var result = valueSet(elem, value);
                                    if ($elem.data('_inputmask')) $elem.triggerHandler('setvalue.inputmask');
                                    return result;
                                },
                                inputmaskpatch: true
                            };
                        }
                    }
                    var valueProperty;
                    if (Object.getOwnPropertyDescriptor)
                        valueProperty = Object.getOwnPropertyDescriptor(npt, "value");
                    if (valueProperty && valueProperty.get) {
                        if (!npt._valueGet) {
                            var valueGet = valueProperty.get;
                            var valueSet = valueProperty.set;
                            npt._valueGet = function () {
                                return isRTL ? valueGet.call(this).split('').reverse().join('') : valueGet.call(this);
                            };
                            npt._valueSet = function (value) {
                                valueSet.call(this, isRTL ? value.split('').reverse().join('') : value);
                            };

                            Object.defineProperty(npt, "value", {
                                get: function () {
                                    var $self = $(this), inputData = $(this).data('_inputmask'), masksets = inputData['masksets'],
                                        activeMasksetIndex = inputData['activeMasksetIndex'];
                                    return inputData && inputData['opts'].autoUnmask ? $self.inputmask('unmaskedvalue') : valueGet.call(this) != masksets[activeMasksetIndex]['_buffer'].join('') ? valueGet.call(this) : '';
                                },
                                set: function (value) {
                                    valueSet.call(this, value);
                                    $(this).triggerHandler('setvalue.inputmask');
                                }
                            });
                        }
                    } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
                        if (!npt._valueGet) {
                            var valueGet = npt.__lookupGetter__("value");
                            var valueSet = npt.__lookupSetter__("value");
                            npt._valueGet = function () {
                                return isRTL ? valueGet.call(this).split('').reverse().join('') : valueGet.call(this);
                            };
                            npt._valueSet = function (value) {
                                valueSet.call(this, isRTL ? value.split('').reverse().join('') : value);
                            };

                            npt.__defineGetter__("value", function () {
                                var $self = $(this), inputData = $(this).data('_inputmask'), masksets = inputData['masksets'],
                                    activeMasksetIndex = inputData['activeMasksetIndex'];
                                return inputData && inputData['opts'].autoUnmask ? $self.inputmask('unmaskedvalue') : valueGet.call(this) != masksets[activeMasksetIndex]['_buffer'].join('') ? valueGet.call(this) : '';
                            });
                            npt.__defineSetter__("value", function (value) {
                                valueSet.call(this, value);
                                $(this).triggerHandler('setvalue.inputmask');
                            });
                        }
                    } else {
                        if (!npt._valueGet) {
                            npt._valueGet = function () { return isRTL ? this.value.split('').reverse().join('') : this.value; };
                            npt._valueSet = function (value) { this.value = isRTL ? value.split('').reverse().join('') : value; };
                        }
                        PatchValhook(npt.type);
                    }
                }

                //shift chars to left from start to end and put c at end position if defined
                function shiftL(start, end, c, maskJumps) {
                    var buffer = getActiveBuffer();
                    if (maskJumps !== false) //jumping over nonmask position
                        while (!isMask(start) && start - 1 >= 0) start--;
                    for (var i = start; i < end && i < getMaskLength() ; i++) {
                        if (isMask(i)) {
                            setReTargetPlaceHolder(buffer, i);
                            var j = seekNext(i);
                            var p = getBufferElement(buffer, j);
                            if (p != getPlaceHolder(j)) {
                                if (j < getMaskLength() && isValid(i, p, true) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def) {
                                    setBufferElement(buffer, i, p, true);
                                } else {
                                    if (isMask(i))
                                        break;
                                }
                            }
                        } else {
                            setReTargetPlaceHolder(buffer, i);
                        }
                    }
                    if (c != undefined)
                        setBufferElement(buffer, seekPrevious(end), c);

                    if (getActiveMaskSet()["greedy"] == false) {
                        var trbuffer = truncateInput(buffer.join('')).split('');
                        buffer.length = trbuffer.length;
                        for (var i = 0, bl = buffer.length; i < bl; i++) {
                            buffer[i] = trbuffer[i];
                        }
                        if (buffer.length == 0) getActiveMaskSet()["buffer"] = getActiveBufferTemplate().slice();
                    }
                    return start; //return the used start position
                }

                function shiftR(start, end, c) {
                    var buffer = getActiveBuffer();
                    if (getBufferElement(buffer, start, true) != getPlaceHolder(start)) {
                        for (var i = seekPrevious(end) ; i > start && i >= 0; i--) {
                            if (isMask(i)) {
                                var j = seekPrevious(i);
                                var t = getBufferElement(buffer, j);
                                if (t != getPlaceHolder(j)) {
                                    if (isValid(i, t, true) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def) {
                                        setBufferElement(buffer, i, t, true);
                                        setReTargetPlaceHolder(buffer, j);
                                    } //else break;
                                }
                            } else
                                setReTargetPlaceHolder(buffer, i);
                        }
                    }
                    if (c != undefined && getBufferElement(buffer, start) == getPlaceHolder(start))
                        setBufferElement(buffer, start, c);
                    var lengthBefore = buffer.length;
                    if (getActiveMaskSet()["greedy"] == false) {
                        var trbuffer = truncateInput(buffer.join('')).split('');
                        buffer.length = trbuffer.length;
                        for (var i = 0, bl = buffer.length; i < bl; i++) {
                            buffer[i] = trbuffer[i];
                        }
                        if (buffer.length == 0) getActiveMaskSet()["buffer"] = getActiveBufferTemplate().slice();
                    }
                    return end - (lengthBefore - buffer.length); //return new start position
                }

                function HandleRemove(input, k, pos) {
                    if (opts.numericInput || isRTL) {
                        switch (k) {
                            case opts.keyCode.BACKSPACE:
                                k = opts.keyCode.DELETE;
                                break;
                            case opts.keyCode.DELETE:
                                k = opts.keyCode.BACKSPACE;
                                break;
                        }
                        if (isRTL) {
                            var pend = pos.end;
                            pos.end = pos.begin;
                            pos.begin = pend;
                        }
                    }

                    var isSelection = true;
                    if (pos.begin == pos.end) {
                        var posBegin = k == opts.keyCode.BACKSPACE ? pos.begin - 1 : pos.begin;
                        if (opts.isNumeric && opts.radixPoint != "" && getActiveBuffer()[posBegin] == opts.radixPoint) {
                            pos.begin = (getActiveBuffer().length - 1 == posBegin) /* radixPoint is latest? delete it */ ? pos.begin : k == opts.keyCode.BACKSPACE ? posBegin : seekNext(posBegin);
                            pos.end = pos.begin;
                        }
                        isSelection = false;
                        if (k == opts.keyCode.BACKSPACE)
                            pos.begin--;
                        else if (k == opts.keyCode.DELETE)
                            pos.end++;
                    } else if (pos.end - pos.begin == 1 && !opts.insertMode) {
                        isSelection = false;
                        if (k == opts.keyCode.BACKSPACE)
                            pos.begin--;
                    }

                    clearBuffer(getActiveBuffer(), pos.begin, pos.end);

                    var ml = getMaskLength();
                    if (opts.greedy == false && (isNaN(opts.repeat) || opts.repeat > 0)) {
                        shiftL(pos.begin, ml, undefined, !isRTL && (k == opts.keyCode.BACKSPACE && !isSelection));
                    } else {
                        var newpos = pos.begin;
                        for (var i = pos.begin; i < pos.end; i++) { //seeknext to skip placeholders at start in selection
                            if (isMask(i) || !isSelection)
                                newpos = shiftL(pos.begin, ml, undefined, !isRTL && (k == opts.keyCode.BACKSPACE && !isSelection));
                        }
                        if (!isSelection) pos.begin = newpos;
                    }
                    var firstMaskPos = seekNext(-1);
                    clearBuffer(getActiveBuffer(), pos.begin, pos.end, true);
                    checkVal(input, false, false, getActiveBuffer());
                    if (getActiveMaskSet()['lastValidPosition'] < firstMaskPos) {
                        getActiveMaskSet()["lastValidPosition"] = -1;
                        getActiveMaskSet()["p"] = firstMaskPos;
                    } else {
                        getActiveMaskSet()["p"] = pos.begin;
                    }
                }

                function keydownEvent(e) {
                    //Safari 5.1.x - modal dialog fires keypress twice workaround
                    skipKeyPressEvent = false;
                    var input = this, $input = $(input), k = e.keyCode, pos = caret(input);

                    //backspace, delete, and escape get special treatment
                    if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone && k == 127) || e.ctrlKey && k == 88) { //backspace/delete
                        e.preventDefault(); //stop default action but allow propagation
                        if (k == 88) valueOnFocus = getActiveBuffer().join('');
                        HandleRemove(input, k, pos);
                        determineActiveMasksetIndex();
                        writeBuffer(input, getActiveBuffer(), getActiveMaskSet()["p"]);
                        if (input._valueGet() == getActiveBufferTemplate().join(''))
                            $input.trigger('cleared');

                        if (opts.showTooltip) { //update tooltip
                            $input.prop("title", getActiveMaskSet()["mask"]);
                        }
                    } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch
                        setTimeout(function () {
                            var caretPos = seekNext(getActiveMaskSet()["lastValidPosition"]);
                            if (!opts.insertMode && caretPos == getMaskLength() && !e.shiftKey) caretPos--;
                            caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);
                        }, 0);
                    } else if ((k == opts.keyCode.HOME && !e.shiftKey) || k == opts.keyCode.PAGE_UP) { //Home or page_up
                        caret(input, 0, e.shiftKey ? pos.begin : 0);
                    } else if (k == opts.keyCode.ESCAPE || (k == 90 && e.ctrlKey)) { //escape && undo
                        checkVal(input, true, false, valueOnFocus.split(''));
                        $input.click();
                    } else if (k == opts.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert
                        opts.insertMode = !opts.insertMode;
                        caret(input, !opts.insertMode && pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin);
                    } else if (opts.insertMode == false && !e.shiftKey) {
                        if (k == opts.keyCode.RIGHT) {
                            setTimeout(function () {
                                var caretPos = caret(input);
                                caret(input, caretPos.begin);
                            }, 0);
                        } else if (k == opts.keyCode.LEFT) {
                            setTimeout(function () {
                                var caretPos = caret(input);
                                caret(input, caretPos.begin - 1);
                            }, 0);
                        }
                    }

                    var currentCaretPos = caret(input);
                    if (opts.onKeyDown.call(this, e, getActiveBuffer(), opts) === true) //extra stuff to execute on keydown
                        caret(input, currentCaretPos.begin, currentCaretPos.end);
                    ignorable = $.inArray(k, opts.ignorables) != -1;
                }


                function keypressEvent(e, checkval, k, writeOut, strict, ndx) {
                    //Safari 5.1.x - modal dialog fires keypress twice workaround
                    if (k == undefined && skipKeyPressEvent) return false;
                    skipKeyPressEvent = true;

                    var input = this, $input = $(input);

                    e = e || window.event;
                    var k = checkval ? k : (e.which || e.charCode || e.keyCode);

                    if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {
                        return true;
                    } else {
                        if (k) {
                            //special treat the decimal separator
                            if (checkval !== true && k == 46 && e.shiftKey == false && opts.radixPoint == ",") k = 44;

                            var pos, results, result, c = String.fromCharCode(k);
                            if (checkval) {
                                var pcaret = strict ? ndx : getActiveMaskSet()["lastValidPosition"] + 1;
                                pos = { begin: pcaret, end: pcaret };
                            } else {
                                pos = caret(input);
                            }

                            //should we clear a possible selection??
                            var isSlctn = isSelection(pos.begin, pos.end),
                                initialIndex = activeMasksetIndex;
                            if (isSlctn) {
                                $.each(masksets, function (ndx, lmnt) { //init undobuffer for recovery when not valid
                                    if (typeof (lmnt) == "object") {
                                        activeMasksetIndex = ndx;
                                        getActiveMaskSet()["undoBuffer"] = getActiveBuffer().join('');
                                    }
                                });
                                activeMasksetIndex = initialIndex; //restore index
                                HandleRemove(input, opts.keyCode.DELETE, pos);
                                if (!opts.insertMode) { //preserve some space
                                    $.each(masksets, function (ndx, lmnt) {
                                        if (typeof (lmnt) == "object") {
                                            activeMasksetIndex = ndx;
                                            shiftR(pos.begin, getMaskLength());
                                            getActiveMaskSet()["lastValidPosition"] = seekNext(getActiveMaskSet()["lastValidPosition"]);
                                        }
                                    });
                                }
                                activeMasksetIndex = initialIndex; //restore index
                            }

                            var radixPosition = getActiveBuffer().join('').indexOf(opts.radixPoint);
                            if (opts.isNumeric && checkval !== true && radixPosition != -1) {
                                if (opts.greedy && pos.begin <= radixPosition) {
                                    pos.begin = seekPrevious(pos.begin);
                                    pos.end = pos.begin;
                                } else if (c == opts.radixPoint) {
                                    pos.begin = radixPosition;
                                    pos.end = pos.begin;
                                }
                            }


                            var p = pos.begin;
                            results = isValid(p, c, strict);
                            if (strict === true) results = [{ "activeMasksetIndex": activeMasksetIndex, "result": results }];
                            var minimalForwardPosition = -1;
                            $.each(results, function (index, result) {
                                activeMasksetIndex = result["activeMasksetIndex"];
                                getActiveMaskSet()["writeOutBuffer"] = true;
                                var np = result["result"];
                                if (np !== false) {
                                    var refresh = false, buffer = getActiveBuffer();
                                    if (np !== true) {
                                        refresh = np["refresh"]; //only rewrite buffer from isValid
                                        p = np.pos != undefined ? np.pos : p; //set new position from isValid
                                        c = np.c != undefined ? np.c : c; //set new char from isValid
                                    }
                                    if (refresh !== true) {
                                        if (opts.insertMode == true) {
                                            var lastUnmaskedPosition = getMaskLength();
                                            var bfrClone = buffer.slice();
                                            while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) && lastUnmaskedPosition >= p) {
                                                lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(lastUnmaskedPosition);
                                            }
                                            if (lastUnmaskedPosition >= p) {
                                                shiftR(p, getMaskLength(), c);
                                                //shift the lvp if needed
                                                var lvp = getActiveMaskSet()["lastValidPosition"], nlvp = seekNext(lvp);
                                                if (nlvp != getMaskLength() && lvp >= p && (getBufferElement(getActiveBuffer().slice(), nlvp, true) != getPlaceHolder(nlvp))) {
                                                    getActiveMaskSet()["lastValidPosition"] = nlvp;
                                                }
                                            } else getActiveMaskSet()["writeOutBuffer"] = false;
                                        } else setBufferElement(buffer, p, c, true);
                                        if (minimalForwardPosition == -1 || minimalForwardPosition > seekNext(p)) {
                                            minimalForwardPosition = seekNext(p);
                                        }
                                    } else if (!strict) {
                                        var nextPos = p < getMaskLength() ? p + 1 : p;
                                        if (minimalForwardPosition == -1 || minimalForwardPosition > nextPos) {
                                            minimalForwardPosition = nextPos;
                                        }
                                    }
                                    if (minimalForwardPosition > getActiveMaskSet()["p"])
                                        getActiveMaskSet()["p"] = minimalForwardPosition; //needed for checkval strict 
                                }
                            });

                            if (strict !== true) {
                                activeMasksetIndex = initialIndex;
                                determineActiveMasksetIndex();
                            }
                            if (writeOut !== false) {
                                $.each(results, function (ndx, rslt) {
                                    if (rslt["activeMasksetIndex"] == activeMasksetIndex) {
                                        result = rslt;
                                        return false;
                                    }
                                });
                                if (result != undefined) {
                                    var self = this;
                                    setTimeout(function () { opts.onKeyValidation.call(self, result["result"], opts); }, 0);
                                    if (getActiveMaskSet()["writeOutBuffer"] && result["result"] !== false) {
                                        var buffer = getActiveBuffer();

                                        var newCaretPosition;
                                        if (checkval) {
                                            newCaretPosition = undefined;
                                        } else if (opts.numericInput) {
                                            if (p > radixPosition) {
                                                newCaretPosition = seekPrevious(minimalForwardPosition);
                                            } else if (c == opts.radixPoint) {
                                                newCaretPosition = minimalForwardPosition - 1;
                                            } else newCaretPosition = seekPrevious(minimalForwardPosition - 1);
                                        } else {
                                            newCaretPosition = minimalForwardPosition;
                                        }

                                        writeBuffer(input, buffer, newCaretPosition);
                                        if (checkval !== true) {
                                            setTimeout(function () { //timeout needed for IE
                                                if (isComplete(buffer) === true)
                                                    $input.trigger("complete");
                                                skipInputEvent = true;
                                                $input.trigger("input");
                                            }, 0);
                                        }
                                    } else if (isSlctn) {
                                        getActiveMaskSet()["buffer"] = getActiveMaskSet()["undoBuffer"].split('');
                                    }
                                } else if (isSlctn) {
                                    getActiveMaskSet()["buffer"] = getActiveMaskSet()["undoBuffer"].split('');
                                }
                            }

                            if (opts.showTooltip) { //update tooltip
                                $input.prop("title", getActiveMaskSet()["mask"]);
                            }

                            //needed for IE8 and below
                            if (e) e.preventDefault ? e.preventDefault() : e.returnValue = false;
                        }
                    }
                }

                function keyupEvent(e) {
                    var $input = $(this), input = this, k = e.keyCode, buffer = getActiveBuffer();

                    opts.onKeyUp.call(this, e, buffer, opts); //extra stuff to execute on keyup
                    if (k == opts.keyCode.TAB && opts.showMaskOnFocus) {
                        if ($input.hasClass('focus.inputmask') && input._valueGet().length == 0) {
                            buffer = getActiveBufferTemplate().slice();
                            writeBuffer(input, buffer);
                            caret(input, 0);
                            valueOnFocus = getActiveBuffer().join('');
                        } else {
                            writeBuffer(input, buffer);
                            if (buffer.join('') == getActiveBufferTemplate().join('') && $.inArray(opts.radixPoint, buffer) != -1) {
                                caret(input, TranslatePosition(0));
                                $input.click();
                            } else
                                caret(input, TranslatePosition(0), TranslatePosition(getMaskLength()));
                        }
                    }
                }

                function pasteEvent(e) {
                    if (skipInputEvent === true && e.type == "input") {
                        skipInputEvent = false;
                        return true;
                    }

                    var input = this, $input = $(input);
                    //paste event for IE8 and lower I guess ;-)
                    if (e.type == "propertychange" && input._valueGet().length <= getMaskLength()) {
                        return true;
                    }
                    setTimeout(function () {
                        var pasteValue = $.isFunction(opts.onBeforePaste) ? opts.onBeforePaste.call(input, input._valueGet(), opts) : input._valueGet();
                        checkVal(input, false, false, pasteValue.split(''), true);
                        writeBuffer(input, getActiveBuffer());
                        if (isComplete(getActiveBuffer()) === true)
                            $input.trigger("complete");
                        $input.click();
                    }, 0);
                }

                //not used - attempt to support android 
                function mobileInputEvent(e) {
                    var input = this, $input = $(input);

                    //backspace in chrome32 only fires input event - detect & treat
                    var caretPos = caret(input),
                        currentValue = input._valueGet();

                    currentValue = currentValue.replace(new RegExp("(" + escapeRegex(getActiveBufferTemplate().join('')) + ")*"), "");
                    //correct caretposition for chrome
                    if (caretPos.begin > currentValue.length) {
                        caret(input, currentValue.length);
                        caretPos = caret(input);
                    }
                    if ((getActiveBuffer().length - currentValue.length) == 1 && currentValue.charAt(caretPos.begin) != getActiveBuffer()[caretPos.begin]
                        && currentValue.charAt(caretPos.begin + 1) != getActiveBuffer()[caretPos.begin]
                        && !isMask(caretPos.begin)) {
                        e.keyCode = opts.keyCode.BACKSPACE;
                        keydownEvent.call(input, e);
                    } else { //nonnumerics don't fire keypress 
                        checkVal(input, false, false, currentValue.split(''));
                        writeBuffer(input, getActiveBuffer());
                        if (isComplete(getActiveBuffer()) === true)
                            $input.trigger("complete");
                        $input.click();
                    }
                    e.preventDefault();
                }

                function mask(el) {
                    $el = $(el);
                    if ($el.is(":input")) {
                        //store tests & original buffer in the input element - used to get the unmasked value
                        $el.data('_inputmask', {
                            'masksets': masksets,
                            'activeMasksetIndex': activeMasksetIndex,
                            'opts': opts,
                            'isRTL': false
                        });

                        //show tooltip
                        if (opts.showTooltip) {
                            $el.prop("title", getActiveMaskSet()["mask"]);
                        }

                        //correct greedy setting if needed
                        getActiveMaskSet()['greedy'] = getActiveMaskSet()['greedy'] ? getActiveMaskSet()['greedy'] : getActiveMaskSet()['repeat'] == 0;

                        //handle maxlength attribute
                        if ($el.attr("maxLength") != null) //only when the attribute is set
                        {
                            var maxLength = $el.prop('maxLength');
                            if (maxLength > -1) { //handle *-repeat
                                $.each(masksets, function (ndx, ms) {
                                    if (typeof (ms) == "object") {
                                        if (ms["repeat"] == "*") {
                                            ms["repeat"] = maxLength;
                                        }
                                    }
                                });
                            }
                            if (getMaskLength() >= maxLength && maxLength > -1) { //FF sets no defined max length to -1 
                                if (maxLength < getActiveBufferTemplate().length) getActiveBufferTemplate().length = maxLength;
                                if (getActiveMaskSet()['greedy'] == false) {
                                    getActiveMaskSet()['repeat'] = Math.round(maxLength / getActiveBufferTemplate().length);
                                }
                                $el.prop('maxLength', getMaskLength() * 2);
                            }
                        }

                        patchValueProperty(el);

                        if (opts.numericInput) opts.isNumeric = opts.numericInput;
                        if (el.dir == "rtl" || (opts.numericInput && opts.rightAlignNumerics) || (opts.isNumeric && opts.rightAlignNumerics))
                            $el.css("text-align", "right");

                        if (el.dir == "rtl" || opts.numericInput) {
                            el.dir = "ltr";
                            $el.removeAttr("dir");
                            var inputData = $el.data('_inputmask');
                            inputData['isRTL'] = true;
                            $el.data('_inputmask', inputData);
                            isRTL = true;
                        }

                        //unbind all events - to make sure that no other mask will interfere when re-masking
                        $el.unbind(".inputmask");
                        $el.removeClass('focus.inputmask');
                        //bind events
                        $el.closest('form').bind("submit", function () { //trigger change on submit if any
                            if (valueOnFocus != getActiveBuffer().join('')) {
                                $el.change();
                            }
                        }).bind('reset', function () {
                            setTimeout(function () {
                                $el.trigger("setvalue");
                            }, 0);
                        });
                        $el.bind("mouseenter.inputmask", function () {
                            var $input = $(this), input = this;
                            if (!$input.hasClass('focus.inputmask') && opts.showMaskOnHover) {
                                if (input._valueGet() != getActiveBuffer().join('')) {
                                    writeBuffer(input, getActiveBuffer());
                                }
                            }
                        }).bind("blur.inputmask", function () {
                            var $input = $(this), input = this, nptValue = input._valueGet(), buffer = getActiveBuffer();
                            $input.removeClass('focus.inputmask');
                            if (valueOnFocus != getActiveBuffer().join('')) {
                                $input.change();
                            }
                            if (opts.clearMaskOnLostFocus && nptValue != '') {
                                if (nptValue == getActiveBufferTemplate().join(''))
                                    input._valueSet('');
                                else { //clearout optional tail of the mask
                                    clearOptionalTail(input);
                                }
                            }
                            if (isComplete(buffer) === false) {
                                $input.trigger("incomplete");
                                if (opts.clearIncomplete) {
                                    $.each(masksets, function (ndx, ms) {
                                        if (typeof (ms) == "object") {
                                            ms["buffer"] = ms["_buffer"].slice();
                                            ms["lastValidPosition"] = -1;
                                        }
                                    });
                                    activeMasksetIndex = 0;
                                    if (opts.clearMaskOnLostFocus)
                                        input._valueSet('');
                                    else {
                                        buffer = getActiveBufferTemplate().slice();
                                        writeBuffer(input, buffer);
                                    }
                                }
                            }
                        }).bind("focus.inputmask", function () {
                            var $input = $(this), input = this, nptValue = input._valueGet();
                            if (opts.showMaskOnFocus && !$input.hasClass('focus.inputmask') && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue == ''))) {
                                if (input._valueGet() != getActiveBuffer().join('')) {
                                    writeBuffer(input, getActiveBuffer(), seekNext(getActiveMaskSet()["lastValidPosition"]));
                                }
                            }
                            $input.addClass('focus.inputmask');
                            valueOnFocus = getActiveBuffer().join('');
                        }).bind("mouseleave.inputmask", function () {
                            var $input = $(this), input = this;
                            if (opts.clearMaskOnLostFocus) {
                                if (!$input.hasClass('focus.inputmask') && input._valueGet() != $input.attr("placeholder")) {
                                    if (input._valueGet() == getActiveBufferTemplate().join('') || input._valueGet() == '')
                                        input._valueSet('');
                                    else { //clearout optional tail of the mask
                                        clearOptionalTail(input);
                                    }
                                }
                            }
                        }).bind("click.inputmask", function () {
                            var input = this;
                            setTimeout(function () {
                                var selectedCaret = caret(input), buffer = getActiveBuffer();
                                if (selectedCaret.begin == selectedCaret.end) {
                                    var clickPosition = isRTL ? TranslatePosition(selectedCaret.begin) : selectedCaret.begin,
                                        lvp = getActiveMaskSet()["lastValidPosition"],
                                        lastPosition;
                                    if (opts.isNumeric) {
                                        lastPosition = opts.skipRadixDance === false && opts.radixPoint != "" && $.inArray(opts.radixPoint, buffer) != -1 ?
                                            (opts.numericInput ? seekNext($.inArray(opts.radixPoint, buffer)) : $.inArray(opts.radixPoint, buffer)) :
                                            seekNext(lvp);
                                    } else {
                                        lastPosition = seekNext(lvp);
                                    }
                                    if (clickPosition < lastPosition) {
                                        if (isMask(clickPosition))
                                            caret(input, clickPosition);
                                        else caret(input, seekNext(clickPosition));
                                    } else
                                        caret(input, lastPosition);
                                }
                            }, 0);
                        }).bind('dblclick.inputmask', function () {
                            var input = this;
                            setTimeout(function () {
                                caret(input, 0, seekNext(getActiveMaskSet()["lastValidPosition"]));
                            }, 0);
                        }).bind(PasteEventType + ".inputmask dragdrop.inputmask drop.inputmask", pasteEvent
                        ).bind('setvalue.inputmask', function () {
                            var input = this;
                            checkVal(input, true);
                            valueOnFocus = getActiveBuffer().join('');
                            if (input._valueGet() == getActiveBufferTemplate().join(''))
                                input._valueSet('');
                        }).bind('complete.inputmask', opts.oncomplete
                        ).bind('incomplete.inputmask', opts.onincomplete
                        ).bind('cleared.inputmask', opts.oncleared);

                        $el.bind("keydown.inputmask", keydownEvent
                             ).bind("keypress.inputmask", keypressEvent
                             ).bind("keyup.inputmask", keyupEvent);

                        // as the other inputevents aren't reliable for the moment we only base on the input event
                        // needs follow-up
                        if (android || androidfirefox || androidchrome || kindle) {
                            $el.attr("autocomplete", "off")
                            .attr("autocorrect", "off")
                            .attr("autocapitalize", "off")
                            .attr("spellcheck", false);

                            if (androidfirefox || kindle) {
                                $el.unbind("keydown.inputmask", keydownEvent
                                    ).unbind("keypress.inputmask", keypressEvent
                                    ).unbind("keyup.inputmask", keyupEvent);
                                if (PasteEventType == "input") {
                                    $el.unbind(PasteEventType + ".inputmask");
                                }
                                $el.bind("input.inputmask", mobileInputEvent);
                            }
                        }

                        if (msie1x)
                            $el.bind("input.inputmask", pasteEvent);

                        //apply mask
                        var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(el, el._valueGet(), opts) : el._valueGet();
                        checkVal(el, true, false, initialValue.split(''));
                        valueOnFocus = getActiveBuffer().join('');
                        // Wrap document.activeElement in a try/catch block since IE9 throw "Unspecified error" if document.activeElement is undefined when we are in an IFrame.
                        var activeElement;
                        try {
                            activeElement = document.activeElement;
                        } catch (e) {
                        }
                        if (activeElement === el) { //position the caret when in focus
                            $el.addClass('focus.inputmask');
                            caret(el, seekNext(getActiveMaskSet()["lastValidPosition"]));
                        } else if (opts.clearMaskOnLostFocus) {
                            if (getActiveBuffer().join('') == getActiveBufferTemplate().join('')) {
                                el._valueSet('');
                            } else {
                                clearOptionalTail(el);
                            }
                        } else {
                            writeBuffer(el, getActiveBuffer());
                        }

                        installEventRuler(el);
                    }
                }

                //action object
                if (actionObj != undefined) {
                    switch (actionObj["action"]) {
                        case "isComplete":
                            return isComplete(actionObj["buffer"]);
                        case "unmaskedvalue":
                            isRTL = actionObj["$input"].data('_inputmask')['isRTL'];
                            return unmaskedvalue(actionObj["$input"], actionObj["skipDatepickerCheck"]);
                        case "mask":
                            mask(actionObj["el"]);
                            break;
                        case "format":
                            $el = $({});
                            $el.data('_inputmask', {
                                'masksets': masksets,
                                'activeMasksetIndex': activeMasksetIndex,
                                'opts': opts,
                                'isRTL': opts.numericInput
                            });
                            if (opts.numericInput) {
                                opts.isNumeric = opts.numericInput;
                                isRTL = true;
                            }

                            var valueBuffer = actionObj["value"].split('');
                            checkVal($el, false, false, isRTL ? valueBuffer.reverse() : valueBuffer, true);
                            return isRTL ? getActiveBuffer().reverse().join('') : getActiveBuffer().join('');
                        case "isValid":
                            $el = $({});
                            $el.data('_inputmask', {
                                'masksets': masksets,
                                'activeMasksetIndex': activeMasksetIndex,
                                'opts': opts,
                                'isRTL': opts.numericInput
                            });
                            if (opts.numericInput) {
                                opts.isNumeric = opts.numericInput;
                                isRTL = true;
                            }

                            var valueBuffer = actionObj["value"].split('');
                            checkVal($el, false, true, isRTL ? valueBuffer.reverse() : valueBuffer);
                            return isComplete(getActiveBuffer());
                    }
                }
            }
            $.inputmask = {
                //options default
                defaults: {
                    placeholder: "_",
                    optionalmarker: { start: "[", end: "]" },
                    quantifiermarker: { start: "{", end: "}" },
                    groupmarker: { start: "(", end: ")" },
                    escapeChar: "\\",
                    mask: null,
                    oncomplete: $.noop, //executes when the mask is complete
                    onincomplete: $.noop, //executes when the mask is incomplete and focus is lost
                    oncleared: $.noop, //executes when the mask is cleared
                    repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer
                    greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
                    autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
                    clearMaskOnLostFocus: true,
                    insertMode: true, //insert the input or overwrite the input
                    clearIncomplete: false, //clear the incomplete input on blur
                    aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js
                    onKeyUp: $.noop, //override to implement autocomplete on certain keys for example
                    onKeyDown: $.noop, //override to implement autocomplete on certain keys for example
                    onBeforeMask: undefined, //executes before masking the initial value to allow preprocessing of the initial value.  args => initialValue, opts => return processedValue
                    onBeforePaste: undefined, //executes before masking the pasted value to allow preprocessing of the pasted value.  args => pastedValue, opts => return processedValue
                    onUnMask: undefined, //executes after unmasking to allow postprocessing of the unmaskedvalue.  args => maskedValue, unmaskedValue, opts
                    showMaskOnFocus: true, //show the mask-placeholder when the input has focus
                    showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
                    onKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: result, opts
                    skipOptionalPartCharacter: " ", //a character which can be used to skip an optional part of a mask
                    showTooltip: false, //show the activemask as tooltip
                    numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
                    //numeric basic properties
                    isNumeric: false, //enable numeric features
                    radixPoint: "", //".", // | ","
                    skipRadixDance: false, //disable radixpoint caret positioning
                    rightAlignNumerics: true, //align numerics to the right
                    //numeric basic properties
                    definitions: {
                        '9': {
                            validator: "[0-9]",
                            cardinality: 1,
                            definitionSymbol: "*"
                        },
                        'a': {
                            validator: "[A-Za-z\u0410-\u044F\u0401\u0451]",
                            cardinality: 1,
                            definitionSymbol: "*"
                        },
                        '*': {
                            validator: "[A-Za-z\u0410-\u044F\u0401\u04510-9]",
                            cardinality: 1
                        }
                    },
                    keyCode: {
                        ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108,
                        NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91
                    },
                    //specify keycodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF
                    ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
                    getMaskLength: undefined, //override for getMaskLength - args => buffer, greedy, repeat, currentBuffer, opts - return length
            isComplete: undefined //override for isComplete - args => buffer, opts - return true || false
                },
                escapeRegex: function (str) {
                    var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
                    return str.replace(new RegExp('(\\' + specials.join('|\\') + ')', 'gim'), '\\$1');
                },
                format: function (value, options) {
                    var opts = $.extend(true, {}, $.inputmask.defaults, options);
                    resolveAlias(opts.alias, options, opts);
                    return maskScope(generateMaskSets(opts), 0, opts, { "action": "format", "value": value });
                },
                isValid: function (value, options) {
                    var opts = $.extend(true, {}, $.inputmask.defaults, options);
                    resolveAlias(opts.alias, options, opts);
                    return maskScope(generateMaskSets(opts), 0, opts, { "action": "isValid", "value": value });
                }
            };

            $.fn.inputmask = function (fn, options) {
                var opts = $.extend(true, {}, $.inputmask.defaults, options),
                    masksets,
                    activeMasksetIndex = 0;

                if (typeof fn === "string") {
                    switch (fn) {
                        case "mask":
                            //resolve possible aliases given by options
                            resolveAlias(opts.alias, options, opts);
                            masksets = generateMaskSets(opts);
                            if (masksets.length == 0) { return this; }

                            return this.each(function () {
                                maskScope($.extend(true, {}, masksets), 0, opts, { "action": "mask", "el": this });
                            });
                        case "unmaskedvalue":
                            var $input = $(this), input = this;
                            if ($input.data('_inputmask')) {
                                masksets = $input.data('_inputmask')['masksets'];
                                activeMasksetIndex = $input.data('_inputmask')['activeMasksetIndex'];
                                opts = $input.data('_inputmask')['opts'];
                                return maskScope(masksets, activeMasksetIndex, opts, { "action": "unmaskedvalue", "$input": $input });
                            } else return $input.val();
                        case "remove":
                            return this.each(function () {
                                var $input = $(this), input = this;
                                if ($input.data('_inputmask')) {
                                    masksets = $input.data('_inputmask')['masksets'];
                                    activeMasksetIndex = $input.data('_inputmask')['activeMasksetIndex'];
                                    opts = $input.data('_inputmask')['opts'];
                                    //writeout the unmaskedvalue
                                    input._valueSet(maskScope(masksets, activeMasksetIndex, opts, { "action": "unmaskedvalue", "$input": $input, "skipDatepickerCheck": true }));
                                    //clear data
                                    $input.removeData('_inputmask');
                                    //unbind all events
                                    $input.unbind(".inputmask");
                                    $input.removeClass('focus.inputmask');
                                    //restore the value property
                                    var valueProperty;
                                    if (Object.getOwnPropertyDescriptor)
                                        valueProperty = Object.getOwnPropertyDescriptor(input, "value");
                                    if (valueProperty && valueProperty.get) {
                                        if (input._valueGet) {
                                            Object.defineProperty(input, "value", {
                                                get: input._valueGet,
                                                set: input._valueSet
                                            });
                                        }
                                    } else if (document.__lookupGetter__ && input.__lookupGetter__("value")) {
                                        if (input._valueGet) {
                                            input.__defineGetter__("value", input._valueGet);
                                            input.__defineSetter__("value", input._valueSet);
                                        }
                                    }
                                    try { //try catch needed for IE7 as it does not supports deleting fns
                                        delete input._valueGet;
                                        delete input._valueSet;
                                    } catch (e) {
                                        input._valueGet = undefined;
                                        input._valueSet = undefined;

                                    }
                                }
                            });
                            break;
                        case "getemptymask": //return the default (empty) mask value, usefull for setting the default value in validation
                            if (this.data('_inputmask')) {
                                masksets = this.data('_inputmask')['masksets'];
                                activeMasksetIndex = this.data('_inputmask')['activeMasksetIndex'];
                                return masksets[activeMasksetIndex]['_buffer'].join('');
                            }
                            else return "";
                        case "hasMaskedValue": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value 
                            return this.data('_inputmask') ? !this.data('_inputmask')['opts'].autoUnmask : false;
                        case "isComplete":
                            if (this.data('_inputmask')) {
                                masksets = this.data('_inputmask')['masksets'];
                                activeMasksetIndex = this.data('_inputmask')['activeMasksetIndex'];
                                opts = this.data('_inputmask')['opts'];
                                return maskScope(masksets, activeMasksetIndex, opts, { "action": "isComplete", "buffer": this[0]._valueGet().split('') });
                            }
                            else return true;
                        case "getmetadata": //return mask metadata if exists
                            if (this.data('_inputmask')) {
                                masksets = this.data('_inputmask')['masksets'];
                                activeMasksetIndex = this.data('_inputmask')['activeMasksetIndex'];
                                return masksets[activeMasksetIndex]['metadata'];
                            }
                            else return undefined;
                        default:
                            //check if the fn is an alias
                            if (!resolveAlias(fn, options, opts)) {
                                //maybe fn is a mask so we try
                                //set mask
                                opts.mask = fn;
                            }
                            masksets = generateMaskSets(opts);
                            if (masksets.length == 0) { return this; }
                            return this.each(function () {
                                maskScope($.extend(true, {}, masksets), activeMasksetIndex, opts, { "action": "mask", "el": this });
                            });

                            break;
                    }
                } else if (typeof fn == "object") {
                    opts = $.extend(true, {}, $.inputmask.defaults, fn);

                    resolveAlias(opts.alias, fn, opts); //resolve aliases
                    masksets = generateMaskSets(opts);
                    if (masksets.length == 0) { return this; }
                    return this.each(function () {
                        maskScope($.extend(true, {}, masksets), activeMasksetIndex, opts, { "action": "mask", "el": this });
                    });
                } else if (fn == undefined) {
                    //look for data-inputmask atribute - the attribute should only contain optipns
                    return this.each(function () {
                        var attrOptions = $(this).attr("data-inputmask");
                        if (attrOptions && attrOptions != "") {
                            try {
                                attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
                                var dataoptions = $.parseJSON("{" + attrOptions + "}");
                                $.extend(true, dataoptions, options);
                                opts = $.extend(true, {}, $.inputmask.defaults, dataoptions);
                                resolveAlias(opts.alias, dataoptions, opts);
                                opts.alias = undefined;
                                $(this).inputmask(opts);
                            } catch (ex) { } //need a more relax parseJSON
                        }
                    });
                }
            };
        }
    })(jQuery);

